<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTML学习</title>
      <link href="/2021/04/28/html-xue-xi/"/>
      <url>/2021/04/28/html-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="HTML基础学习"><a href="#HTML基础学习" class="headerlink" title="HTML基础学习"></a>HTML基础学习</h2><h3 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h3><ul><li><p>语言标签</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zh-CN<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre></li><li><p>文本格式化标签</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1-h6</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>段落之间有空行    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--换行--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>    纵向区块<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>横向区块<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span></code></pre></li><li><p>图像标签</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>img</span><span class="token punctuation">></span></span></code></pre></li><li><p>超链接</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--_blank则新窗口打开页面，_self则当前窗口打开页面--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">herf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.baidu.com<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--内部链接可以直接使用路径html文件--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">herf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>test.html<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--空链接--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">herf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--下载链接--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">herf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>test.zip<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--网页元素链接--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">herf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--锚点链接 链接到页面内特定位置 herf内容为#则直接返回顶部--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">herf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#FirstPosition<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>&lt;h1 id ="FirstPosition"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span></code></pre></li><li><p>特殊字符</p><table><thead><tr><th>特殊字符</th><th>描述</th><th>字符代码</th></tr></thead><tbody><tr><td>&nbsp;</td><td>空格符</td><td>&amp;nbsp;</td></tr><tr><td>&lt;</td><td>小于号</td><td>&amp;lt;</td></tr><tr><td>&gt;</td><td>大于号</td><td>&amp;gt;</td></tr><tr><td>&amp;</td><td>与符号</td><td>&amp;amp;</td></tr><tr><td>&yen;</td><td>人民币</td><td>&amp;yen;</td></tr><tr><td>&sup3;</td><td>上标</td><td>&amp;sup3;</td></tr></tbody></table></li><li><p>表格标签</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!--   表格对齐方式                表示是否有边框 单元边沿与内容空白像素 单元格之间像素     表格宽度  表格高度--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">align</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left/center/right<span class="token punctuation">"</span></span> <span class="token attr-name">border</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1/0<span class="token punctuation">"</span></span> <span class="token attr-name">cellpadding</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span> <span class="token attr-name">cellspcing</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--必须嵌套table内，定义行--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!--必须嵌套在tr内，定义单元格--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>排名<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>关键词<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>趋势<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>进入搜索<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>最近七日<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>th</span><span class="token punctuation">></span></span>相关链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>th</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--跨行合并单元格数量 需要删除合并得单元格--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">colspan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">rolspan</span><span class="token punctuation">></span></span>鬼吹灯<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>temp.jpg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>没有图<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>123<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>贴吧<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>百科&lt;/a<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--无序列表--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--有序列表 内部元素只可使用li标签--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>名词<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>名词解释1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>名词解释2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">></span></span></code></pre></li><li><p>表单标签</p><blockquote><p>表单一般包括表单域、表单控件、表单信息</p></blockquote><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo.php<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>temp<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--input type可选项--></span>    <span class="token comment" spellcheck="true">&lt;!--定义可点击按钮，可使用JS启动脚本--></span>    "button"    <span class="token comment" spellcheck="true">&lt;!--定义复选框--></span>    "checkbox"    <span class="token comment" spellcheck="true">&lt;!--定义输入字段和"浏览"按键，供文件上传--></span>    "file"    <span class="token comment" spellcheck="true">&lt;!--定义隐藏的输入字段--></span>    "hidden"    <span class="token comment" spellcheck="true">&lt;!--定义图像形式的提交按钮--></span>    "image"    <span class="token comment" spellcheck="true">&lt;!--定义密码字段，字符被掩码--></span>    "password"    <span class="token comment" spellcheck="true">&lt;!--定义单选按钮--></span>    "radio"    <span class="token comment" spellcheck="true">&lt;!--定义重置全部表单数据--></span>    "reset"    <span class="token comment" spellcheck="true">&lt;!--定义提交按钮，将表单数据发送服务端 以restful风格&amp;连接法送服务端--></span>    "submit"    <span class="token comment" spellcheck="true">&lt;!--定义文本--></span>    "text"    <span class="token comment" spellcheck="true">&lt;!-- 表单属性 name为input元素名称 value为表单元素预制值 checked为预制是否选中 maxlength为输入字符最大长度 --></span>    <span class="token comment" spellcheck="true">&lt;!-- 标签绑定一个表单元素，点击label内文本则自动选定按钮 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>用户名:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>test<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>请输入用户名<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>        密码:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pwd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 单选按钮 --></span>    性别：男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 女<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> ???<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 多选按钮 --></span>    是否同意注册:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>是否<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 下拉表单元素 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>选项1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>选项2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span><span class="token punctuation">></span></span>选项3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 默认选项 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>option</span> <span class="token attr-name">selected</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selected<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>选项1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>option</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 文本区域 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code></pre></li></ul><h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li><p>标签选择器</p><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;head>    &lt;style>&lt;!-- 标签选择器，选择全部该标签更改样式 -->        h1 </span><span class="token punctuation">{</span>            <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">12</span>px<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    &lt;/style>&lt;/head></code></pre></li><li><p>类选择器</p><p>类选择器可单标签对应多个类名，可抽离重复代码切片</p><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;head>&lt;style>    <span class="token class">.testCss</span> </span><span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span>        <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">30</span>px<span class="token punctuation">;</span>    <span class="token punctuation">}</span>&lt;/style>&lt;/head>&lt;body>    &lt;h<span class="token number">1</span> class=<span class="token string">"testCss"</span>>标题&lt;/h<span class="token number">1</span>>&lt;/body></code></pre></li><li><p>ID选择器</p><p>通过标签ID进行对应，只可对应一次，不可复用，一般对结构进行定义</p><pre class=" language-css"><code class="language-css"><span class="token selector">&lt;head>&lt;style>    <span class="token id">#testId</span> </span><span class="token punctuation">{</span>        <span class="token property">color</span><span class="token punctuation">:</span> aquamarine<span class="token punctuation">;</span>        <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">30</span>px<span class="token punctuation">;</span>    <span class="token punctuation">}</span>&lt;/style>&lt;/head>&lt;body>    &lt;h<span class="token number">1</span> class=<span class="token string">"testCss"</span>>标题&lt;/h<span class="token number">1</span>>&lt;/body></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 前端基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript入门</title>
      <link href="/2021/04/03/javascript/"/>
      <url>/2021/04/03/javascript/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="JavaScript基础教程"><a href="#JavaScript基础教程" class="headerlink" title="JavaScript基础教程"></a>JavaScript基础教程</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1.简单使用"></a>1.简单使用</h4><ul><li><p>改变HTML内容、属性、CSS样式</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//改变HTML内容</span><span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">"button"</span> onclick<span class="token operator">=</span><span class="token string">'document.getElementById("demo").innerHTML = "Hello JavaScript!"'</span><span class="token operator">></span>改变内容<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token comment" spellcheck="true">//改变HTML标签属性</span><span class="token operator">&lt;</span>button onclick<span class="token operator">=</span><span class="token string">"document.getElementById('myImage').src='/i/eg_bulboff.gif'"</span><span class="token operator">></span>改变属性<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token comment" spellcheck="true">//改变CSS样式</span><span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">"button"</span> onclick<span class="token operator">=</span><span class="token string">"document.getElementById('demo').style.fontSize='35px'"</span><span class="token operator">></span>改变样式<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span></code></pre></li><li><p>隐藏显示HTML元素</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">"button"</span> onclick<span class="token operator">=</span><span class="token string">"document.getElementById('demo').style.display='none'"</span><span class="token operator">></span>隐藏元素<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span></code></pre></li><li><p>在&lt;head&gt;或&lt;body&gt;中的JS脚本</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">function</span> <span class="token function">changeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"段落被更改。"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>h2<span class="token operator">></span>Head 中的 JavaScript<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">></span><span class="token operator">&lt;</span>p id<span class="token operator">=</span><span class="token string">"demo"</span><span class="token operator">></span>一个段落。<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">"button"</span> onclick<span class="token operator">=</span><span class="token string">"changeColor()"</span><span class="token operator">></span>更换颜色<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span><span class="token comment" spellcheck="true">//外部加载或引用JS脚本</span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"myScript.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://www.w3school.com.cn/js/myScript1.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"/js/myScript1.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre></li><li><p>JS输出</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>p id<span class="token operator">=</span><span class="token string">"demo"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>window<span class="token punctuation">.</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre></li><li><p>关键字</p><table><thead><tr><th align="center">关键词</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">break</td><td align="center">终止 switch 或循环。</td></tr><tr><td align="center">continue</td><td align="center">跳出循环并在顶端开始。</td></tr><tr><td align="center">debugger</td><td align="center">停止执行 JavaScript，并调用调试函数（如果可用）。</td></tr><tr><td align="center">do … while</td><td align="center">执行语句块，并在条件为真时重复代码块。</td></tr><tr><td align="center">for</td><td align="center">标记需被执行的语句块，只要条件为真。</td></tr><tr><td align="center">function</td><td align="center">声明函数。</td></tr><tr><td align="center">if … else</td><td align="center">标记需被执行的语句块，根据某个条件。</td></tr><tr><td align="center">return</td><td align="center">退出函数。</td></tr><tr><td align="center">switch</td><td align="center">标记需被执行的语句块，根据不同的情况。</td></tr><tr><td align="center">try … catch</td><td align="center">对语句块实现错误处理。</td></tr><tr><td align="center">var</td><td align="center">声明变量。</td></tr></tbody></table></li><li><p>JS数据类型</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//数字</span><span class="token keyword">var</span> length <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//字符串</span><span class="token keyword">var</span> lastName <span class="token operator">=</span> <span class="token string">"Gates"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数组</span><span class="token keyword">var</span> cars <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Porsche"</span><span class="token punctuation">,</span> <span class="token string">"Volvo"</span><span class="token punctuation">,</span> <span class="token string">"BMW"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对象</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token punctuation">{</span>firstName<span class="token punctuation">:</span><span class="token string">"Bill"</span><span class="token punctuation">,</span> lastName<span class="token punctuation">:</span><span class="token string">"Gates"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//JavaScript为动态类型语言</span><span class="token comment" spellcheck="true">//现在 x 是 undefined</span><span class="token keyword">var</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//现在 x 是数值</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//现在 x 是字符串值</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">"Bill"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Undefined 与 null 的值相等，但类型不相等</span></code></pre></li><li><p>函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">toCelsius</span><span class="token punctuation">(</span>fahrenheit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> carName <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">/</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>fahrenheit<span class="token operator">-</span>carName<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>对象</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>  firstName<span class="token punctuation">:</span> <span class="token string">"Bill"</span><span class="token punctuation">,</span>  lastName <span class="token punctuation">:</span> <span class="token string">"Gates"</span><span class="token punctuation">,</span>  id       <span class="token punctuation">:</span> <span class="token number">678</span><span class="token punctuation">,</span>  fullName <span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//访问对象属性</span>objectName<span class="token punctuation">.</span>propertyNameobjectName<span class="token punctuation">[</span><span class="token string">"propertyName"</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//访问对象方法 若不使用()则返回函数定义</span>objectName<span class="token punctuation">.</span><span class="token function">methodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>name <span class="token operator">=</span> objectName<span class="token punctuation">.</span>methodName<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//避免new字符串、数值或布尔对象，会影响执行速度</span></code></pre></li><li><p>事件</p><blockquote><p>HTML 事件是发生在 HTML 元素上的“事情”。</p><table><thead><tr><th>onchange</th><th>HTML 元素已被改变</th></tr></thead><tbody><tr><td>onclick</td><td>用户点击了 HTML 元素</td></tr><tr><td>onmouseover</td><td>用户把鼠标移动到 HTML 元素上</td></tr><tr><td>onmouseout</td><td>用户把鼠标移开 HTML 元素</td></tr><tr><td>onkeydown</td><td>用户按下键盘按键</td></tr><tr><td>onload</td><td>浏览器已经完成页面加载</td></tr></tbody></table></blockquote></li><li><p>字符串API</p><ul><li>search()与indexOf()方法搜索特定值的字符串，并返回匹配的位置<ul><li>search() 方法无法设置第二个开始位置参数</li><li>indexOf() 方法无法设置更强大的搜索值（正则表达式）</li></ul></li><li>slice(<em>start</em>, <em>end</em>)</li><li>substring(<em>start</em>, <em>end</em>)</li><li>substr(<em>start</em>, <em>length</em>)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合类源码阅读</title>
      <link href="/2020/07/26/java-ji-he-lei/"/>
      <url>/2020/07/26/java-ji-he-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="集合类源码阅读"><a href="#集合类源码阅读" class="headerlink" title="集合类源码阅读"></a>集合类源码阅读</h2><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="继承体系及域"><a href="#继承体系及域" class="headerlink" title="继承体系及域"></a>继承体系及域</h5><ul><li><p>继承Map AbstractMap</p><p>保证代理的使用多继承了Map接口</p></li><li><p>类私有域及类</p><ol><li>初始容量16，最大容量2的30次幂，扩容负载因子0.75</li><li>树化容量8，退化容量6，最小树化容量64</li><li>Node</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper学习笔记</title>
      <link href="/2020/05/24/zookeeper/"/>
      <url>/2020/05/24/zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="Zookeeper基础"><a href="#Zookeeper基础" class="headerlink" title="Zookeeper基础"></a>Zookeeper基础</h3><h4 id="配合使用的中间件"><a href="#配合使用的中间件" class="headerlink" title="配合使用的中间件"></a>配合使用的中间件</h4><ul><li>Hadoop</li><li>HBase</li><li>Kafka</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>配置管理</li><li>DNS服务</li><li>组成员管理</li><li>各种分布式锁</li></ul><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><ul><li><p>层次模型</p><p>便于表达数据之间层次关系，便于为不同应用分配独立的命名空间</p><p>示例：当代表某个app的节点下的某一进程节点存在，则代表进程存在</p></li><li><p>znode分类</p><ul><li><p>持久性</p><p>永久性节点在创建之后即使集群或client宕机依然存在，临时节点在集群宕机或client没有在指定的时间内向集群发消息则消失</p></li><li><p>顺序性</p><p>永久性或临时性节点按名字存在顺序性</p></li></ul></li></ul><h3 id="Zookeeper开发"><a href="#Zookeeper开发" class="headerlink" title="Zookeeper开发"></a>Zookeeper开发</h3><h4 id="Zookeeper总体架构"><a href="#Zookeeper总体架构" class="headerlink" title="Zookeeper总体架构"></a>Zookeeper总体架构</h4><p><strong>standalone</strong></p><p>另包含一个节点</p><h5 id="quorum模式"><a href="#quorum模式" class="headerlink" title="quorum模式"></a>quorum模式</h5><p>包含多个节点，leader节点和follower节点，leader可读写请求，follower只读请求，写将转发给leader</p><ul><li>Session<ol><li>zkcli与集群中某一结点创建session，cli可主动关闭或等待超时后关闭session</li><li>若cli连接出错，则会自动和其他节点建立连接</li></ol></li><li>数据一致性<ol><li>全局可线性化写入，leader决定写请求执行顺序</li><li>客户端FIFO，来自客户端的请求按照发送顺序执行</li></ol></li></ul><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><ul><li><p>Zookeeper类</p><p>全部读取znode数据的API都可设置watch</p><p>全部更新znode的数据的API当version为-1则为无条件版本更新，否则为有条件</p><p>全部方法都有同步异步两个版本</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//节点IP列表，session过期时间，接收集群事件</span><span class="token function">Zookeeper</span><span class="token punctuation">(</span>connectString<span class="token punctuation">,</span>sessionTimeout<span class="token punctuation">,</span>watcher<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建指定路径znode，保存data数据，指定znode类型</span><span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>data<span class="token punctuation">,</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果version匹配，删除znode</span><span class="token function">delete</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>version<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断是否存在，存在则增加watch</span><span class="token function">exists</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>watch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回数据并增加watch</span><span class="token function">getData</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>watch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//若版本匹配，设置znode数据</span><span class="token function">setData</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>data<span class="token punctuation">,</span>version<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回指定znode子节点名字并设置子节点watch</span><span class="token function">getChildren</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>watch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//把客户端session连接节点与leader节点进行同步</span><span class="token function">sync</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span></code></pre><p>常见异常</p><ol><li>KeeperException表示服务端出错，其子类ConnectionLossException表示节点断开连接</li><li>InterruptedException</li></ol><p>watch轮循保证及时获取更新数据</p><p>条件版本更新保证版本不被覆盖</p></li><li><p>实现分布式队列</p><ol><li>建立名称+序号的znode</li><li>offer入队，element出队</li></ol></li><li><p>分布式锁</p><p>create -e /lock   stat -w /lock</p><p>Zookeeper的ephemeral节点特性保证若锁的持有者宕机，锁可以被释放</p><p>实现分布式锁时，连接失败则会进行重试获取；申请锁时会进行排序依次获取，按顺序watch前者，保证不会出现释放锁后导致的惊群效应；释放锁后，后一个watch则会得到通知</p></li><li><p>分布式选举</p><p>类似分布式锁，创建时间戳+线程号的znode，选举请求排序，后缀数字小为leader</p></li></ul><h3 id="Zookeeper运维"><a href="#Zookeeper运维" class="headerlink" title="Zookeeper运维"></a>Zookeeper运维</h3><h3 id="Zookeeper进阶开发"><a href="#Zookeeper进阶开发" class="headerlink" title="Zookeeper进阶开发"></a>Zookeeper进阶开发</h3><h3 id="比较Zookeeper-etcd-Chubby"><a href="#比较Zookeeper-etcd-Chubby" class="headerlink" title="比较Zookeeper,etcd,Chubby"></a>比较Zookeeper,etcd,Chubby</h3><h3 id="设计实践原理"><a href="#设计实践原理" class="headerlink" title="设计实践原理"></a>设计实践原理</h3>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试的艺术</title>
      <link href="/2020/05/22/dan-yuan-ce-shi-de-yi-zhu/"/>
      <url>/2020/05/22/dan-yuan-ce-shi-de-yi-zhu/</url>
      
        <content type="html"><![CDATA[<h1 id="单元测试的艺术"><a href="#单元测试的艺术" class="headerlink" title="单元测试的艺术"></a>单元测试的艺术</h1><h3 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h3><ul><li>单元测试的要求<ol><li>自动化可重复执行</li><li>容易实现</li><li>有复用价值</li><li>运行方便</li><li>结果稳定</li><li>完全隔离</li><li>完全控制单元</li><li>失败后易于定位问题</li></ol></li><li>集成测试</li><li>测试驱动开发（TDD）</li></ul><h3 id="2-第一个单元测试"><a href="#2-第一个单元测试" class="headerlink" title="2.第一个单元测试"></a>2.第一个单元测试</h3><ul><li><p>语法</p><pre class=" language-java"><code class="language-java"><span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertFalse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertSame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertNotNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertNotEquals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">assertNotSame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>AssertThat</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">assertThat</span><span class="token punctuation">(</span>T actual<span class="token punctuation">,</span> Matcher<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> matcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assertThat</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> actual<span class="token punctuation">,</span> matcher<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Matcher</p><p><a href="https://blog.csdn.net/smxjant/article/details/78206435" target="_blank" rel="noopener">https://blog.csdn.net/smxjant/article/details/78206435</a></p><p>一般匹配符</p><p>is anyOf anything allOf not</p><p>字符串匹配符</p><p>containsString endsWith startWith equalTo equalToIgnoringCase </p><p>数值相关匹配符</p><p>closeTo greaterThan lessThan greaterThanOrEqualTo lessThanOrEqualTo</p><p>集合相关匹配符</p><p>hasEntry hasItem hasKey hasValue</p></li><li><p>@Rule</p><p><a href="https://blog.csdn.net/weixin_34399060/article/details/93886426" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34399060/article/details/93886426</a></p><p><strong>Verifier</strong>：所有测试结束后对测试执行结果添加额外的逻辑验证测试最终成功与否。该抽象类为子类提供一个接口方法verify()供扩展</p><p><strong>ErrorCollector</strong>：是Verifier类的一个子类实现，用于在测试执行过程中收集错误信息，不会中断测试，最后调用verify()方法处理。</p><p><strong>TemporaryFolder</strong>：是抽象类ExternalResource的一个子类实现，用于在JUnit测试执行前后，创建和删除临时目录</p><p><strong>TestName</strong>：是抽象类TestWatcher的一个子类实现，用于在测试执行过程中获取测试方法名称。在starting()中记录测试方法名，在getMethodName()中返回</p><p><strong>TestWatcher</strong>：监视测试方法生命周期的各个阶段。该抽象类为子类提供了五个接口方法succeeded(), failed(), skipped(), starting()及finished()供扩展</p><p><strong>Timeout</strong>：与@Test中的timeout相对应，@Test只能修饰待测试方法，Timeout可以修饰待测试类</p><p><strong>ExpectedException</strong>：与@Test中的expected相对应，提供更强大灵活的异常验证功能，@Test只能修饰待测试方法，ExpectedException可以修饰待测试类</p></li></ul><h2 id="3-使用存根破除依赖"><a href="#3-使用存根破除依赖" class="headerlink" title="3.使用存根破除依赖"></a>3.使用存根破除依赖</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>存根是对系统中存在的一个依赖项的可控制的替代物。通过使用存根，</p></blockquote><h3 id="如何破除依赖"><a href="#如何破除依赖" class="headerlink" title="如何破除依赖"></a>如何破除依赖</h3><ol><li>找到被测试对象使用的外部接口或API</li><li>将接口的底层实现替换成能控制的内容</li></ol><h3 id="重构代码设计以提高可测试性"><a href="#重构代码设计以提高可测试性" class="headerlink" title="重构代码设计以提高可测试性"></a>重构代码设计以提高可测试性</h3><ul><li><p>重构</p><p>不改变代码功能的前提下对代码的修改</p></li><li><p>接缝</p><p>是代码中可以插入不同功能的地方</p></li><li><p>重构类型</p><p>可以把具体类抽象成接口或委托；重构使得能够注入委托和接口的伪实现</p></li><li><p>重构思路</p><ol><li>抽取接口使底层可替换</li><li>依赖注入，在被测试单元注入伪实现</li><li>构造函数注入，在构造函数层注入伪对象</li><li>用伪对象模拟异常</li><li>getter,setter注入伪对象</li><li>方法调用前注入伪对象<ul><li>使用工厂类构造</li><li>在发布版本中隐藏接缝</li><li>不同的间接层次</li><li>伪造方法使用局部的工厂方法</li></ul></li></ol></li></ul><h3 id="使用模拟对象进行交互测试"><a href="#使用模拟对象进行交互测试" class="headerlink" title="使用模拟对象进行交互测试"></a>使用模拟对象进行交互测试</h3><ul><li>基于状态的测试</li><li>交互测试</li></ul><h4 id="模拟对象与存根的区别"><a href="#模拟对象与存根的区别" class="headerlink" title="模拟对象与存根的区别"></a>模拟对象与存根的区别</h4><blockquote><p>存根永远不会导致测试失败，模拟对象可以</p></blockquote><p>资料查阅理解：伪对象就是后两者的统称，模拟对象是一种功能更强大的存根，模拟对象会记录交互的状态，不记录交互状态的就是存根</p><p>个人理解：存根面向特定调用过程的结果，模拟对象注重对象状态</p><h3 id="隔离框架"><a href="#隔离框架" class="headerlink" title="隔离框架"></a>隔离框架</h3><h4 id="动态生成伪对象"><a href="#动态生成伪对象" class="headerlink" title="动态生成伪对象"></a>动态生成伪对象</h4><ul><li><p>NSub</p><pre class=" language-c#"><code class="language-c#">ILogger logger = Substitute.For<ILogger>();</code></pre></li><li><p>Mockito</p><pre class=" language-java"><code class="language-java">ILogger logger <span class="token operator">=</span> Mockito<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span>ILogger<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h4 id="模拟值"><a href="#模拟值" class="headerlink" title="模拟值"></a>模拟值</h4><ul><li><p>NSub</p><pre class=" language-c#"><code class="language-c#">IFilenameRules fakeRules = Substitue.For<IFilenameRules>();fakeRules.IsValidLogFileName("strict.txt").Returns(true);</code></pre></li><li><p>Mockito</p><pre class=" language-java"><code class="language-java">IFilenameRules fakeRules <span class="token operator">=</span> Mockito<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span>IFilenameRules<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Mockito<span class="token punctuation">.</span><span class="token function">when</span><span class="token punctuation">(</span>fakeRules<span class="token punctuation">.</span><span class="token function">IsValidLogFileName</span><span class="token punctuation">(</span><span class="token string">"strict.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenReturn</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h4 id="隔离框架的优缺点"><a href="#隔离框架的优缺点" class="headerlink" title="隔离框架的优缺点"></a>隔离框架的优缺点</h4><h4 id="应避免的陷阱"><a href="#应避免的陷阱" class="headerlink" title="应避免的陷阱"></a>应避免的陷阱</h4><ul><li>测试代码不可读</li><li>验证错误的内容</li><li>一个测试多个模拟对象</li><li>过度指定测试</li></ul><h4 id="隔离框架设计反模式"><a href="#隔离框架设计反模式" class="headerlink" title="隔离框架设计反模式"></a>隔离框架设计反模式</h4><ul><li><p>避免概念混淆</p><p>模拟对象与存根不可混用</p></li><li><p>使用Given-when-then模式而非录制重放</p></li><li><p>避免粘性行为</p></li></ul><h3 id="优秀单元测试的支柱"><a href="#优秀单元测试的支柱" class="headerlink" title="优秀单元测试的支柱"></a>优秀单元测试的支柱</h3><p>可靠性、可维护性、可读性</p><h4 id="编写可靠的测试"><a href="#编写可靠的测试" class="headerlink" title="编写可靠的测试"></a>编写可靠的测试</h4><ol><li><p>删除或修改测试</p><p>测试失败的原因：产品缺陷、测试缺陷、语义或API变更、冲突或无效的测试</p></li><li><p>避免测试中的逻辑</p><p>避免循环以及控制逻辑</p></li><li><p>只测试一个关注点</p></li><li><p>分离单元测试与集成测试</p></li><li><p>用CR确保单测覆盖率</p></li></ol><h4 id="编写可维护的测试"><a href="#编写可维护的测试" class="headerlink" title="编写可维护的测试"></a>编写可维护的测试</h4><ul><li><p>测试私有或受保护的方法</p><ul><li>测试的方法设为public</li><li>独立逻辑的方法抽取到新类</li><li>使方法称为静态方法</li><li>使方法称为内部方法</li></ul></li><li><p>去除重复代码</p></li><li><p>以可维护的方法使用setup方法</p><ol><li>避免只在某些测试中使用的初始化对象</li><li>避免冗长难懂</li><li>避免准备伪对象</li><li>停用setup方法</li></ol></li><li><p>实现测试隔离</p><p>坏味道</p><ol><li>强制的测试顺序</li><li>隐藏的测试调用</li><li>共享状态损坏</li><li>外部共享状态损坏</li></ol></li><li><p>避免对不同关注点多次断言</p></li><li><p>对象比较应提高可维护性，如重写toString</p></li><li><p>避免过度指定</p><ol><li>避免纯内部行为</li><li>在需要存根时使用模拟对象</li><li>不必要的顺序指定或精确匹配</li></ol></li></ul><h4 id="编写可读的测试"><a href="#编写可读的测试" class="headerlink" title="编写可读的测试"></a>编写可读的测试</h4><ol><li><p>注意单测命名</p></li><li><p>变量命名</p></li><li><p>有意义的断言</p><p>不要重复测试控制台输出信息</p><p>不要重复测试名中包含的信息</p><p>若无有用信息则无需输出</p><p>提供应发生与未发生的信息</p></li><li><p>断言和操作分离</p></li><li><p>避免滥用setup与teardown</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单元测试 </tag>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核设计与实现</title>
      <link href="/2020/05/21/linux-nei-he-she-ji-yu-shi-xian/"/>
      <url>/2020/05/21/linux-nei-he-she-ji-yu-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul><li><p>Unix特点</p><ol><li>Unix简洁，仅提供几百个明确设计的系统调用</li><li>所有的东西都被当做文件对待，对设备操作均通过open(), read(), write(), lseek(), close()</li><li>内核与相关的系统工具均使用C，移植能力强</li><li>Unix创建线程迅速，拥有fork()系统调用</li><li>简单稳定的进程间通信原语</li></ol></li><li><p>Linux与Unix比较</p><ul><li><p>单内核与多内核</p><p>Unix系统采用全部内核服务运行于大内核地址空间的单内核设计，</p><p>WindowsNT采用微内核设计，采用IPC机制</p></li><li><p>显著差异</p><p>Linux在使用单内核的基础上，补充了模块化设计、抢占式内核、支持内核线程、动态装载内核模块</p></li></ul></li></ul><h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><h3 id="内核开发特点"><a href="#内核开发特点" class="headerlink" title="内核开发特点"></a>内核开发特点</h3><ul><li>不能访问C库及标准的C头文件</li><li>必须使用GNU C<ol><li>内联函数</li><li>内联汇编</li><li>分支声明</li></ol></li><li>无内存保护机制</li><li>难以执行浮点运算</li><li>给每个进程分配的只有很小的定长堆栈</li><li>支持异步中断、抢占和SMP，必须时刻注意同步、并发</li><li>需考虑可移植</li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote><p>进程就是执行期内的程序，是操作系统进行资源调度分配的基本单位</p></blockquote><p>进程的资源包括打开的文件、挂起的信号、内核内部数据、处理器状态、内存地址空间及全局变量数据段</p><blockquote><p>线程是进程中活动的对象，是CPU进行资源分配的最小单位</p></blockquote><h3 id="进程描述符与任务结构"><a href="#进程描述符与任务结构" class="headerlink" title="进程描述符与任务结构"></a>进程描述符与任务结构</h3><blockquote><p>进程的列表以task_struct的形式放入任务队列中</p></blockquote><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> task_struct<span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> state<span class="token punctuation">;</span>    <span class="token keyword">int</span> prio<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> policy<span class="token punctuation">;</span>    <span class="token keyword">struct</span> task_struct <span class="token operator">*</span>parent<span class="token punctuation">;</span>    <span class="token keyword">struct</span> list_head tasks<span class="token punctuation">;</span>    pid_t pid<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> thread_info<span class="token punctuation">{</span>    <span class="token keyword">struct</span> task_struct <span class="token operator">*</span>task<span class="token punctuation">;</span>    <span class="token keyword">struct</span> exec_domain <span class="token operator">*</span>exec_domain<span class="token punctuation">;</span>    __u32 flag<span class="token punctuation">;</span>    __u32 status<span class="token punctuation">;</span>    __u32 cpu<span class="token punctuation">;</span>    <span class="token keyword">int</span> preempt_count<span class="token punctuation">;</span>    mm_segment_t addr_limit<span class="token punctuation">;</span>    stuct restart_block<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>sysenter_return<span class="token punctuation">;</span>    <span class="token keyword">int</span> uaccess_err<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><ul><li>TASK_RUNNING 运行</li><li>TASK_INTERRUPTIBLE 可中断</li><li>TASK_UNINTERRUPTIBLE 不可中断</li><li>__TASK_TRACED 被其他进程跟踪的进程</li><li>__TASK_STOPPED 停止执行</li></ul><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h4><p><strong>clone()调用do_fork()完成创建中的大部分工作，其中调用copy_process()</strong></p><ol><li>调用dup_task_struct()为新进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程的值相同</li><li>检查创建后的资源没有超出用户分配资源限制</li><li>子进程的进程描述符的许多成员被清0或初始值</li><li>子进程状态被设置为TASK_UNITERRUPTIBLE</li><li>调用copy_flags()更新flags成员，调用alloc_pid()分配有效的pid</li><li>拷贝进程的其他资源如打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间</li><li>copy_process()做扫尾工作范围指向子进程的指针</li></ol><h4 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h4><p>不拷贝父进程的页表项，其他与fork()功能相同；vfork()系统调用的实现是通过clone()系统调用一个特殊标志实现</p><ol><li>调用copy_process()，task_struct的vfor_done成员被设置为NULL</li><li>执行do_fork()时，若给定特别标志，vfork_done指定特定地址</li><li>子进程开始执行后，父进程不是马上恢复执行，二十一直等待，知道子进程通过vfork_done指针发送信号</li><li>mm_release()时，进程退出内存地址空间，进程vfork_done是否为空，不为空则发送信号</li><li>回到do_fork()，父进程恢复开始执行</li></ol><h3 id="线程在Linux中的实现"><a href="#线程在Linux中的实现" class="headerlink" title="线程在Linux中的实现"></a>线程在Linux中的实现</h3><blockquote><p>Linux线程拥有唯一隶属于自己的task_struct，对内核而言可视作进程实现</p></blockquote><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><p>与普通进程的创建类似，clone()需额外传递参数标志</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">//线程创建的clone()</span><span class="token function">clone</span><span class="token punctuation">(</span>CLONE_VM <span class="token operator">|</span> CLONE_FS <span class="token operator">|</span> CLONE_FILES <span class="token operator">|</span> CLONE_SIGNAND<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//普通fork()的实现</span><span class="token function">clone</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//普通vfork()实现</span><span class="token function">clone</span><span class="token punctuation">(</span>CLONE_VFORK <span class="token operator">|</span> CLONE_VM <span class="token operator">|</span> SIGCHLD<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h4><p>内核线程与普通线程的区别在于内核线程没有独立的地址空间，只在内核空间运行，从不切换到用户空间去</p><h3 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h3><p>进程终结时，内核释放其资源并告知父线程，终结进程通过调用do_exit()完成</p><ol><li>讲task_struct中的标志成员设置为PF_EXITING</li><li>调用del_timer_sync()删除任一内核定时器，根据返回的结果确保没有定时器在排队，也没有定时器处理程序在运行</li><li>调用exit_mm()函数释放进程占用的mm_struct</li><li>调用sem__exit()函数，如果进程排队等候IPC信号，离开队列</li><li>调用exit_files()和exit_fs()递减文件描述符、文件系统数据的引用计数，若某一项为零则可释放</li><li>exit_code成员中的任务退出代码置为由exit()提供的退出代码</li><li>调用exit_notify()向父进程发送信号，给子进程重新找父进程</li><li>do_exit()调用schedule()切换到新的进程</li></ol><h4 id="删除进程描述符"><a href="#删除进程描述符" class="headerlink" title="删除进程描述符"></a>删除进程描述符</h4><p>release_task()调用完成以下内容</p><ol><li>调用__exit_signal()，其中调用 _unhash_process()调用detach_pid()从pidhash上删除该进程</li><li>_exit_signal()释放目前僵死进程所使用的所有剩余资源</li><li>如果这个进程时线程组最后一个进程，release_task()需通知领头进程的父进程</li><li>release_task()调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放tast_struct所占的slab高速缓存</li></ol><h4 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h4><p>避免进程进入僵死状态耗费内存，给子进程在当前线程组找个一个线程为父进程或init为父进程</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis设计与实现阅读笔记</title>
      <link href="/2020/05/20/redis-she-ji-yu-shi-xian/"/>
      <url>/2020/05/20/redis-she-ji-yu-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis设计与实现"><a href="#Redis设计与实现" class="headerlink" title="Redis设计与实现"></a>Redis设计与实现</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><h3 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h3><h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><p><strong>String</strong></p><p>常用指令set/get/del/incr/decr/incrby/decrby</p><p>字符串处理指令getrange/append/setrange/getbit/setbit/bicount/bitop</p><p><strong>List</strong></p><p>常用指令rpush/lpush/rpop/lpop/lindex/lrange/ltrim</p><p><strong>Set</strong></p><p>常用命令sadd/srem/sismember/scard/smembers/srandnumber/spop/smove</p><p>组合多个集合命令sdiff差集/sdiffstore/sinter交集/sunion并集/sunion</p><p><strong>Hash</strong></p><p>常用命令hmget/hmset/hdel/hlen</p><p>批量命令hexists/hkeys/hvals/hgetall/hincrby/hincrbyfloat</p><p><strong>Zset</strong></p><p>常用命令zadd/zrem/zcard/zincrby/zcount/zrank/zscore/zrange</p><p>范围型命令zrevrank分值排名/zrevrange排名范围排名/zrangebyscore分值范围排名/zremrangebyrank/zremrangebyscore/zinterstore/zunionstore</p><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><ul><li>sort二进制排序命令</li><li>Redis事务<ol><li>multi</li><li>exec</li></ol></li><li>处理过期时间<ol><li>persist移除过期时间</li><li>ttl查看剩余时间</li><li>expire指定过期时间</li><li>expireat指定为unix时间点过期</li><li>pttl查看剩余时间单位为毫秒</li><li>pexpire指定毫秒过期时间</li><li>pexpireat指定毫秒过期时间点</li></ol></li></ul><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><h3 id="基本数据结构与对象"><a href="#基本数据结构与对象" class="headerlink" title="基本数据结构与对象"></a>基本数据结构与对象</h3><h4 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h4><h4 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> sdshdr<span class="token punctuation">{</span>    <span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token keyword">int</span> free<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="SDS与C字符串区别"><a href="#SDS与C字符串区别" class="headerlink" title="SDS与C字符串区别"></a>SDS与C字符串区别</h4><ol><li>常数复杂度获取字符串长度</li><li>杜绝缓冲区溢出</li><li>减少修改字符串时带来的内存重分配次数<ul><li>空间预分配，小value值扩容2倍+1字节</li><li>惰性空间释放，字符串缩短不会立即进行缩容</li></ul></li></ol><h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><p>使用len判断字符串是否结束，buf数组为字节数组由于保存一系列二进制数据</p><h4 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h4><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> listNode<span class="token punctuation">{</span>    <span class="token keyword">struct</span> listNode <span class="token operator">*</span>prev<span class="token punctuation">;</span>    <span class="token keyword">struct</span> listNode <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span>listNode<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> list<span class="token punctuation">{</span>    listNode <span class="token operator">*</span>head<span class="token punctuation">;</span>    listNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>dup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>free<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>match<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>双端链表</li><li>无环</li><li>带表头指针和表尾指针</li><li>链表长度计数器</li><li>多态，可保存不同类型的值</li></ol><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictht<span class="token punctuation">{</span>    dictEntry <span class="token operator">*</span><span class="token operator">*</span>table<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sizemask<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> used<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dictEntry<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">;</span>    <span class="token keyword">union</span><span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token operator">*</span>val<span class="token punctuation">;</span>        unit64_tu64<span class="token punctuation">;</span>        int64_ts64<span class="token punctuation">;</span>    <span class="token punctuation">}</span>v<span class="token punctuation">;</span>    <span class="token keyword">struct</span> dictEntry <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>dictEntry<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> dict<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//类型特定函数；</span>    dictType <span class="token operator">*</span>type<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>privdata<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//哈希表</span>    dictht ht<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//rehash索引</span>    <span class="token keyword">int</span> rehashidx<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>使用MurmurHash2算法</p><h3 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h3><p>使用链地址法，采用头插法</p><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><ol><li>为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量<ul><li>若执行的扩展操作，ht[1]的大小为第一个大于等于ht[0].used*2的2的n次方</li><li>若执行的收缩操作，ht[1]的大小为第一个大于等于ht[0].used*2的2的n次方</li></ul></li><li>将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置</li><li>挡ht[0]包含的所有键值对都迁移到了ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备</li></ol><h4 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h4><ul><li>server没有执行bgsave或bgrewriteaof且哈希表负载因子大于等于1</li><li>server正在执行bgsave或者bgrewriteaof且哈希表负载因子大于等于5</li></ul><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始</li><li>在rehash进行期间，每次对字典进行crud，会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash完成后，将其值+1</li><li>ht[0]全部已rehash至ht[1]时，将rehashidx设为-1，表示rehash操作已完成</li></ol><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><h3 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h3><h4 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h4><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> askiplistNode<span class="token punctuation">{</span>    <span class="token keyword">struct</span> askiplistLevel<span class="token punctuation">{</span>        <span class="token keyword">struct</span> askiplistNode <span class="token operator">*</span>forward<span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> span<span class="token punctuation">;</span>    <span class="token punctuation">}</span>level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> askiplistNode <span class="token operator">*</span>backward<span class="token punctuation">;</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span>    robj <span class="token operator">*</span>obj<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p>层</p><p>每次创建一个新跳跃表节点，根据幂次定律随机生成一个介于1-32的值作为层的高度</p></li><li><p>前进指针</p></li></ul><h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><h4 id="旧版复制"><a href="#旧版复制" class="headerlink" title="旧版复制"></a>旧版复制</h4><ul><li><p>同步</p><ol><li>从服务器向主服务器发送SYNC</li><li>主进行BGSAVE，完成后回传RDB文件</li><li>最后将BGSAVE期间在缓冲区的写命令同步至从服务器</li></ol></li><li><p>命令传播</p><p>将命令传播给各从服务器</p></li></ul><h4 id="新版复制"><a href="#新版复制" class="headerlink" title="新版复制"></a>新版复制</h4><p>完整重同步和部分重同步解决断线问题</p><h5 id="部分重同步实现"><a href="#部分重同步实现" class="headerlink" title="部分重同步实现"></a>部分重同步实现</h5><ul><li>主从服务器各自的复制偏移量</li><li>主的复制积压缓冲区</li><li>服务器运行ID</li></ul>]]></content>
      
      
      <categories>
          
          <category> Nosql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 非关系型数据库 </tag>
            
            <tag> Redis集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka</title>
      <link href="/2020/05/19/kafka-ji-chu/"/>
      <url>/2020/05/19/kafka-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li><p>高吞吐量、低延迟</p><p>每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。</p></li><li><p>可扩展性</p><p>kafka集群支持热扩展</p></li><li><p>持久性、可靠性</p><p>消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</p></li><li><p>容错性</p><p>允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</p></li><li><p>高并发</p><p>支持数千个客户端同时读写</p></li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><p>日志收集</p><p>一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。</p></li><li><p>消息系统</p><p>解耦和生产者和消费者、缓存消息等。</p></li><li><p>用户活动跟踪</p><p>Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</p></li><li><p>运营指标</p><p>Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</p></li><li><p>流式处理</p><p>比如spark streaming和storm</p></li><li><p>事件源</p></li></ul><h4 id="技术优势"><a href="#技术优势" class="headerlink" title="技术优势"></a>技术优势</h4><ul><li><p>可伸缩性</p><ol><li>Kafka集群在运行期间可以轻松的扩展和收缩</li><li>可以扩展一个Kafka主题来包含更多的分区，由于一个分区无法扩展到多个代理，所以它的容量收到代理磁盘空间的限制，能够增加分区和代理的数量意味着单个主题可以存储的数据量是没有限制的</li></ol></li><li><p>容错性和可靠性</p><p>Kafka的设计方式是某个代理的故障能够被集群中的其他代理检测到，由于每个主题都可以在多个代理上复制，所以集群可以在不中断服务的情况下从此类故障中恢复并继续运行</p></li><li><p>吞吐量</p><p>代理能够以超快的速度有效地存储和检索数据</p></li></ul><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><blockquote><p>producer封装数据封装成一个ProducerRecord对象</p></blockquote><h4 id="发送类型"><a href="#发送类型" class="headerlink" title="发送类型"></a>发送类型</h4><ul><li><p>发送即忘记</p><pre class=" language-java"><code class="language-java">producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>同步发送</p><pre class=" language-java"><code class="language-java">producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>record<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>异步发送</p><pre class=" language-java"><code class="language-java">producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>record<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCompletion</span><span class="token punctuation">(</span>RecordMetadata metadata<span class="token punctuation">,</span>Exception exception<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h4 id="序列化器"><a href="#序列化器" class="headerlink" title="序列化器"></a>序列化器</h4><ul><li><p>Serializer接口</p><p>提供了StringSerializer, IntegerSerializer, BytesSerializer</p></li><li><p>自定义序列化器</p></li></ul><h4 id="分区器"><a href="#分区器" class="headerlink" title="分区器"></a>分区器</h4><ul><li><p>分区策略</p><ol><li><p>指定partition时，直接按指定</p></li><li><p>没有指定但包含key，则按key的hash与topic的partition数取余的值</p></li><li><p>均未指定则第一次调用随机生成值，将值按topic的partition总数取</p><p>轮询调度算法的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。</p></li></ol></li><li><p>自定义分区器</p></li></ul><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><ul><li><p>使用场景</p><ol><li>按照某个规则过滤掉不符合要求的消息</li><li>修改消息的内容</li><li>统计类需求</li></ol></li><li><p>自定义拦截器</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProducerInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">ProducerInterceptor</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> sendSuccess <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> sendFailure <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> P <span class="token function">onSend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>    record<span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">timestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>record<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"prefix-"</span><span class="token operator">+</span>record<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>record<span class="token punctuation">.</span><span class="token function">headers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onAcknowledgement</span><span class="token punctuation">(</span>RecordMetadata recordMetadata<span class="token punctuation">,</span> Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            sendSuccess<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>            sendFailure<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h4 id="生产者参数"><a href="#生产者参数" class="headerlink" title="生产者参数"></a>生产者参数</h4><ul><li><p>ACK</p><p>Kafka 为用户提供了三种可靠性级别，用户根据可靠性和延迟的要求进行权衡，选择以下配置</p><ul><li>0表示producer 不等待 broker 的 ack，这提供了最低延迟，broker 一收到数据还没有写入磁盘就已经返回，当 broker 故障时有可能丢失数据</li><li>1表示producer 等待 broker 的 ack，partition 的 leader 落盘成功后返回 ack，如果在 follower 同步成功之前 leader 故障，那么将会丢失数据</li><li>-1表示producer 等待 broker 的 ack，partition 的 leader 和 follower 全部落盘成功后才返回 ack。但是在 broker 发送 ack 时，leader 发生故障，则会造成数据重复</li></ul></li></ul><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><h4 id="订阅分区和主题"><a href="#订阅分区和主题" class="headerlink" title="订阅分区和主题"></a>订阅分区和主题</h4><pre class=" language-java"><code class="language-java">KafkaConsumer<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaConsumer</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>Collections<span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>topic<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>consumer<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TopicPartition</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><p>对于Kafka的分区而言，它的每条消息都有唯一的offset，用来表示消息在分区中的位置</p><p>当我们调用poll()，消息从broker返回消费者，broker并不跟踪这些消息是否被消费者接收，Kafka让消费者自身来管理消费的位移，并向消费者提供更新位移的接口，此种方式称为提交</p><ul><li><p>重复消费</p><p>多个消费者，某个消费者消息唯一还未提交，另一个消费者可能消费到还未提交但已经被消费的消息</p></li><li><p>消息丢失</p><p>消费者消费一部分后宕机，则重启后未消费的部分丢失</p></li><li><p>自动提交</p><p>让消费者管理位移，应用本身不需要显式操作，将enable.auto.commit设置为true，消费者调用poll后每隔五秒提交一次offset，此种方式可能导致重复消费</p></li><li><p>同步提交</p><p>consumer.commitSync();</p></li><li><p>异步提交</p><p>异步提交可能在提交失败后不能进行重试</p></li></ul><h4 id="指定位移消费"><a href="#指定位移消费" class="headerlink" title="指定位移消费"></a>指定位移消费</h4><p>consumer.seek(topic,offset)</p><h4 id="重平衡监听器"><a href="#重平衡监听器" class="headerlink" title="重平衡监听器"></a>重平衡监听器</h4><p>指分区的所属从一个消费者转移到另一个消费者的行为，期间消费者无法拉取消息</p><h4 id="消费者拦截器"><a href="#消费者拦截器" class="headerlink" title="消费者拦截器"></a>消费者拦截器</h4><p>应用于消费到消息或者提交消费位移时进行的一些定制化操作，如设置消息有效期的属性</p><h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><ul><li><p>fetch.min.bytes</p><p>允许消费者指定从broker读取消息时最小的数据量，当小欸这从broker读取消息时，如果数据量小于这个阈值，broker会等待有足够的数据后才会批量返回给消费者。减少broker和消费者的压力</p></li><li><p>fetch.max.wait.ms</p><p>指定了消费者读取时的最长等待时间，避免长时间阻塞，默认500ms</p></li><li><p>max.poll.records</p><p>制定了每个分区返回的最多字节数，默认1M</p></li></ul><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><h4 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h4><pre class=" language-shell"><code class="language-shell">bin/kafka-topics.sh --zookeeper localhost:2181 --create --topic test --replication-factor 1</code></pre><p>参数依次表示为</p><ul><li>zookeeper所在IP，多个使用,分隔</li><li>主题分区数，每个线程处理一个分区数据</li><li>设置主题副本数，每个副本分布在不同节点，不能吃超过总结点数，否则将报错。</li></ul>{% asset_img Topic管理.png Topic管理 %}<h4 id="删除主题"><a href="#删除主题" class="headerlink" title="删除主题"></a>删除主题</h4><pre class=" language-shell"><code class="language-shell">bin/kafka-topic.sh -delete --zookeeper localhost:2181 --topic test</code></pre><p>若delete.topic.enable=true，则直接删除Topic</p><p>若为false，若当前Topic没有传输过信息，则实际删除；若有传输过信息，则标记删除，重启Server后删除</p><h4 id="增加分区"><a href="#增加分区" class="headerlink" title="增加分区"></a>增加分区</h4><pre class=" language-shell"><code class="language-shell">bin/kafka-topics.sh --zookeeper localhost:2181 --topic test --partition 3</code></pre><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><blockquote><p>Kafka可以将主题划分为多个分区，会根据分区规则吧消息存储到哪个分区中，只要分区设置的合理，所有的消息都会均匀的分布到不同的分区中，实现水平扩展和负载均衡。另外，多个订阅者可以从一个或着多个分区中同时消费数据，以支撑海量数据处理。消息追加到分区中，顺序写磁盘效率高于随机写内存</p></blockquote><h4 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h4><p>由于Producer和Consumer都只会与Leader角色的分区副本相连，所以kafka需要以集群的组织形式提供主题下的消息高可用。kafka支持主备复制，所以消息具备高可用和持久性。<br>一个分区可以有多个副本，这些副本保存在不同的broker上。每个分区的副本中都会有一个作为Leader。当一个broker失败时，Leader在这台broker上的分区都会变得不可用，kafka会自动移除Leader，再其他副本中选一个作为新的Leader。<br>在通常情况下，增加分区可以提供kafka集群的吞吐量。然而，也应该意识到集群的总分区数或是单台服务器上的分区数过多，会增加不可用及延迟的风险。</p>{% asset_img Kafka分区.png Kafka分区 %}<h4 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h4><p>如果某个分区的Leader挂了,那么其它跟随者将会进行选举产生一个新的leader,之后所有的读写就会转移到这个新的Leader上,在kafka中,其不是采用常见的多数选举的方式进行副本的Leader选举,而是会在Zookeeper上针对每个Topic维护一个称为ISR（in-sync replica，已同步的副本）的集合,显然还有一些副本没有来得及同步。只有这个ISR列表里面的才有资格成为leader(先使用ISR里面的第一个，如果不行依次类推，因为ISR里面的是同步副本，消息是最完整且各个节点都是一样的)。<br>通过ISR,kafka需要的冗余度较低，可以容忍的失败数比较高。假设某个topic有f+1个副本，kafka可以容忍f个不可用,当然,如果全部ISR里面的副本都不可用,也可以选择其他可用的副本,只是存在数据的不一致。</p><h4 id="重新分区"><a href="#重新分区" class="headerlink" title="重新分区"></a>重新分区</h4><p>步骤</p><ol><li><p>创建一个三节点分区</p><pre class=" language-shell"><code class="language-shell">kafka-topics.sh --create --zookeeper localhost:2181 --topic test --partition 3 -replication-factor 3kafka-topics.sh --describe --zookeeper localhost:2181 --topic test</code></pre></li><li><p>在test主题增加一个分区</p><pre class=" language-shell"><code class="language-shell">kafka-topics.sh --alter --zookeeper localhost:2181 --topic test --partition 4kafka-topics.sh --describe --zookeeper localhost:2181 --topic test</code></pre></li><li><p>再增加一个broker节点</p><pre class=" language-shell"><code class="language-shell">kafka-topics.sh --describe --zookeeper localhost:2181 --topic test</code></pre></li><li><p>重新分配</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"topics"</span><span class="token operator">:</span><span class="token punctuation">[</span>    <span class="token punctuation">{</span><span class="token property">"topic"</span><span class="token operator">:</span><span class="token string">"test"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token property">"version"</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span></code></pre><pre class=" language-shell"><code class="language-shell">kafka-reassign-partition.sh --zookeeper localhost:2181 --topics-to-move-json-file reassign.json --broker-list "0,1,2,3" --generate</code></pre><p>生成两个json串，第一个为当前分区副本分配情况，第二个为重新分配的候选方案（此时为执行重分配</p><p>将生成的json保存到result.json</p></li><li><p>执行重新分配</p><pre class=" language-shell"><code class="language-shell">kafka-reassign-partitions --zookeeper localhost:2181 --reassignment-json-file result.json --excute</code></pre></li></ol><h4 id="分区分配策略"><a href="#分区分配策略" class="headerlink" title="分区分配策略"></a>分区分配策略</h4><ul><li><p>RangeAssignor策略RangeAssignor策略的原理是按照消费者总数和分区总数进行整除运算来获得一个跨度，然后将分区按照跨度进行平均分配，以保证分区尽可能均匀地分配给所有的消费者。对于每一个topic，RangeAssignor策略会将消费组内所有订阅这个topic的消费者按照名称的字典序排序，然后为每个消费者划分固定的分区范围，如果不够平均分配，那么字典序靠前的消费者会被多分配一个分区。</p><p>假设n=分区数/消费者数量，m=分区数%消费者数量，那么前m个消费者每个分配n+1个分区，后面的（消费者数量-m）个消费者每个分配n个分区。</p><p>为了更加通俗的讲解RangeAssignor策略，我们不妨再举一些示例。假设消费组内有2个消费者C0和C1，都订阅了主题t0和t1，并且每个主题都有4个分区，那么所订阅的所有分区可以标识为：t0p0、t0p1、t0p2、t0p3、t1p0、t1p1、t1p2、t1p3。最终的分配结果为：</p><pre><code>消费者C0：t0p0、t0p1、t1p0、t1p1``消费者C1：t0p2、t0p3、t1p2、t1p3</code></pre><p>这样分配的很均匀，那么此种分配策略能够一直保持这种良好的特性呢？我们再来看下另外一种情况。假设上面例子中2个主题都只有3个分区，那么所订阅的所有分区可以标识为：t0p0、t0p1、t0p2、t1p0、t1p1、t1p2。最终的分配结果为：</p><pre><code>消费者C0：t0p0、t0p1、t1p0、t1p1``消费者C1：t0p2、t1p2</code></pre><p>可以明显的看到这样的分配并不均匀，如果将类似的情形扩大，有可能会出现部分消费者过载的情况</p></li><li><p>RoundRobinAssignor策略</p><p>RoundRobinAssignor策略的原理是将消费组内所有消费者以及消费者所订阅的所有topic的partition按照字典序排序，然后通过轮询方式逐个将分区以此分配给每个消费者。RoundRobinAssignor策略对应的partition.assignment.strategy参数值为：org.apache.kafka.clients.consumer.RoundRobinAssignor。</p><p>如果同一个消费组内所有的消费者的订阅信息都是相同的，那么RoundRobinAssignor策略的分区分配会是均匀的。举例，假设消费组中有2个消费者C0和C1，都订阅了主题t0和t1，并且每个主题都有3个分区，那么所订阅的所有分区可以标识为：t0p0、t0p1、t0p2、t1p0、t1p1、t1p2。最终的分配结果为：</p><pre><code>消费者C0：t0p0、t0p2、t1p1``消费者C1：t0p1、t1p0、t1p2</code></pre><p>如果同一个消费组内的消费者所订阅的信息是不相同的，那么在执行分区分配的时候就不是完全的轮询分配，有可能会导致分区分配的不均匀。如果某个消费者没有订阅消费组内的某个topic，那么在分配分区的时候此消费者将分配不到这个topic的任何分区。</p><p>举例，假设消费组内有3个消费者C0、C1和C2，它们共订阅了3个主题：t0、t1、t2，这3个主题分别有1、2、3个分区，即整个消费组订阅了t0p0、t1p0、t1p1、t2p0、t2p1、t2p2这6个分区。具体而言，消费者C0订阅的是主题t0，消费者C1订阅的是主题t0和t1，消费者C2订阅的是主题t0、t1和t2，那么最终的分配结果为：</p><pre><code>消费者C0：t0p0``消费者C1：t1p0``消费者C2：t1p1、t2p0、t2p1、t2p2</code></pre><p>可以看到RoundRobinAssignor策略也不是十分完美，这样分配其实并不是最优解，因为完全可以将分区t1p1分配给消费者C1</p></li><li><p>StickyAssignor分配策略<br>我们再来看一下StickyAssignor策略，“sticky”这个单词可以翻译为“粘性的”，Kafka从0.11.x版本开始引入这种分配策略，它主要有两个目的：</p><p>分区的分配要尽可能的均匀；<br>分区的分配尽可能的与上次分配的保持相同。<br>当两者发生冲突时，第一个目标优先于第二个目标。鉴于这两个目标，StickyAssignor策略的具体实现要比RangeAssignor和RoundRobinAssignor这两种分配策略要复杂很多。我们举例来看一下StickyAssignor策略的实际效果。<br>假设消费组内有3个消费者：C0、C1和C2，它们都订阅了4个主题：t0、t1、t2、t3，并且每个主题有2个分区，也就是说整个消费组订阅了t0p0、t0p1、t1p0、t1p1、t2p0、t2p1、t3p0、t3p1这8个分区。最终的分配结果如下：</p><pre><code>消费者C0：t0p0、t1p1、t3p0``消费者C1：t0p1、t2p0、t3p1``消费者C2：t1p0、t2p1</code></pre><p>这样初看上去似乎与采用RoundRobinAssignor策略所分配的结果相同，但事实是否真的如此呢？再假设此时消费者C1脱离了消费组，那么消费组就会执行再平衡操作，进而消费分区会重新分配。如果采用RoundRobinAssignor策略，那么此时的分配结果如下：</p><pre><code>消费者C0：t0p0、t1p0、t2p0、t3p0``消费者C2：t0p1、t1p1、t2p1、t3p1</code></pre><p>如分配结果所示，RoundRobinAssignor策略会按照消费者C0和C2进行重新轮询分配。而如果此时使用的是StickyAssignor策略，那么分配结果为：</p><pre><code>消费者C0：t0p0、t1p1、t3p0、t2p0``消费者C2：t1p0、t2p1、t0p1、t3p1</code></pre><p>可以看到分配结果中保留了上一次分配中对于消费者C0和C2的所有分配结果，并将原来消费者C1的“负担”分配给了剩余的两个消费者C0和C2，最终C0和C2的分配还保持了均衡。</p><p>如果发生分区重分配，那么对于同一个分区而言有可能之前的消费者和新指派的消费者不是同一个，对于之前消费者进行到一半的处理还要在新指派的消费者中再次复现一遍，这显然很浪费系统资源。StickyAssignor策略如同其名称中的“sticky”一样，让分配策略具备一定的“粘性”，尽可能地让前后两次分配相同，进而减少系统资源的损耗以及其它异常情况的发生。</p></li><li><p>消费者消费消息什么时候重新分配</p><p>当消费者个数发生变的时候</p><ol><li><p>假设topic1有6个分区  三个消费者A、B、C，不管用什么策略分配，假设C负责消费partition4和partition5，突然C挂掉了，这个时候partition4和partition5需不需要消费，答案当然是要，那怎么消费？当然是重新分配</p></li><li><p>假设topic1有6个分区  三个消费者A、B、C、D，当消费者A服务起来的时候6个分区都分配给了A，当B起来的时候重新分配，当C起来时候也会重新分配，消费者A、B、C都分配到了2个partition，当第四个消费者D加进来的时候，会怎么办？还是上面那句话，消费者个数发生变化的时候，就会触发分区分配策略重新分配</p><p>当消费者个数发生变的时候，消费者个数可以增多或者减少，甚至可以增多至比分区数还多的时候，照样会重新分配，只是有些消费者可能被分配不到</p></li></ol></li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul><li><p>特性</p><ul><li><p>每一个partition相当于一个巨型文件被平均分配到多个大小相等的segment数据文件里</p></li><li><p>每一个segment file消息数量不一定相等，这样的特性方便old segment file高速被删除</p></li><li><p>每一个partition仅仅需要支持顺序读写即可，segment文件生命周期由服务端配置参数决定</p></li></ul></li><li><p>存储结构</p><p>segment由两大部分组成，分别为.index .log，分别为索引文件和数据文件</p><p>segment文件命名规则，partition全局的第一个segment从0开始，每一个segment文件名称为上一个segment文件最后一条消息的offset值</p></li></ul><h4 id="日志索引"><a href="#日志索引" class="headerlink" title="日志索引"></a>日志索引</h4><ul><li><p>数据文件的分段</p><p>Kafka解决查询效率的手段之一是将数据文件分段，比如有100条Message，它们的offset是从0到99。假设将数据文件分成5段，第一段为0-19，第二段为20-39，以此类推，每段放在一个单独的数据文件里面，数据文件以该段中最小的offset命名。这样在查找指定offset的Message的时候，用二分查找就可以定位到该Message在哪个段中</p></li><li><p>偏移量索引</p><p>数据文件分段使得可以在一个较小的数据文件中查找对应offset的Message了，但是这依然需要顺序扫描才能找到对应offset的Message。为了进一步提高查找的效率，Kafka为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index</p></li></ul><h4 id="日志清理"><a href="#日志清理" class="headerlink" title="日志清理"></a>日志清理</h4><ul><li><p>日志删除</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 启用删除策略</span><span class="token attr-name">log.clean.policy</span><span class="token punctuation">=</span><span class="token attr-value">delete</span><span class="token comment" spellcheck="true"># 直接删除，删除后的消息不可恢复，可配置以下两个策略</span><span class="token comment" spellcheck="true"># 清理超过指定时间</span><span class="token attr-name">log.retention.hours</span><span class="token punctuation">=</span><span class="token attr-value">16</span><span class="token comment" spellcheck="true"># 超过指定大小后删除旧消息</span><span class="token attr-name">log.retention.bytes</span><span class="token punctuation">=</span><span class="token attr-value">1073741824</span></code></pre></li><li><p>日志压缩</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># broker中启用cleaner</span><span class="token attr-name">log.cleaner.enable</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token comment" spellcheck="true"># Topic中配置启用压缩策略</span><span class="token attr-name">log.cleanup.policy</span><span class="token punctuation">=</span><span class="token attr-value">compact</span></code></pre></li></ul><h4 id="磁盘存储优势"><a href="#磁盘存储优势" class="headerlink" title="磁盘存储优势"></a>磁盘存储优势</h4><ul><li><p>Kafka设计采用了文件追加的方式写入消息，不允许修改已经写入的消息，因此为典型顺序写入，保证了吞吐量</p></li><li><p>大量使用页缓存</p></li><li><p>零拷贝技术</p><p>只用将磁盘文件的数据复制到页面缓存中一次，然后将数据从页面缓存直接发送到网络中（发送给不同的订阅者时，都可以使用同一个页面缓存），避免了重复赋值操作</p></li></ul><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><blockquote><p>Kafka的消息传输保障机制，当producer向broker发送消息时，一旦这条消息commit，由于副本机制的存在，它就不会丢失，但如果producer发送数据给broker后，遇到的网络问题而造成通信中断，那producer就无法判断该条消息是否已经提交。Kafka无法确定网络故障期间的情况，但producer可能retry多次，确保消息已经正确传输到broker中，保证At least one</p></blockquote><h4 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h4><p>简单地说就是对接口的多次调用所产生的结果和调用一次是一致的。生产者在进行重试的时候有可能会重复写入消息，而使用Kafka的幂等性功能之后就可以避免这种情况</p><p>条件</p><ul><li>只能保证 Producer 在单个会话内不丟不重，如果 Producer 出现意外挂掉再重启是无法保证的(幂等性情况下，是无法获取之前的状态信息，因此是无法做到跨会话级别的不丢不重)。</li><li>幂等性不能跨多个 Topic-Partition，只能保证单个 Partition 内的幂等性，当涉及多个 Topic-Partition 时，这中间的状态并没有同步。</li></ul><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>Kafka 从 0.11 版本开始引入了事务支持。事务可以保证 Kafka 在 Exactly Once 语义的基础上，生产和消费可以跨分区和会话，要么全部成功，要么全部失败。</p><ul><li><p>Producer 事务<br>为了实现跨分区跨会话的事务，需要引入一个全局唯一的 Transaction ID，并将 Producer 获得的 PID 和 Transaction ID 绑定。这样当 Producer 重启后就可以通过正在进行的 Transaction ID 获得原来的 PID。<br>为了管理 Transaction，Kafka 引入了一个新的组件 Transaction Coordinator。Producer 就是通过和 Transaction Coordinator 交互获得 Transaction ID 对应的任务状态。Transaction Coordinator 还负责将事务所有写入 Kafka 的一个内部 Topic，这样即使整个服务重启，由于事务状态得到保存，进行中的事务状态可以得到恢复，从而继续进行。</p></li><li><p>Consumer 事务<br>上述事务机制主要是从 Producer 方面考虑，对于 Consumer 而言，事务的保证就会相对较弱，尤其时无法保证 Commit 的信息被精确消费。这是由于 Consumer 可以通过 offset 访问任意信息，而且不同的 Segment File 生命周期不同，同一事务的消息可能会出现重启后被删除的情况。</p></li><li><p>相关API</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//transactionalId配置完毕后，配置初始化事务</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initTransactions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//开启事务</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//为消费者提供事务内的位移提交操作</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendOffsetsToTransaction</span><span class="token punctuation">(</span>MapTopicPartition<span class="token punctuation">,</span> OffsetAndMetadata offsets<span class="token punctuation">,</span> String consumerGroupId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//提交</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">commitTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//回滚事务</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">abortTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><ul><li><p>概述</p><p>kafka集群中会有至少一个broker,会有且只有一个broker被选举为控制器,负责管理集群中所有分区和副本的状态</p><p>如果分区的leader副本出现故障.控制器负责为该分区选举新的leader副本；分区的ISR集合发生变化时,由控制器负责同志所有broker更新数据信息；使用kafka-topics.sh脚本给topic增加分区数量时,还是控制器负责分区的重新分配</p></li><li><p>kafka控制器选举的工作依赖于Zookeeper,成功竞选为控制器的broker会在Zookeeper中创建/controkker这个临时节点</p><ul><li>监听partition相关的变化</li><li>监听topic相关的变化</li><li>监听broker相关的变化</li><li>从Zookeeper中读取获取当前所有和topic,partition和broker有关信息,进行相应的管理</li></ul></li><li><p>zookeeper选举机制</p><p>每个broker启动的时候回尝试去读取/controller节点的brokerId的值,</p><ol><li>如果brokerId不为-1,表示已经有其他的broker节点成功竞选为控制器了,</li><li>如果不存在/controller这个节点.或者这个节点的数据异常,就会尝试去创建这个节点</li><li>只有成功创建/controller这个节点的broker才能成为控制器</li><li>除了竞选成功的broker,其他的broker都会在内存中保存当前控制器的brokerId值,这个可以被标识位activeControllerid</li></ol></li><li><p>zookeeper里面有一个/controller_epoch节点,这个节点是持久节点,在里面存放一个整型的<br>controller_epoch值,用来记录控制器发生变更的次数,也就是控制器的版本，每个和controller交互的请求都会带上controller_epoch,如果这个值不等于内存中controller_epoch值.则说明控制器已经更新了，自己这个请求会被作废,并重新拉取controller_epoch的值保存在内存中.保证一致性</p></li></ul><h4 id="可靠性保证"><a href="#可靠性保证" class="headerlink" title="可靠性保证"></a>可靠性保证</h4><blockquote><p>可靠性保证:确保系统在不同环境下能够发生一致的行为</p></blockquote><ul><li><p>kafka的保证</p><ol><li>保证分区消息的顺序<br>如果使用同一个生产者往同一个分区写入消息,而且消息b在消息a之后写入，kafka可以保证消息b的偏移量比消息a的偏移量大,而且消费组会先读取到a再读取到b</li><li>只有消息被写入分区所有同步副本时,才被认为是已提交<br>生产者可以选择接受不同类型的确认,控制系数acks，只要有一个副本时活跃的,已提交的消息就不会丢失<br>消费组只能读取已经提交的消息</li></ol></li><li><p>副本失效<br>判断副本是否失效,由一个参数replica.lag.time.max.ms默认为10000来控制，当ISR的一个follower副本之后leader副本的时间超过replica.lag.time.max.ms(简称replica)的值,就是判断为失效,被剔除在ISR之外，具体原理为，当follower副本将leader的LEO(log end offset)之前的日志全部同步时,认为follower已经追上了leader副本,会更改这个副本的lastCaughtUpTimeMs标识，kafka的副本管理器(ReplicaManager)启动时会启动副本过期检测的定时任务,而这个定时任务会定时检查当前时间和副本的lastCaughtUpTimeMs之间的差是否大于replica</p></li><li><p>副本复制</p><ul><li><p>复制策略</p><p>半数加一的数量完成同步，就发送ack，延迟低，n个副本选举leader容许n/2台节点故障</p><p>全部完成同步才发送ack，延迟高，选举新leader只要有一台未故障即可</p></li><li><p>副本不同步leader原因<br>副本慢，复制消息跟不上leader的写入,所以被判定失效,从ISR剔除</p><p>副本卡住，由于GC暂停或者follower失效或死亡,都会停止从leader拉取请求</p></li></ul></li></ul><h4 id="一致性保证"><a href="#一致性保证" class="headerlink" title="一致性保证"></a>一致性保证</h4><ul><li><p>旧版</p><p>leader宕机之后,从ISR选举之后,新的leader可以保证HW之前的数据,确保消费者能继续看到HW之前已经提交的数据<br>HW截断机制使新的leader选举之后,为了保证数据一致性,所有follower都将HW之后的数据截断，宕机的leader恢复后,也会将自己的数据在新leader的HW位置之后数据全部截断,保证数据一致性<br>使用HW的话可能会导致数据丢失和数据不一致,因为HW的更新时异步延迟的,需要额外的FETCH请求处理流程才能更新</p></li><li><p>新版解决方案</p><p>Kafka0.11引入了leader epoch取代HW值，Leader端多开辟一段内存区域专门保存leader的epoch信息，保证一致性</p><p>leader epoch实质上是一对值，(epoch,offset)，epoch表示leader的版本号，从0开始，dangleader变更过1次epoch+1，offset对应于改epoch版本的leader写入第一条消息的位移，leaderbroker定期保存缓存，定期写入到checkpoint文件中</p></li></ul><h4 id="消息重复"><a href="#消息重复" class="headerlink" title="消息重复"></a>消息重复</h4><ul><li>生产者端重复<br>生产发送的消息没有收到正确的brok响应,导致producer重试<br>启动kafka的幂等性,修改配置文件:enable.idempotence=true,同时ack = all且retries&gt;1<br>ack=0 ,不重试:可能会丢消息,适用于吞吐量指标重要性高于数据丢失</li><li>消费者重复<br>数据消费完没有及时提交offset到broker<br>取消自动提交:每次消费完或程序退出时手动提交,但是可能也没法保证<br>下游做幂等:比如将offset记录其他地方,做唯一性校验,通过锁,事务等保证</li><li>consumer_offsets<br>consumer_offsets是一个内部topic,保存的是kafka新版本consumer的位移信息，当集群中第一有消费者消费消息时会有自动创建主题_consumer_offsets,分区数可以通过offset.topic.num.partitions参数设定,默认50</li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2020/04/20/git/"/>
      <url>/2020/04/20/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>版本控制</p><p>记录一个或若干文件的内容变化</p><ul><li><p>分布式的版本控制</p><p>Git，本地存储完整的代码仓库，通过压缩算法缩小占用空间</p><p>存放的不是版本与版本之间的差异，存放的是索引，回滚快</p></li><li><p>集中式的版本控制</p><p>SVN，提取最新的更改文件的快照，有可能在中央服务器宕机的情况下丢失期间的更新的内容，甚至可能丢失全部的历史记录，回滚慢</p></li></ul></li><li><p>本地分区</p><ul><li><p>工作区</p><p>即日常代码编写的区域</p></li><li><p>暂存区</p><p>git add的部分做临时存储</p></li><li><p>本地库</p><p>git commit提交的区域，存储历史版本</p></li></ul></li><li><p>本地库与远程库</p><ul><li><p>团队内协作</p><p>clone代码，加入团队后push，其他人pull</p></li><li><p>跨团队协作</p><p>fork代码，push后提交pull request，审核通过后merge</p></li></ul></li></ul><h3 id="Git基本命令"><a href="#Git基本命令" class="headerlink" title="Git基本命令"></a>Git基本命令</h3><h4 id="本地库操作"><a href="#本地库操作" class="headerlink" title="本地库操作"></a>本地库操作</h4><ul><li><p>本地库初始化</p><p>git add，创建.git文件夹，存放本地库相关的子目录与文件</p><p>git config user.name Arthas git config user.email <a href="mailto:Arthas@163.com">Arthas@163.com</a>设置仓库级别</p><p>git config –global user.name Arthas 设置系统级别</p></li></ul><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>查看状态</p><p>git status 查看工作区、暂存区状态</p></li><li><p>新建</p><p>git add 将工作区的新建/修改添加到暂存区</p></li><li><p>查看版本状态</p><p>git log 显示版本  –oneline按部分hash+操作一行显示</p><p>git reflog 查看 历史记录</p></li><li><p>版本前进后退</p><p>git reset –hard hash值 可前进可后退</p><p>git reset –hard HEAD^ 后退一步</p><p>git reset –hard HEAD~3 后退三步</p><ul><li>soft 仅在本地库指针变化</li><li>mixed 在本地库移动指针+重置暂存区</li><li>hard 在本地库移动指针+重置暂存区+重置工作区</li></ul></li><li><p>删除文件找回</p><p>若删除操作已提交 git reset –hard [指针位置]</p><p>若删除操作未提交 git reset –hard HEAD</p></li><li><p>比较文件</p><p>git diff 比较全部文件</p><p>git diff [文件名]比较单一文件</p></li></ul><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><ul><li><p>概述</p><p>版本控制过程中，使用多条线同时推进多个任务</p><img src="/2020/04/20/git/%E5%88%86%E6%94%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="" title="分支工作流程"></li><li><p>优势</p><p>同时并行推进多个功能开发，提高开发效率</p><p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响，失败的分支删除重新开始即可</p></li><li><p>分支操作</p><ul><li><p>创建分支</p><p>git branch [分支名]</p></li><li><p>查看分支</p><p>git branch -v</p></li><li><p>切换分支</p><p>git checkout [分支名]</p></li><li><p>合并分支</p><ol><li><p>切换到接受修改的分支</p><p>git checkout [被合并分支名]</p></li><li><p>执行merge命令</p><p>git merge [有新内容分支名]</p></li></ol></li><li><p>解决冲突</p><ol><li>编辑文件删除特殊符号</li><li>把文件修改到满意的程度，保存退出</li><li>git add [文件名]</li><li>git commit -m “日志信息”（此时commit不能带具体文件名</li></ol></li></ul></li></ul><h3 id="Git原理"><a href="#Git原理" class="headerlink" title="Git原理"></a>Git原理</h3><h4 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h4><p>通过SHA1等算法计算文件差异，进行校验</p><h4 id="Git分支管理机制"><a href="#Git分支管理机制" class="headerlink" title="Git分支管理机制"></a>Git分支管理机制</h4><p>通过指针指向不同分支的记录</p><h3 id="远程库操作"><a href="#远程库操作" class="headerlink" title="远程库操作"></a>远程库操作</h3><ul><li><p>基本操作</p><ul><li><p>链接远程库</p><p>git remote -v查看对应的远程库分支</p><p>git remote add origin <a href="https://github.com/ryougi-shiki0/my.git" target="_blank" rel="noopener">https://github.com/ryougi-shiki0/my.git</a> 将分支链接到远程库分支</p></li><li><p>克隆远程库</p><p>git clone <a href="https://github.com/ryougi-shiki0/my.git" target="_blank" rel="noopener">https://github.com/ryougi-shiki0/my.git</a></p><p>完成了下载到本地、创建origin远程地址别名、初始化本地库</p></li><li><p>解决冲突</p><ol><li>先git pull origin 分支名</li><li>手动修改冲突部分</li><li>git push origin 分支名</li></ol></li><li><p>拉取尽量使用</p><ol><li>git fetch [远程库地址别名][远程分支名]</li><li>git merge [远程库地址别名][远程分支名]</li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
            <tag> 开发规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式复习笔记</title>
      <link href="/2020/03/20/she-ji-mo-shi/"/>
      <url>/2020/03/20/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote><p>使程序具有更好的重用性、可读性、可扩展性、可靠性、呈现高内聚低耦合的特性</p></blockquote><h2 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><blockquote><p>最终目的：</p><p>找出应用中可能需要变化的内容，从不需要变化的部分拆分出来</p><p>针对接口编程，而不是针对实现编程</p><p>为了实现交互对象之间的松耦合设计</p></blockquote><h3 id="单一职责原则SPP"><a href="#单一职责原则SPP" class="headerlink" title="单一职责原则SPP"></a>单一职责原则SPP</h3><ol><li>一个类应只负责一项职责，降低类的复杂度</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>只有逻辑足够简单时可以违反该原则，若类中方法少，可在方法层面保持该原则</li></ol><h3 id="接口隔离原则ISP"><a href="#接口隔离原则ISP" class="headerlink" title="接口隔离原则ISP"></a>接口隔离原则ISP</h3><ul><li>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</li><li>使用原则<ul><li>根据接口隔离原则拆分接口时，首先必须满足单一职责原则： 没有哪个设计可以十全十美的考虑到所有的设计原则，有些设计原则之间就可能出现冲突，就如同单一职责原则和接口隔离原则，一个考虑的是接口的职责的单一性，一个考虑的是方法设计的专业性(尽可能的少)，必然是会出现冲突。在出现冲突时，尽量以单一职责为主，当然这也要考虑具体的情况。</li><li>提高高内聚： 提高接口，类，模块的处理能力，减少对外的交互。比如你给杀手提交了一个订单，要求他在一周之内杀一个人，一周后杀手完成了任务，这种不讲条件完成任务的表现就是高内聚。具体来说就是：要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险就越小，也有利于降低成本。</li><li>定制服务： 单独为一个个体提供优良服务(只提供访问者需要的方法)。</li><li>接口设计要有限度： 根据经验判断</li></ul></li></ul><h3 id="依赖倒转原则DIP"><a href="#依赖倒转原则DIP" class="headerlink" title="依赖倒转原则DIP"></a>依赖倒转原则DIP</h3><ul><li><p>概述</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该以来细节，细节应该依赖抽象</li><li>依赖倒转的中心思想是面向接口编程</li><li>基于抽象比细节更加稳定的设计理念，接口和抽象类负责制定好规范</li></ul></li><li><p>方式</p><ol><li><p>通过接口传递实现依赖</p><pre class=" language-java"><code class="language-java">ChangHong changHong <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChangHong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>OpenAndClose openAndClose <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OpenAndClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>openAndClose<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>changHong<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>通过构造方法依赖传递</p><pre class=" language-java"><code class="language-java">ChangHong changHong <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChangHong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>OpenAndClose openAndClose <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OpenAndClose</span><span class="token punctuation">(</span>changHong<span class="token punctuation">)</span><span class="token punctuation">;</span>openAndClose<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>通过setter方法传递</p><pre class=" language-java"><code class="language-java">ChangHong changHong <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChangHong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>OpenAndClose openAndClose <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OpenAndClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>openAndClose<span class="token punctuation">.</span><span class="token function">setTv</span><span class="token punctuation">(</span>changHong<span class="token punctuation">)</span><span class="token punctuation">;</span>openAndClose<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol></li><li><p>注意事项</p><ol><li>底层模块尽量都要有接口或抽象类或两者都有</li><li>变量的声明类型尽量是抽象类或接口，作为缓冲层，有利于程序扩展优化</li><li>继承时遵循里氏替换原则</li></ol></li></ul><h3 id="里氏替换原则LSP"><a href="#里氏替换原则LSP" class="headerlink" title="里氏替换原则LSP"></a>里氏替换原则LSP</h3><ul><li>概述<ul><li>所有引用基类的地方必须能透明地使用其子类的对象</li><li>子类中尽量不要重写父类的方法</li><li>通过聚合、组合、依赖来解决问题</li></ul></li><li>使用基类代替直接继承</li></ul><h3 id="开闭原则OCP"><a href="#开闭原则OCP" class="headerlink" title="开闭原则OCP"></a>开闭原则OCP</h3><ul><li><p>概述</p><ul><li>最基础最重要的设计原则</li><li>函数模块对扩展开放、对修改关闭，用抽象构建框架，实现构建细节</li><li>通过扩展实体的实现变化，而不是修改已有</li></ul></li><li><p>方式</p><p>扩展时直接扩展一个新类继承原有抽象类，调用时直接传入新类实例</p></li></ul><h3 id="迪米特法则DP"><a href="#迪米特法则DP" class="headerlink" title="迪米特法则DP"></a>迪米特法则DP</h3><ul><li><p>概述</p><ol><li>一个对象应该对其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>即对于被依赖的类，无论多么复杂，都应尽量保证将逻辑封装在类的内部，对外除了提供的public方法，不泄露任何信息</li><li>概括为只与直接的朋友通信</li></ol></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//管理学院员工的管理类</span><span class="token keyword">class</span> <span class="token class-name">CollegeManager</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//返回学院的所有员工</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>CollegeEmployee<span class="token operator">></span> <span class="token function">getAllEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>CollegeEmployee<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>CollegeEmployee<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这里我们增加了10个员工到 list</span>            CollegeEmployee emp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CollegeEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            emp<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token string">"学院员工id= "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>emp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//输出学院员工的信息</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取到学院员工</span>        List<span class="token operator">&lt;</span>CollegeEmployee<span class="token operator">></span> list1 <span class="token operator">=</span> <span class="token function">getAllEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------------学院员工------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>CollegeEmployee e <span class="token operator">:</span> list1<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//学校管理类</span><span class="token comment" spellcheck="true">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span><span class="token comment" spellcheck="true">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 </span><span class="token keyword">class</span> <span class="token class-name">SchoolManager</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//返回学校总部的员工</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> <span class="token function">getAllEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Employee<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这里我们增加了5个员工到 list</span>            Employee emp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            emp<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token string">"学校总部员工id= "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>emp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> list<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//该方法完成输出学校总部和学院员工信息(id)</span>    <span class="token keyword">void</span> <span class="token function">printAllEmployee</span><span class="token punctuation">(</span>CollegeManager sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//分析问题</span>        <span class="token comment" spellcheck="true">//1. 将输出学院的员工方法，封装到CollegeManager</span>        sub<span class="token punctuation">.</span><span class="token function">printEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取到学校总部员工</span>        List<span class="token operator">&lt;</span>Employee<span class="token operator">></span> list2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAllEmployee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------------学校总部员工------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Employee e <span class="token operator">:</span> list2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>注意</p><p>该法则为了降低类之间耦合，但不能消除</p></li></ul><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>尽量使用聚合、组合而不是继承</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><h3 id="UML类图关系"><a href="#UML类图关系" class="headerlink" title="UML类图关系"></a>UML类图关系</h3><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><ul><li>类中用到了对方，则之间存在依赖关系<ul><li>包括成员属性</li><li>返回类型</li><li>接收的参数类型</li><li>方法中使用到</li></ul></li></ul><h4 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h4><ul><li><p>即继承关系，为依赖的特例</p></li><li><p>实现接口</p></li></ul><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><ul><li>类与类的联系，依赖关系的特例<ul><li>导航性</li><li>多重性</li></ul></li></ul><h4 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h4><ul><li>整体和部分的关系（成员即聚合），关联关系的特例，整体与部分不可分离</li></ul><h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><ul><li>整体与部分的关系，整体与部分不可分离</li></ul><h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><ul><li><p>静态常量</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Singleton instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>静态代码块</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Singeton</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span><span class="token punctuation">{</span>        instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>优劣</p><ul><li>简单，线程安全</li><li>占用内存</li></ul></li></ul><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><ul><li><p>静态变量</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//双重校验锁</span><span class="token keyword">class</span> <span class="token class-name">Singeton</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>外层if减少了已实例化时进入synchronized的monitor管程的开销</p></li><li><p>静态内部类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Singeton</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> innerClass<span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> innerClass<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>利用JVM类装载机制保证线程安全，类初始化时，其他线程无法进入</p></li><li><p>枚举</p><pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> Singleton<span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h4 id="JDK中的使用"><a href="#JDK中的使用" class="headerlink" title="JDK中的使用"></a>JDK中的使用</h4><ul><li>Runtime类</li><li>java.lang.System#getSecurityManager()</li><li>常用场景<ul><li>Logger Classes</li><li>Configuration Classes</li><li>Accesing resources in shared mode</li><li>Factories implemented as Singletons</li></ul></li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="简单工厂模式（静态工厂）"><a href="#简单工厂模式（静态工厂）" class="headerlink" title="简单工厂模式（静态工厂）"></a>简单工厂模式（静态工厂）</h4><ul><li><p>概述</p><p>由工厂判断创建的商品类型，在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Pizza <span class="token function">createPizza2</span><span class="token punctuation">(</span>String orderType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Pizza pizza <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>orderType<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"greek"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pizza <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GreekPizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pizza<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">" 希腊披萨 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>orderType<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"cheese"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pizza <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CheesePizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pizza<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">" 奶酪披萨 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>orderType<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"pepper"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pizza <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PepperPizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pizza<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"胡椒披萨"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pizza<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><ul><li><p>概述</p><p>定义了一个创建对象的抽象方法，由子类决定要实例化的类，将对象的实例化推迟到子类</p></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">OrderPizza</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//定义一个抽象方法，createPizza , 让各个工厂子类自己实现</span>    <span class="token keyword">abstract</span> Pizza <span class="token function">createPizza</span><span class="token punctuation">(</span>String orderType<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造器</span>    <span class="token keyword">public</span> <span class="token function">OrderPizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Pizza pizza <span class="token operator">=</span> null<span class="token punctuation">;</span>        String orderType<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 订购披萨的类型</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            orderType <span class="token operator">=</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pizza <span class="token operator">=</span> <span class="token function">createPizza</span><span class="token punctuation">(</span>orderType<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//抽象方法，由工厂子类完成</span>            <span class="token comment" spellcheck="true">//输出pizza 制作过程</span>            pizza<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pizza<span class="token punctuation">.</span><span class="token function">bake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pizza<span class="token punctuation">.</span><span class="token function">cut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pizza<span class="token punctuation">.</span><span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 写一个方法，可以获取客户希望订购的披萨种类</span>    <span class="token keyword">private</span> String <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            BufferedReader strin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"input pizza 种类:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String str <span class="token operator">=</span> strin<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> str<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LDOrderPizza</span> <span class="token keyword">extends</span> <span class="token class-name">OrderPizza</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    Pizza <span class="token function">createPizza</span><span class="token punctuation">(</span>String orderType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Pizza pizza <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>orderType<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"cheese"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pizza <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LDCheesePizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>orderType<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"pepper"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pizza <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LDPepperPizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> pizza<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BJOrderPizza</span> <span class="token keyword">extends</span> <span class="token class-name">OrderPizza</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    Pizza <span class="token function">createPizza</span><span class="token punctuation">(</span>String orderType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Pizza pizza <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"cheese"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>orderType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pizza <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BJCheesePizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"pepper"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>orderType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pizza <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BJPepperPizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> pizza<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><ul><li><p>概述</p><p>定义了一个接口用于创建相关或有依赖的对象族，而无需指明具体的类，是对简单工厂的改进。将工厂抽象成两层，抽象工厂和具体实现的工厂子类，将单个的简单工厂变成了工厂族，方便代码的维护和扩展</p></li></ul><img src="/2020/03/20/she-ji-mo-shi/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E7%B1%BB%E5%9B%BE.png" class="" title="抽象工厂类图"><ul><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AbsFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//让下面的工厂子类来 具体实现</span>    Pizza <span class="token function">createPizza</span><span class="token punctuation">(</span>String orderType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//这是工厂子类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BJFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbsFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Pizza <span class="token function">createPizza</span><span class="token punctuation">(</span>String orderType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"~使用的是抽象工厂模式~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        Pizza pizza <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"cheese"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>orderType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pizza <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BJCheesePizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"pepper"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>orderType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            pizza <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BJPepperPizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pizza<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LDFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbsFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Pizza <span class="token function">createPizza</span><span class="token punctuation">(</span>String orderType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"~使用的是抽象工厂模式~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Pizza pizza <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>orderType<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"cheese"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pizza <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LDCheesePizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>orderType<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"pepper"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pizza <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LDPepperPizza</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> pizza<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderPizza</span> <span class="token punctuation">{</span>    AbsFactory factory<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造器</span>    <span class="token keyword">public</span> <span class="token function">OrderPizza</span><span class="token punctuation">(</span>AbsFactory factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setFactory</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setFactory</span><span class="token punctuation">(</span>AbsFactory factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Pizza pizza <span class="token operator">=</span> null<span class="token punctuation">;</span>        String orderType <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用户输入</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>factory <span class="token operator">=</span> factory<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            orderType <span class="token operator">=</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// factory 可能是北京的工厂子类，也可能是伦敦的工厂子类</span>            pizza <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createPizza</span><span class="token punctuation">(</span>orderType<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pizza <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 订购ok</span>                pizza<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                pizza<span class="token punctuation">.</span><span class="token function">bake</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                pizza<span class="token punctuation">.</span><span class="token function">cut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                pizza<span class="token punctuation">.</span><span class="token function">box</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"订购失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 写一个方法，可以获取客户希望订购的披萨种类</span>    <span class="token keyword">private</span> String <span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            BufferedReader strin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"input pizza 种类:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String str <span class="token operator">=</span> strin<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> str<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PizzaStore</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token comment" spellcheck="true">//new OrderPizza(new BJFactory());</span>        <span class="token keyword">new</span> <span class="token class-name">OrderPizza</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LDFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h4 id="JDK中的使用-1"><a href="#JDK中的使用-1" class="headerlink" title="JDK中的使用"></a>JDK中的使用</h4><ul><li><p>Calendar</p><pre class=" language-java"><code class="language-java">Calendar calendar<span class="token operator">=</span>Calendar<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">createCalendar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><ul><li><p>概述</p><p>用原型实例创建指定种类的对象，通过拷贝这些原型创建新的对象</p></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Prototype</span> <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> Prototype <span class="token function">myClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcretePrototype</span> <span class="token keyword">extends</span> <span class="token class-name">Prototype</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String filed<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcretePrototype</span><span class="token punctuation">(</span>String filed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>filed <span class="token operator">=</span> filed<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    Prototype <span class="token function">myClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span>filed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> filed<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Prototype prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcretePrototype</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Prototype clone <span class="token operator">=</span> prototype<span class="token punctuation">.</span><span class="token function">myClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clone<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>优劣</p><ul><li>创建新的对象复杂时，可以简化创建过程，提高效率</li><li>不用重新初始化对象，动态获取对象运行时状态</li><li>需要为每个类实现clone()方法，违背了ocp原则</li></ul></li></ul><h4 id="Spring中的使用"><a href="#Spring中的使用" class="headerlink" title="Spring中的使用"></a>Spring中的使用</h4><ul><li><p>prototype标签</p><pre class=" language-java"><code class="language-java"><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">doGetBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//最终调用</span>prototypeInstance<span class="token operator">=</span><span class="token function">createBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h4 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h4><ul><li><p>浅拷贝</p><p>默认的clone()方法，基本数据类型进行值传递，对象则进行引用传递</p></li><li><p>深拷贝</p><p>通过重写clone()方法或序列化对象实现</p></li><li><p>序列化实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建流对象</span>ByteArrayOutputStream bos <span class="token operator">=</span> null<span class="token punctuation">;</span>ObjectOutputStream oos <span class="token operator">=</span> null<span class="token punctuation">;</span>ByteArrayInputStream bis <span class="token operator">=</span> null<span class="token punctuation">;</span>ObjectInputStream ois <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//序列化</span>    bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">)</span><span class="token punctuation">;</span>    oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//当前这个对象以对象流的方式输出</span>    <span class="token comment" spellcheck="true">//反序列化</span>    bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bis<span class="token punctuation">)</span><span class="token punctuation">;</span>    DeepProtoType copyObj <span class="token operator">=</span> <span class="token punctuation">(</span>DeepProtoType<span class="token punctuation">)</span>ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> copyObj<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// TODO: handle exception</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//关闭流</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        bos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        oos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ois<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO: handle exception</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e2<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><ul><li><p>概述</p><p>将复杂对象的建造过程抽离出来，使这个抽象过程的不同实现方法可以构造出不同的表现的对象</p><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p><p>而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p></li><li><p>四个角色</p><ul><li>Product</li><li>Builder</li><li>ConcreteBuilder</li><li>Director</li></ul></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 抽象的建造者</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">HouseBuilder</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> House house <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">House</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将建造的流程写好, 抽象的方法</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildBasic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildWalls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">roofed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//建造房子好， 将产品(房子) 返回</span>    <span class="token keyword">public</span> House <span class="token function">buildHouse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> house<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HighBuilding</span> <span class="token keyword">extends</span> <span class="token class-name">HouseBuilder</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildBasic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildWalls</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">roofed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>注意</p><ol><li>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则”</li><li>产品之间差异性很大的情况：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>产品内部变化很复杂的情况： 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ol></li></ul><h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><ul><li><p>概述</p><p>将某个类的接口转换成客户端期望的另一个接口标识，主要是为了兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作（也称为包装器</p></li><li><p>分类</p><ul><li>类适配器模式</li><li>对象适配器模式</li><li>接口适配器模式</li></ul></li><li><p>实现</p><ul><li><p>类适配器</p><p>需要继承src类，适配的dst需要为接口，src类的方法在在Adapter会暴露，增加了使用成本</p><p>可以重写src类的方法，增强了灵活性</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VoltageAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">Voltage220V</span> <span class="token keyword">implements</span> <span class="token class-name">IVoltage5V</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">output5V</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token comment" spellcheck="true">//获取到220V电压</span>        <span class="token keyword">int</span> srcV <span class="token operator">=</span> <span class="token function">output220V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dstV <span class="token operator">=</span> srcV <span class="token operator">/</span> <span class="token number">44</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//转成 5v</span>        <span class="token keyword">return</span> dstV<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>对象适配器</p><p>将src类做修改，持有src类，实现dst接口。遵循了合成复用原则，用关联关系替代继承，较为常用</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VoltageAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">IVoltage5V</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 关联关系-聚合</span>    <span class="token keyword">private</span> Voltage220V voltage220V<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">output5V</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> dst <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> voltage220V<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> src <span class="token operator">=</span> voltage220V<span class="token punctuation">.</span><span class="token function">output220V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取220V 电压</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用对象适配器，进行适配~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dst <span class="token operator">=</span> src <span class="token operator">/</span> <span class="token number">44</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"适配完成，输出的电压为="</span> <span class="token operator">+</span> dst<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dst<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>接口适配器</p><p>或称缺省适配器模式，在不需要使用接口的全部方法时，设计一个抽象类为每个方法提供默认的空方法实现，则该抽象类的子类可以选择性的覆盖某些方法来实现需求</p><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbsAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">Interface4</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span>    AbsAdapter absAdapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AbsAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//只需要去覆盖我们 需要使用 接口方法</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"使用了m1的方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><p>Spring中的使用</p><p>每种Controller都有一种对应的适配器实现类，适配器代替controller执行相应的方法，扩展Controller时仅需增加适配器类即可扩展</p><p>HandlerAdapter</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DispatchServlet</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>HandlerAdapter<span class="token operator">></span> handlerAdapters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>HandlerAdapter<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DispatchServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        handlerAdapters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AnnotationHandlerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handlerAdapters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpHandlerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handlerAdapters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleHandlerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doDispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 此处模拟SpringMVC从request取handler的对象，</span>        <span class="token comment" spellcheck="true">// 适配器可以获取到希望的Controller</span>         HttpController controller <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// AnnotationController controller = new AnnotationController();</span>        <span class="token comment" spellcheck="true">//SimpleController controller = new SimpleController();</span>        <span class="token comment" spellcheck="true">// 得到对应适配器</span>        HandlerAdapter adapter <span class="token operator">=</span> <span class="token function">getHandler</span><span class="token punctuation">(</span>controller<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过适配器执行对应的controller对应方法</span>        adapter<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>controller<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> HandlerAdapter <span class="token function">getHandler</span><span class="token punctuation">(</span>Controller controller<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//遍历：根据得到的controller(handler), 返回对应适配器</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>HandlerAdapter adapter <span class="token operator">:</span> handlerAdapters<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>adapter<span class="token punctuation">.</span><span class="token function">supports</span><span class="token punctuation">(</span>controller<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> adapter<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>注意事项</p><ul><li>通过src传递给Adapter的方式命名，类、对象、接口</li><li>实现不兼容的接口融合工作</li></ul></li></ul><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><ul><li><p>概述</p><p>将实现和抽象放在两个不同的类层次中，是的两个层次可以独立改变</p><p>基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责，保持各部分的独立性以及应对他们的功能扩展</p></li><li><p>类图说明</p><ul><li>Client类为调用者</li><li>抽象类维护了Implemetor即它的实现类</li><li>RefinedAbstraction为抽象类的子类</li><li>Implementor为行为实现类的接口</li><li>ConcreteImplemetor为行为的具体实现类</li><li>抽象类和接口是聚合关系</li></ul></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Brand</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//组合品牌</span>    <span class="token keyword">private</span> Brand brand<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//构造器</span>    <span class="token keyword">public</span> <span class="token function">Phone</span><span class="token punctuation">(</span>Brand brand<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>brand <span class="token operator">=</span> brand<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>brand<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        brand<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        brand<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取折叠式手机 (样式 + 品牌 )</span>        Phone phone1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FoldedPhone</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">XiaoMi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        phone1<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        phone1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        phone1<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        UpRightPhone phone4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UpRightPhone</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Vivo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        phone4<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        phone4<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        phone4<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p>JDK中的使用</p><img src="/2020/03/20/she-ji-mo-shi/JDBC%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" class="" title="JDBC桥接模式"></li><li><p>注意事项</p><ol><li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统</li><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其他的部分由具体业务来完成</li><li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本</li><li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</li><li>桥接模式要求正确识别出系统中两个独立变化的纬度，因此其使用范围有一定的局限性，即需要有这样的应用场景</li></ol></li><li><p>应用场景</p><p>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式很适用</p><p>常见的应用场景：</p><ul><li>JDBC驱动程序<ul><li>银行转账系统转账分类：网上转账、柜台转账、AMT转账</li><li>转账用户类型：普通用户、银卡用户、金卡用户</li></ul></li><li>消息管理<ul><li>消息类型：即时消息、延时消息</li><li>消息分类：手机短信、邮件消息、QQ消息</li></ul></li></ul></li></ul><h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><ul><li><p>概述</p><p>装饰者模式是动态地将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则（ocp）</p><p>装饰者模式就像打包一个快递，主体：比如陶瓷、衣服；包装：比如报纸填充、塑料泡沫、纸板、木板</p><ul><li>Component：主体，比如下面的Drink</li><li>ConcreteComponent：具体的主体，比如下面的各个单品咖啡</li><li>Decorator：装饰者，比如各调料</li><li>在如图的Component与ConcreteComponent之间，如果ConcreteComponent类很多，还可以设计一个缓冲层，将共有的部分提取出来，抽象成一个类</li></ul></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Decorator</span> <span class="token keyword">extends</span> <span class="token class-name">Drink</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Drink obj<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//组合</span>    <span class="token keyword">public</span> <span class="token function">Decorator</span><span class="token punctuation">(</span>Drink obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LongBlack</span> <span class="token keyword">extends</span> <span class="token class-name">Coffee</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">LongBlack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setDes</span><span class="token punctuation">(</span><span class="token string">" longblack "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setPrice</span><span class="token punctuation">(</span><span class="token number">5.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Coffee</span> <span class="token keyword">extends</span> <span class="token class-name">Drink</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Drink</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String des<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">float</span> price <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getDes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> des<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDes</span><span class="token punctuation">(</span>String des<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>des <span class="token operator">=</span> des<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> price<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPrice</span><span class="token punctuation">(</span><span class="token keyword">float</span> price<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//计算费用的抽象方法</span>    <span class="token comment" spellcheck="true">//子类来实现</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">float</span> <span class="token function">cost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 装饰者模式下的订单：2份巧克力+一份牛奶的LongBlack</span>        <span class="token comment" spellcheck="true">// 1. 点一份 LongBlack</span>        Drink order <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongBlack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2. order 加入一份牛奶</span>        order <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Milk</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3. order 加入一份巧克力</span>        order <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Chocolate</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3. order 加入一份巧克力</span>        order <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Chocolate</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>JDK应用</p><img src="/2020/03/20/she-ji-mo-shi/InputStream%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" class="" title="InputStream装饰者模式"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的JVM实现(一)</title>
      <link href="/2020/02/19/cong-ling-kai-shi-de-jvm-shi-xian/"/>
      <url>/2020/02/19/cong-ling-kai-shi-de-jvm-shi-xian/</url>
      
        <content type="html"><![CDATA[<h3 id="JCommander"><a href="#JCommander" class="headerlink" title="JCommander"></a>JCommander</h3><blockquote><p>JCommander是Java解析命令行参数的工具，作者cebust</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>注解驱动<br>它的核心功能<strong>命令行参数定义</strong>是基于注解的，这也是我选择用它的主要原因。我们可以轻松做到命令行参数与属性的映射，属性除了是String类型，还可以是Integer、boolean，甚至是File、集合类型。</li><li>功能丰富<br>它同时支持文章开头的两种命令行风格，并且提供了输出帮助文档的能力(<code>usage()</code>)，还提供了国际化的支持。</li><li>高度扩展</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在一般应用场景，大多只需要设置<code>@Parameter</code>以下几个属性值：</p><ul><li>names 设置命令行参数，如<code>-version</code></li><li>required 设置此参数是否必须</li><li>description 设置参数的描述</li><li>order 设置帮助文档的顺序</li><li>help 设置此参数是否为展示帮助文档或者辅助功能</li></ul><h4 id="两个扩展接口"><a href="#两个扩展接口" class="headerlink" title="两个扩展接口"></a>两个扩展接口</h4><p>可以通过以下两个接口实现正则校验等校验方式的实现</p><ul><li>IStringConverter 支持String类型的参数值可以转化为任意其他类型的属性</li><li>IParameterValidator 支持参数值的校验</li></ul><h3 id="类路径的解析"><a href="#类路径的解析" class="headerlink" title="类路径的解析"></a>类路径的解析</h3><ul><li><p>四种路径分别进行处理</p><ul><li>ZipEntry</li><li>CompositeEntry</li><li>WildcardEntry</li><li>DirEntry</li></ul></li><li><p>Tips：</p><p>-Xbootclasspath/a:<path></p><p>Appends the specified resources to the end of the bootstrap class path</p><p>NIO包</p><ul><li>Files类<ul><li>exists()测试文件是否存在</li><li>newBufferedReader()</li><li>walkFileTree()走一个文件树</li><li>walk()</li></ul></li><li>Paths类<ul><li>get()</li></ul></li><li>FileSystems类</li></ul><p>Stream包</p><ul><li>初始化与转换<ul><li>Stream.of()</li><li>list.stream()</li></ul></li><li>流操作<ul><li>stream().map()</li><li>stream().filter()</li><li>stream().forEach()</li><li>stream().skip().limit()</li><li>stream().distinct()</li><li>stream().anyMatch()</li><li>stream().noneMath()</li></ul></li></ul></li></ul><h3 id="Class文件的读取"><a href="#Class文件的读取" class="headerlink" title="Class文件的读取"></a>Class文件的读取</h3>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
            <tag> 开源工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2020/02/07/redis/"/>
      <url>/2020/02/07/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="Nosql"><a href="#Nosql" class="headerlink" title="Nosql"></a>Nosql</h2><blockquote><p>NoSQL：即Not-Only SQL（泛指非关系型的数据库），作为关系型数据库的补充。</p><p>作用：应对基于海量用户和海量数据前提下的数据处理问题</p></blockquote><p>特征：可扩容，可伸缩;大数据量下高性能;灵活的数据模型;高可用</p><p>常见Nosql 数据库：Redis;memcache;HBase;MongoDB</p><img src="/2020/02/07/redis/%E7%94%B5%E5%95%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" class="" title="电商解决方案"><h2 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h2><blockquote><p>Redis (REmote DIctionaryServer) 是用C 语言开发的一个开源的高性能键值对（key-value）数据库。</p></blockquote><ul><li><p>特征：</p><ol><li><p>数据间没有必然的关联关系</p></li><li><p>内部采用单线程机制进行工作</p></li><li><p>高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。</p></li><li><p>多数据类型支持</p><ul><li>字符串类型string</li><li>列表类型list</li><li>散列类型hash</li><li>集合类型set</li><li>有序集合类型sorted_set</li></ul></li><li><p>持久化支持。可以进行数据灾难恢复</p></li></ol></li><li><p>应用</p><ul><li>为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等任务队列，如秒杀、抢购、购票排队等</li><li>即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设备信号等</li><li>时效性信息控制，如验证码控制、投票控制等</li><li>分布式数据共享，如分布式集群架构中的session 分离</li><li>消息队列</li><li>分布式锁</li></ul></li><li><p>核心文件：</p><ul><li>redis-server.exe 服务器启动命令</li><li>redis-cli.exe命令行客户端</li><li>redis.windows.confredis核心配置文件</li><li>redis-benchmark.exe性能测试工具</li><li>redis-check-aof.exe AOF文件修复工具</li><li>redis-check-dump.exe RDB文件检查工具（快照持久化文件）</li></ul></li><li><p>基本操作</p><ul><li><p>功能性命令</p><ul><li><p>信息添加</p><p>set key value</p></li><li><p>信息查询</p><p>get key</p></li></ul></li><li><p>清除屏幕信息</p><p>clear</p></li><li><p>帮助信息查阅</p><p>help  命令名称</p><p>help  @组名</p></li><li><p>退出指令</p><p>quit/exit/&lt;ESC&gt;</p></li></ul></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><p>string String</p><ul><li><p>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型</p></li><li><p>存储数据的格式：一个存储空间保存一个数据</p></li><li><p>存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用</p></li><li><p>基本操作</p><ul><li>set/get/del</li><li>mset/mget </li><li>strlen</li><li>append 追加信息到原始信息后部（如果原始信息存在就追加，否则新建）</li></ul></li><li><p>扩展操作</p><ol><li><p>设置数值数据增加指定范围的值解决方案</p><p>incr key/ incrby key increment/ incrbyfloat key increment</p></li><li><p>设置数值数据减少指定范围的值</p><p>decr key/ decrby key increment</p></li><li><p>string作为数值操作</p><ul><li>string在redis内部存储默认就是一个字符串，当遇到增减类操作incr，decr时会转成数值型进行计算。</li><li>redis所有的操作都是原子性的，采用单线程处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li><li>按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis数值上限范围，将报错。9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</li><li>Tips ：redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性此方案适用于所有数据库，且支持数据库集群</li></ul></li><li><p>设置数据具有指定的生命周期</p><p>setex key seconds value/psetex key milliseconds value</p><p>Tips ：redis控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</p></li></ol></li><li><p>string 类型数据操作的注意事项</p><ul><li><p>数据操作不成功的反馈与数据正常操作之间的差异</p></li><li><p>①表示运行结果是否成功</p><p>(integer) 0  →  false失败</p><p>(integer) 1  →  true成功</p></li><li><p>②表示运行结果值</p><p>(integer) 3→  3 3个</p><p>(integer) 1→  1 1个</p><p>数据未获取到（nil）等同于null</p></li><li><p>数据最大存储量512MB</p></li><li><p>数值计算最大范围（java中的long的最大值）9223372036854775807</p></li><li><p>Tips: redis应用于各种结构型和非结构型高热度数据访问加速，数据库中的热点数据key命名惯例</p><p>表名: 主键名:主键值:字段名    order​ : id : 29438 : name</p></li></ul></li></ul></li><li><p>hash HashMap</p><ul><li><p>底层使用哈希表结构实现数据存储</p></li><li><p>hash存储结构优化</p><ul><li>如果field数量较少，存储结构优化为类数组结构</li><li>如果field数量较多，存储结构使用HashMap结构</li></ul></li><li><p>基本操作</p><ul><li>添加修改 hset key field value</li><li>获取数据 hget key field / hgetall key</li><li>删除数据 hdel key field1 (field2)</li><li>添加/修改多个数据 hmset key field1 value1 field2 value2 …</li><li>获取多个数据 hmget key field1 field2 …</li><li>获取哈希表中字段的数量 hlen key</li><li>获取哈希表中是否存在指定的字段 hexists key field</li></ul></li><li><p>扩展操作</p><ul><li><p>获取哈希表中所有的字段名或字段值 hkeys key / hvals key</p></li><li><p>设置指定字段的数值数据增加指定范围的值 </p><p>hincrby key field increment / hincrbyfloat key field increment</p></li></ul></li><li><p>hash类型数据操作的注意事项</p><ul><li>hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）</li><li>每个hash 可以存储2的32次方-1 个键值对</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用</li><li>hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈</li></ul></li><li><p>hash类型应用场景</p><ul><li><p>优化以用户为key的设计</p><p>每条购物车中的商品记录保存成两条field</p><ul><li><p>field1专用于保存购买数量</p><p>命名格式：商品id:nums 保存数据：数值</p></li><li><p>field2专用于保存购物车中显示的信息，包含文字描述，图片地址，所属商家信息等</p><p>命名格式：商品id:info 保存数据：json独立</p></li></ul></li><li><p>hsetnx key field value</p><p>Set the value of a hash field, only if the field does not exist</p></li><li><p>string存储对象（json）与hash存储对象</p></li><li><p>应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</p></li></ul></li></ul></li><li><p>list LinkedList</p><ul><li><p>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</p></li><li><p>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</p></li><li><p>list类型：保存多个数据，底层使用双向链表存储结构实现</p></li><li><p>基本操作</p><ul><li><p>添加/修改数据</p><p>lpushkey value1 [value2] ……</p><p>rpushkey value1 [value2] ……</p></li><li><p>获取数据</p><p>获取范围值（-1代表倒数第一个，-2倒数第二个）lrange key start stop </p><p>获取对应索引的值lindex key index</p><p>获取对应list长度 llen key</p></li><li><p>获取并移除数据</p><p>lpop key </p><p>rpop key</p></li></ul></li><li><p>扩展操作</p><ul><li><p>规定时间内获取并移除数据</p><p>blpop key1 [key2] timeout</p><p>brpop key1[key2] timeout </p><p>brpoplpush source destination timeout</p></li><li><p>移除指定数据</p><p>lrem key count value</p></li></ul></li><li><p>注意事项</p><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2的32次方-1个元素(4294967295)。</li><li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作<ul><li>获取全部数据操作结束索引设置为-1</li></ul></li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</li><li>应用于最新消息展示</li></ul></li></ul></li><li><p>set HashSet</p><ul><li><p>新的存储需求：存储大量的数据，在查询方面提供更高的效率</p></li><li><p>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</p></li><li><p>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的</p></li><li><p>基本操作</p><ul><li>添加数据 sadd key member1 [member2]</li><li>删除数据 srem key member1 [member2]</li><li>获取全部数据 smembers key </li><li>获取集合数据总量 scard key</li><li>判断集合中是否包含指定数据 sismember key member</li></ul></li><li><p>扩展操作</p><ul><li><p>随机获取集合中指定数量的数据解决方案 srandmember key [count]</p></li><li><p>随机获取集合中的某个数据并将该数据移出集合 spop key [count]</p></li><li><p>应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，大V推荐等</p></li><li><p>求两个集合的交、并、差集</p><p>sinter key1 [key2] </p><p>sunion key1 [key2] </p><p>sdiff key1 [key2]</p></li><li><p>求两个集合的交、并、差集并存储到指定集合中</p><p>sinter store destination key1 [key2] </p><p>sunion store destination key1 [key2] </p><p>sdiff store destination key1 [key2] </p></li><li><p>将指定数据从原始集合中移动到目标集合中</p><p>smove source destination member  </p></li></ul></li><li><p>应用场景</p><ul><li>redis应用于同类型数据的快速去重</li><li>redis应用于基于黑名单与白名单设定的服务控制</li></ul></li></ul></li><li><p>sorted_set TreeSet</p><ul><li><p>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</p></li><li><p>需要的存储结构：新的存储模型，可以保存可排序的数据</p></li><li><p>sorted_set类型：在set的存储结构基础上添加可排序字段</p></li><li><p>基础操作</p><ul><li><p>添加数据</p><p>zadd key score1 member1 [score2 member2]</p></li><li><p>获取全部数据</p><p>zrange key start stop [WITHSCORES]</p><p>zrevrange key start stop [WITHSCORES]</p></li><li><p>删除数据</p><p>zrem key member [member …]</p></li><li><p>按条件获取数据</p><p>zrangebyscore key min max [WITHSCORES] [LIMIT]</p><p>zrevrangebyscore key max min [WITHSCORES]</p></li><li><p>条件删除数据</p><p>zremrangebyrank key start stop</p><p>zremrangebyscore key min max</p></li><li><p>注意：</p><p>min与max用于限定搜索查询的条件</p><p>start与stop用于限定查询范围，作用于索引，表示开始和结束索引</p><p>offset与count用于限定查询范围，作用于查询结果，表示开始位置和数据总量</p></li><li><p>获取集合数据总量</p><p>zcard key</p><p>zcount key min max</p></li><li><p>集合交、并操作</p><p>zinterstore destination numkeys key [key …]</p><p>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</p><p>zunionstore destination numkeys key [key …]</p><p>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight] [AGGREGATE SUM|MIN|MAX]</p></li></ul></li><li><p>扩展操作</p><ul><li><p>获取数据对应的索引（排名）</p><p>zrank key member</p><p>zrevrank key member</p></li><li><p>score值获取与修改</p><p>zscorekey member</p><p>zincrbykey increment member</p></li><li><p>Tips：应用于计数器组合排序功能对应的排名</p></li></ul></li><li><p>注意事项</p><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时候要慎重</li><li>sorted_set底层存储还是基于set结构的，因此数据不能重复，如果重复添加相同的数据，score值将被反复覆盖，保留最后一次修改的结果</li></ul></li><li><p>应用场景</p><ul><li>应用于定时任务执行顺序管理或任务过期管理<ol><li>对于基于时间线限定的任务处理，将处理时间记录为score值，利用排序功能区分处理的先后顺序</li><li>记录下一个要处理的时间，当到期后处理对应任务，移除redis中的记录，并记录下一个要处理的时间</li><li>当新任务加入时，判定并更新当前下一个要处理的任务时间</li><li>为提升sorted_set的性能，通常将任务根据特征存储成若干个sorted_set。例如1小时内，1天内，周内，月内，季内，年度等，操作时逐级提升，将即将操作的若干个任务纳入到1小时内处理的队列中</li><li>获取当前系统时间time</li></ol></li><li>应用于即时任务/消息队列执行管理<ol><li>对于带有权重的任务，优先处理权重高的任务，采用score记录权重即可多条件任务权重设定<ul><li>如果权重条件过多时，需要对排序score值进行处理，保障score值能够兼容2条件或者多条件，例如外贸订单优先于国内订单，总裁订单优先于员工订单，经理订单优先于员工订单</li></ul></li><li>因score长度受限，需要对数据进行截断处理，尤其是时间设置为小时或分钟级即可（折算后）</li><li>先设定订单类别，后设定订单发起角色类别，整体score长度必须是统一的，不足位补0。第一排序规则首位不得是0<ul><li>例如外贸101，国内102，经理004，员工008。</li><li>员工下的外贸单score值为101008（优先）</li><li>经理下的国内单score值为102004</li></ul></li></ol></li></ul></li></ul></li><li><p>案例</p><ul><li><p>redis应用于限时按次结算的服务控制</p><p>人工智能领域的语义识别与自动对话将是未来服务业机器人应答呼叫体系中的重要技术，百度自研用户评价语义识别服务，免费开放给企业试用，同时训练百度自己的模型。现对试用用户的使用行为进行限速，限制每个用户每分钟最多发起10次调用1…10</p></li><li><p>解决方案</p><ul><li>设计计数器，记录调用次数，用于控制业务执行次数。以用户id作为key，使用次数作为value</li><li>在调用前获取次数，判断是否超过限定次数不超过次数的情况下，每次调用计数+1业务调用失败，计数-1</li><li>为计数器设置生命周期为指定周期，例如1秒/分钟，自动清空周期内使用次数</li></ul></li><li><p>解决方案优化</p><ul><li>取消最大值的判定，利用incr操作超过Long.Max最大值抛出异常的形式替代每次判断是否大于最大值</li><li>判断是否为nil，如果是，设置为Max-次数如果不是，计数+1业务调用失败，计数-1</li><li>遇到异常即+操作超过上限，视为使用达到上限</li></ul></li><li><p>redis应用于基于时间顺序的数据操作，而不关注具体时间</p><p>使用微信的过程中，当微信接收消息后，会默认将最近接收的消息置顶，当多个好友及关注的订阅号同时发送消息时，该排序会不停的进行交替。同时还可以将重要的会话设置为置顶。一旦用户离线后，再次打开微信时，消息该按照什么样的顺序显示</p></li><li><p>解决方案</p><ul><li>依赖list的数据具有顺序的特征对消息进行管理，将list结构作为栈使用</li><li>对置顶与普通会话分别创建独立的list分别管理</li><li>当某个list中接收到用户消息后，将消息发送方的id从list的一侧加入list（此处设定左侧）</li><li>多个相同id发出的消息反复入栈会出现问题，在入栈之前无论是否具有当前id对应的消息，先删除对应id</li><li>推送消息时先推送置顶会话list，再推送普通会话list，推送完成的list清除所有数据</li><li>消息的数量，也就是微信用户对话数量采用计数器的思想另行记录，伴随list操作同步更新</li></ul></li></ul></li></ul><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul><li><p>key通用操作</p><ul><li><p>特征</p><p>key是一个字符串，通过key获取redis中保存的数据</p></li><li><p>基本操作</p><ul><li>获取key是否存在 exists key</li><li>获取key的类型 type key</li><li>删除指定key del key</li></ul></li><li><p>扩展操作</p><ul><li><p>为指定key设置有效期</p><p>expire key seconds</p><p>pexpire key milliseconds</p><p>expireat key timestamp </p><p>pexpireat key milliseconds-timestamp</p></li><li><p>获取key的有效时间</p><p>ttl key 返回-2表示key不存在，返回-1表示key存在，若有有效时间返回有效时间</p><p>pttl key</p></li><li><p>切换key从时效性转换为永久性 persist key</p></li><li><p>查询key pattern key</p><p>*匹配任意数量的任意符号</p><p>? 配合一个任意符号</p><p>[]匹配一个指定符号</p></li></ul></li><li><p>其他操作</p><ul><li><p>改名</p><p>rename key newkey</p><p>renamex key newkey（若newkey不存在才改名</p></li><li><p>排序 sort</p></li><li><p>其他key通用操作 help @generic</p></li></ul></li></ul></li><li><p>数据库通用操作</p><ul><li><p>解决key 的重复问题</p><ul><li>redis为每个服务提供有16个数据库，编号从0到15</li><li>每个数据库之间的数据相互独立</li></ul></li><li><p>DB基本操作</p><ul><li><p>切换数据库 select index</p></li><li><p>其他操作</p><p>quit    ping测试连通    echo输出控制台</p></li></ul></li><li><p>DB相关操作</p><ul><li>数据移动 move key db</li><li>数据清除 dbsize flushdb flushall</li></ul></li></ul></li></ul><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><ul><li><p>基于连接池获取连接</p><ul><li>JedisPool：Jedis提供的连接池技术</li><li>poolConfig:连接池配置对象</li><li>host:redis服务地址</li><li>port:redis服务端口号</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">JedisPool</span><span class="token punctuation">(</span>GenericObjectPoolConfig poolConfig<span class="token punctuation">,</span> String host<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>poolConfig<span class="token punctuation">,</span> host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>null<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p>jedis.properties</p><ul><li>jedis.host=localhost</li><li>jedis.port=6379</li><li>jedis.maxTotal=30</li><li>jedis.maxIdle=10</li></ul></li><li><p>静态代码块初始化资源</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//读取配置文件获得参数值</span>    ResourceBundle rb <span class="token operator">=</span> ResourceBundle<span class="token punctuation">.</span><span class="token function">getBundle</span><span class="token punctuation">(</span><span class="token string">"jedis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    host <span class="token operator">=</span> rb<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"jedis.host"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    port <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>rb<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"jedis.port"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxTotal <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>rb<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"jedis.maxTotal"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    maxIdle <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>rb<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"jedis.maxIdle"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    poolConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>poolConfig<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span>maxTotal<span class="token punctuation">)</span><span class="token punctuation">;</span>    poolConfig<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span>maxIdle<span class="token punctuation">)</span><span class="token punctuation">;</span>    jedisPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>poolConfig<span class="token punctuation">,</span>host<span class="token punctuation">,</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>对外访问接口，提供jedis连接对象，连接从连接池获取</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Jedis <span class="token function">getJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Jedis jedis <span class="token operator">=</span> jedisPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> jedis<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li></ul><h2 id="Redis高级"><a href="#Redis高级" class="headerlink" title="Redis高级"></a>Redis高级</h2><h3 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h3><ul><li><p>基于Center OS7安装Redis</p><ul><li>下载安装包wget<a href="http://download.redis.io/releases/redis-?.?.?.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-?.?.?.tar.gz</a></li><li>解压tar –xvf文件名.tar.gz</li><li>编译make</li><li>安装make install [destdir=/目录]</li></ul></li><li><p>Redis基础环境设置</p><ul><li><p>创建软链接ln -s 原始目录名快速访问目录名</p></li><li><p>创建配置文件管理目录</p><p>mkdir conf / mkdir config</p></li><li><p>创建数据文件管理目录mkdirdata</p></li></ul></li><li><p>Redis服务启动</p><ul><li><p>默认配置启动</p><p>redis-serverredis-server  –-port 6379</p><p>redis-server  –-port 6380 ……</p></li><li><p>指定配置文件启动</p><p>redis-server  redis.conf</p><p>redis-server  redis-6379.conf</p><p>redis-server  redis-6380.conf ……</p><p>redis-server  conf/redis-6379.conf</p><p>redis-server  config/redis-6380.conf ……</p></li><li><p>Redis客户端连接</p><ul><li><p>默认连接</p><p>redis-cli</p></li><li><p>连接指定服务器</p><p>redis-cli  -h  127.0.0.1</p><p>redis-cli  –port  6379</p><p>redis-cli  -h  127.0.0.1  –port   6379</p></li></ul></li><li><p>Redis服务端配置</p></li><li><p>基本配置</p><ul><li><p>daemonize yes</p><p>以守护进程方式启动，使用本启动方式，redis将以服务的形式存在，日志将不再打印到命令窗口中</p></li><li><p>port  6***</p><p>设定当前服务启动端口号</p></li><li><p>dir“/自定义目录/redis/data“</p><p>设定当前服务文件保存位置，包含日志文件、持久化文件（后面详细讲解）等</p></li><li><p>logfile”6***.log“</p><p>设定日志文件名，便于查阅</p></li></ul></li></ul></li></ul><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul><li><p>简介</p><ul><li><p>概念</p><p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化</p></li><li><p>意义</p><p>防止数据的意外丢失，确保数据安全性</p></li><li><p>两种方式</p><ul><li>RDB将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据</li><li>AOF将数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在数据的操作过程</li></ul></li></ul></li><li><p>RDB</p><ul><li><p>启动方式save</p><p>手动执行一次保存</p></li><li><p>save指令相关配置</p><ul><li><p>dbfilename dump.rdb</p><p>说明：设置本地数据库文件名，默认值为dump.rdb</p><p>经验：通常设置为dump-端口号.rdb</p></li><li><p>dir</p><p>说明：设置存储.rdb文件的路径</p><p>经验：通常设置成存储空间较大的目录中，目录名称data</p></li><li><p>rdbcompression yes</p><p>说明：设置存储至本地数据库时是否压缩数据，默认为yes，采用LZF 压缩</p><p>经验：通常默认为开启状态，如果设置为no，可以节省CPU 运行时间，但会使存储的文件变大（巨大）</p></li><li><p>rdbchecksum yes</p><p>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行</p><p>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</p></li></ul></li><li><p>启动方式bgsave</p><p>手动启动后台保存操作，但不是立即执行</p></li><li><p>工作原理</p><img src="/2020/02/07/redis/bgsave%E6%8C%87%E4%BB%A4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" class="" title="bgsave指令工作原理"></li><li><p>bgsave相关配置</p><ul><li><p>dbfilename dump.rdb</p></li><li><p>dir</p></li><li><p>rdbcompression yes</p></li><li><p>rdbchecksum yes</p></li><li><p>stop-writes-on-bgsave-error yes</p><p>说明：后台存储过程中如果出现错误现象，是否停止保存操作</p><p>经验：通常默认为开启状态</p></li></ul></li><li><p>save配置</p><ul><li><p>配置</p><p>save second changes </p></li><li><p>作用</p><p>满足限定时间范围内key的变化数量达到指定数量即进行持久化</p></li><li><p>参数</p><p>second：监控时间范围</p><p>changes：监控key的变化量</p><p>位置在conf文件中进行配置</p></li><li><p>范例</p><p>save 900 1 </p><p>save 300 10</p><p>save 60 10000</p></li><li><p>原理</p><img src="/2020/02/07/redis/save%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86.png" class="" title="save配置原理"></li><li><p>注意</p><p>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</p><p>save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系</p><p>save配置启动后执行的是bgsave操作</p></li></ul></li><li><p>rdb特殊启动形式</p><ul><li><p>全量复制</p></li><li><p>服务器运行过程中重启</p><p>debug reload</p></li><li><p>关闭服务器时指定保存数据</p><p>shutdown save</p></li></ul></li><li><p>优劣</p><ul><li><p>优势</p><p>RDB是一个紧凑压缩的二进制文件，存储效率较高</p><p>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</p><p>RDB恢复数据的速度要比AOF快很多</p><p>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复。</p></li><li><p>劣势</p><p>RDB方式无论是执行指令还是利用配置，无法做到实时持久化，具有较大的可能性丢失数据</p><p>bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能</p><p>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</p></li></ul></li></ul></li><li><p>AOF</p><ul><li><p>简介</p><ul><li>AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中命令达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</li><li>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式</li></ul></li><li><p>写数据的策略</p><ul><li>always(每次）每次写入操作均同步到AOF文件中，数据零误差，性能较低，不建议使用。</li><li>everysec（每秒）每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高，建议使用，也是默认配置在系统突然宕机的情况下丢失1秒内的数据</li><li>no（系统控制）由操作系统控制每次同步到AOF文件的周期，整体过程不可控</li></ul></li><li><p>AOF功能开启</p><ul><li><p>配置 appendonly yes|no</p><p>作用 是否开启AOF持久化功能，默认为不开启状态</p></li><li><p>配置 appendfsync always|everysec|no </p><p>作用 AOF 写数据策略</p></li><li><p>配置 appendfilename filename</p><p>作用  AOF持久化文件名，默认文件名未appendonly.aof，建议配置为 appendonly-端口号.aof</p></li><li><p>配置 dir</p><p>作用 AOF持久化文件保存路径，与RDB持久化文件保持一致即可</p></li></ul></li><li><p>AOF重写</p><p>随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录。</p><ul><li><p>作用</p><p>降低磁盘占用量，提高磁盘利用率</p><p>提高持久化效率，降低持久化写时间，提高IO性能</p><p>降低数据恢复用时，提高数据恢复效率</p></li><li><p>AOF重写规则</p><ol><li>进程内已超时的数据不再写入文件</li><li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令如del key1、hdelkey2、sremkey3、set key4 111、set key4 222等</li><li>对同一数据的多条写命令合并为一条命令如lpushlist1 a、lpushlist1 b、lpushlist1 c 可以转化为：lpushlist1 a b c。为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li></ol></li><li><p>AOF重写方式</p><ul><li><p>手动重写 </p><p>bgrewriteaof </p></li><li><p>自动重写 </p><p>auto-aof-rewrite-min-size size </p><p>auto-aof-rewrite-percentage percentage</p></li></ul></li><li><p>自动重写方式</p><ul><li><p>自动重写触发条件设置</p><p>auto-aof-rewrite-min-size size</p><p>auto-aof-rewrite-percentage percent</p></li><li><p>自动重写触发比对参数（运行指令info Persistence获取具体信息）</p><p>aof_current_size</p><p>aof_base_size</p></li><li><p>自动重写触发条件</p><p>aof_current_size&gt;=auto-aof-rewrite-min-size</p><p>(aof_current_size-aof_base_size/aof_base_size)&gt;=auto-aof-rewrite-percentage</p></li></ul></li><li><p>AOF重写流程</p><img src="/2020/02/07/redis/AOF%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B.png" class="" title="AOF重写流程"></li></ul></li></ul></li><li><p>RBD对比AOF</p><img src="/2020/02/07/redis/RBD%E5%AF%B9%E6%AF%94AOF.png" class="" title="RBD对比AOF"><ul><li>对数据非常敏感，建议使用默认的AOF持久化方案<ul><li>AOF持久化策略使用everysecond，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li><li>注意：由于AOF文件存储体积较大，且恢复速度较慢</li></ul></li><li>数据呈现阶段有效性，建议使用RDB持久化方案<ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且恢复速度较快，阶段点数据恢复通常采用RDB方案</li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低，慎重</li></ul></li><li>综合比对<ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF</li><li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB</li><li>灾难恢复选用RDB</li><li>双保险策略，同时开启RDB 和AOF，重启后，Redis优先使用AOF 来恢复数据，降低丢失数据的量</li></ul></li></ul></li><li><p>应用场景</p><p>以下可考虑使用</p><ul><li>应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</li><li>应用于具有操作先后顺序的数据控制</li><li>应用于最新消息展示</li><li>应用于基于黑名单与白名单设定的服务控制</li><li>应用于计数器组合排序功能对应的排名</li></ul></li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li><p>简介</p><p>redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰</p><p>一个队列中，一次性、顺序性、排他性的执行一系列命令</p></li><li><p>事务的基本操作</p><ul><li>开启事务 mutli<ul><li>作用 设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li></ul></li><li>执行事务 exec<ul><li>作用 设定事务的结束位置，同时执行事务。与multi成对出现，成对使用</li></ul></li><li>注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</li><li>取消事务 discard<ul><li>作用 终止当前事务的定义，发生在multi之后，exec之前</li></ul></li></ul></li><li><p>事务的工作流程</p></li></ul><img src="/2020/02/07/redis/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="" title="事务的工作流程"><ul><li><p>事务的注意事项</p><ul><li><p>定义事务的过程中，命令格式输入错误</p><ul><li><p>处理结果</p><p>如果定义的事务中所包含的命令存在语法错误，整体事务中所有命令均不会执行。包括那些语法正确的命令。</p></li></ul></li><li><p>定义事务的过程中，命令执行出现错误怎么办？</p><p>运行错误指命令格式正确，但是无法正确的执行。例如对list进行incr操作</p><ul><li><p>处理结果</p><p>能够正确运行的命令会执行，运行错误的命令不会被执行</p></li></ul></li><li><p>注意：已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚。</p></li><li><p>手动进行事务回滚</p><ul><li>记录操作过程中被影响的数据之前的状态<ol><li>单数据：string</li><li>多数据：hash、list、set、zset</li></ol></li><li>设置指令恢复所有的被修改的项<ol><li>单数据：直接set（注意周边属性，例如时效）</li><li>多数据：修改对应值或整体克隆复制</li></ol></li></ul></li></ul></li><li><p>锁</p><ul><li><p>对key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><p>watch key1 [key2……]</p></li><li><p>取消对所有key 的监视</p><p>unwatch</p></li><li><p>应用基于状态控制的批量任务执行</p></li></ul></li><li><p>应用基于分布式锁对应的场景控制</p><ul><li><p>业务场景</p><p>天猫双11热卖过程中，对已经售罄的货物追加补货，且补货完成。客户购买热情高涨，3秒内将所有商品购买完毕。本次补货已经将库存全部清空，如何避免最后一件商品不被多人同时购买？【超卖问题】</p></li><li><p>分析</p><p>使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据</p><p>虽然redis是单线程的，但是多个客户端对同一数据同时进行操作时，如何避免不被同时修改</p></li><li><p>方案</p><ul><li><p>使用setnx设置一个公共锁利用 setnx lock-key value</p><p>setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功</p></li><li><p>对于返回设置成功的，拥有控制权，进行下一步的具体业务操作</p></li><li><p>对于返回设置失败的，不具有控制权，排队或等待操作完毕通过del操作释放锁</p></li><li><p>注意：上述解决方案是一种设计概念，依赖规范保障，具有风险性</p></li></ul></li><li><p>改良</p><ul><li><p>使用expire为锁key添加时间限定，到时不释放，放弃锁</p><p>expire lock-key second </p><p>pexpire lock-key milliseconds</p></li><li><p>由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大。具体时间需要业务测试后确认。</p><p>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。</p><p>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时</p><p>锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110%</p><p>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</p></li></ul></li></ul></li></ul><h3 id="Redis删除策略"><a href="#Redis删除策略" class="headerlink" title="Redis删除策略"></a>Redis删除策略</h3><ul><li><p>过期数据</p><ul><li>Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态<ul><li>XX：具有时效性的数据</li><li>-1：永久有效的数据</li><li>-2：已经过期的数据或被删除的数据或未定义的数据Redis中的数据特征</li></ul></li></ul></li><li><p>数据删除策略</p><ol><li><p>定时删除</p><ul><li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</li><li>优点：节约内存，到时就删除，快速释放掉不必要的内存占用</li><li>缺点：CPU压力很大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li><li>总结：用处理器性能换取存储空间（拿时间换空间）</li></ul></li><li><p>惰性删除</p><ul><li>数据到达过期时间，不做处理。等下次访问该数据时如果未过期，返回数据，发现已过期，删除，返回不存在</li><li>优点：节约CPU性能，发现必须删除的时候才删除</li><li>缺点：内存压力很大，出现长期占用内存的数据</li><li>总结：用存储空间换取处理器性能 expireIfNeeded()（拿时间换空间）</li></ul></li><li><p>定期删除</p><p>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</p><ul><li><p>Redis启动服务器初始化时，读取配置server.hz的值，默认为10</p></li><li><p>每秒钟执行server.hz次serverCron()-&gt;databasesCron()-&gt;activeExpireCycle()</p></li><li><p>activeExpireCycle()对每个expires[<em>]逐一进行检测，每次执行250ms/server.hz</em></p></li><li><p>对某个expires[*]检测时，随机挑选W个key检测</p><ol><li>如果key超时，删除key</li><li>如果一轮中删除的key的数量&gt;W<em>25%，循环该过程</em></li><li>如果一轮中删除的key的数量≤W*25%，检查下一个expires[*]，0-15循环</li><li>W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP属性值</li></ol></li><li><p>参数current_db用于记录activeExpireCycle()进入哪个expires[*]执行</p></li><li><p>如果activeExpireCycle()执行时间到期，下次从current_db继续向下执行</p></li><li><p>特点：</p><p>CPU性能占用设置有峰值，检测频度可自定义设置</p><p>内存压力不是很大，长期占用内存的冷数据会被持续清理</p></li></ul></li><li><p>对比</p><ul><li><p>定时删除</p><p>节约内存，无占用 不分时段占用CPU资源，频度高 拿时间换空间</p></li><li><p>惰性删除</p><p>内存占用严重 延时执行，CPU利用率高 拿空间换时间</p></li><li><p>定期删除</p><p>内存定期随机清理 每秒花费固定的CPU资源维护内存 随机抽查，重点抽查</p></li></ul></li></ol></li><li><p>逐出算法</p><ul><li><p>新数据进入检测</p><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法。</li><li>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息</li></ul></li><li><p>影响数据逐出的相关配置</p><ul><li><p>最大可使用内存 maxmemory</p><p>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</p></li><li><p>每次选取待删除数据的个数 maxmemory-samples</p><p>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</p></li><li><p>删除策略 maxmemory-policy</p><p>达到最大内存后的，对被挑选出来的数据进行删除的策略</p></li></ul></li><li><p>影响数据逐出的相关配置</p><ul><li><p>检测易失数据（可能会过期的数据集server.db[i].expires ）</p><p>①volatile-lru：挑选最近最少使用的数据淘汰</p><p>②volatile-lfu：挑选最近使用次数最少的数据淘汰</p><p>③volatile-ttl：挑选将要过期的数据淘汰</p><p>④volatile-random：任意选择数据淘汰</p></li><li><p>检测全库数据（所有数据集server.db[i].dict）</p><p>⑤allkeys-lru：挑选最近最少使用的数据淘汰</p><p>⑥allkeys-lfu：挑选最近使用次数最少的数据淘汰</p><p>⑦allkeys-random：任意选择数据淘汰</p></li><li><p>放弃数据驱逐</p><p>⑧no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</p></li></ul></li><li><p>数据逐出策略配置依据</p><p>使用INFO命令输出监控信息，查询缓存hit 和miss 的次数，根据业务需求调优Redis配置</p></li></ul></li></ul><h3 id="Redis核心配置"><a href="#Redis核心配置" class="headerlink" title="Redis核心配置"></a>Redis核心配置</h3><ul><li><p>服务器基础配置</p><ul><li><p>服务器端设定</p><ul><li><p>设置服务器以守护进程的方式运行</p><p>daemonize yes|no</p></li><li><p>绑定主机地址</p><p>bind 127.0.0.1</p></li><li><p>设置服务器端口号</p><p>port 6379</p></li><li><p>设置数据库数量</p><p>databases 16</p></li></ul></li><li><p>日志配置</p><ul><li><p>设置服务器以指定日志记录级别</p><p>loglevel debug|verbose|notice|warning</p></li><li><p>日志记录文件名</p><p>logfile 端口号.log</p></li><li><p>注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频度</p></li></ul></li><li><p>客户端配置</p><ul><li><p>设置同一时间最大客户端连接数，默认无限制。当客户端连接到达上限，Redis会关闭新的连接</p><p>maxclients 0（设置为0表示不作限制</p></li><li><p>客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为0</p><p>timeout 300</p></li></ul></li><li><p>多服务器快捷配置</p><ul><li>导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件，便于维护include/path/server-端口号.conf</li></ul></li></ul></li></ul><h3 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h3><ul><li><p>Bitmaps</p><ul><li><p>基础操作</p><ul><li><p>获取指定key对应偏移量上的bit值</p><p>getbitkey offset</p></li><li><p>设置指定key对应偏移量上的bit值，value只能是1或0</p><p>setbit key offset value</p></li></ul></li><li><p>扩展操作</p><ul><li><p>业务场景</p><ol><li>统计每天某一部电影是否被点播</li><li>统计每天有多少部电影被点播</li><li>统计每周/月/年有多少部电影被点播</li><li>统计年度哪部电影没有被点播</li></ol></li><li><p>对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中</p><p>bitop op destKey key1 [key2…]</p><p>and 交 or 并 not 非 xo 异或</p></li><li><p>统计指定key中1的数量</p><p>bitcount key [start end]</p></li></ul></li><li><p>Tips ：redis应用于信息状态统计</p></li></ul></li><li><p>Hyperloglog</p><ul><li><p>统计独立UV</p><ul><li>原始方案：set 存储每个用户的id（字符串）</li><li>改进方案：Bitmaps 存储每个用户状态（bit）</li><li>全新的方案：Hyperloglog</li></ul></li><li><p>基数</p><ul><li>基数是数据集去重后元素个数</li><li>HyperLogLog是用来做基数统计的，运用了LogLog的算法</li></ul></li><li><p>基本操作</p><ul><li><p>添加数据</p><p>pfadd key element [element …]</p></li><li><p>统计数据</p><p>pfcount key [key …]</p></li><li><p>合并数据</p><p>pfmerge destkey sourcekey [sourcekey…]</p></li></ul></li><li><p>相关说明</p><ul><li>用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据</li><li>核心是基数估算算法，最终数值存在一定误差</li><li>误差范围：基数估计的结果是一个带有0.81% 标准错误的近似值</li><li>耗空间极小，每个hyperloglogkey占用了12K的内存用于标记基数</li><li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存逐渐增大</li><li>Pfmerge命令合并后占用的存储空间为12K，无论合并之前数据量多少</li></ul></li><li><p>redis应用于独立信息统计</p></li></ul></li><li><p>GEO</p><ul><li><p>redis应用于地理位置计算</p></li><li><p>基本操作</p><ul><li><p>添加坐标点</p><p>geoaddkey longitude latitude member [longitude latitude member …]</p></li><li><p>获取坐标点</p><p>geoposkey member [member …]</p></li><li><p>计算坐标点距离</p><p>geodistkey member1 member2 [unit]</p></li><li><p>添加坐标点</p><p>georadiuskey longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</p></li><li><p>获取坐标点</p><p>georadiusbymemberkey member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</p></li><li><p>计算经纬度</p><p>geohashkey member [member …]</p></li></ul></li></ul></li></ul><h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ul><li><p>简介</p><ul><li><p>多台服务器连接</p><ul><li>提供数据方：master主服务器，主节点，主库主客户端</li><li>接收数据方：slave从服务器，从节点，从库从客户端</li><li>需要解决的问题：数据同步</li><li>核心工作：master的数据复制到slave中</li></ul></li><li><p>概念</p><ul><li>主从复制即将master中的数据即时、有效的复制到slave中</li></ul></li><li><p>特征：一个master可以拥有多个slave，一个slave只对应一个master</p></li><li><p>职责：</p><ul><li><p>master：</p><p>写数据；执行写操作时，将出现变化的数据自动同步到slave；读数据（可忽略）；</p></li><li><p>slave:</p><p>读数据;写数据（禁止）</p></li></ul></li><li><p>作用</p><ul><li>读写分离：master写、slave读，提高服务器的读写负载能力</li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li></ul></li></ul></li><li><p>工作流程</p><ol><li><p>建立连接阶段</p><ol><li>建立slave到master的连接，使master能够识别slave，并保存slave端口号<ul><li>设置master的地址和端口，保存master信息</li><li>建立socket连接</li><li>发送ping命令（定时器任务）</li><li>身份验证</li><li>发送slave端口信息至此，主从连接成功！</li></ul></li></ol><img src="/2020/02/07/redis/%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="" title="建立连接阶段工作流程"><ol start="2"><li><p>状态：</p><ul><li>slave：保存master的地址与端口</li><li>master：保存slave的端口</li><li>总体：之间创建了连接的socket</li></ul></li><li><p>主从连接</p><ul><li><p>方式一：客户端发送命令</p><p>slaveof <masterip> <masterport></p></li><li><p>方式二：启动服务器参数</p><p>redis-server -slaveof <masterip> <masterport></p></li><li><p>方式三：服务器配置</p><p>slaveof <masterip> <masterport></p></li><li><p>slave系统信息</p><p>master_link_down_since_seconds</p><p>masterhost</p><p>masterport</p></li><li><p>master系统信息</p><p>slave_listening_port(多个)</p></li></ul></li><li><p>主从断开连接</p><ul><li>客户端发送命令slaveof no one</li><li>说明：slave断开连接后，不会删除已有数据，只是不再接受master发送的数据</li></ul></li><li><p>授权访问</p><ul><li><p>master客户端发送命令设置密码</p><p>requirepass <password></p></li><li><p>master配置文件设置密码</p><p>config set requirepass <password></p><p>config get requirepass </p></li><li><p>slave客户端发送命令设置密码</p><p>redis-server–a <password></p></li><li><p>slave配置文件设置密码</p><p>masterauth <password></p></li><li><p>slave启动服务器设置密码</p><p>auth <password></p></li></ul></li></ol></li><li><p>数据同步阶段工作流程</p><p>在slave初次连接master后，复制master中的所有数据到slave；将slave的数据库状态更新成master当前的数据库状态</p><img src="/2020/02/07/redis/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%98%B6%E6%AE%B5%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="" title="数据同步阶段工作流程"><ul><li>请求同步数据</li><li>创建RDB同步数据</li><li>恢复RDB同步数据</li><li>请求部分同步数据</li><li>恢复部分同步数据</li></ul><p>状态：</p><ul><li>slave：具有master端全部数据，包含RDB过程接收的数据</li><li>master：保存slave当前数据同步的位置</li><li>总体：之间完成了数据克隆</li></ul><p>说明</p><ul><li><p>master</p><ol><li><p>如果master数据量巨大，数据同步阶段应避开流量高峰期，避免造成master阻塞，影响业务正常执行</p></li><li><p>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入死循环状态。</p><p>默认 repl-backlog-size 1mb</p></li><li><p>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区</p></li></ol></li><li><p>slave</p><ol><li><p>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，建议关闭此期间的对外服务</p><p>slave-serve-stale-data yes|no</p></li><li><p>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</p></li><li><p>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</p></li><li><p>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，数据一致性变差，应谨慎选择</p></li></ol></li></ul></li><li><p>命令传播阶段</p><p>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作称为命令传播</p><p>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</p><img src="/2020/02/07/redis/%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%E9%98%B6%E6%AE%B5%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="" title="命令传播阶段工作流程"><p>命令传播阶段出现了断网现象</p><ul><li>网络闪断闪连 忽略</li><li>短时间网络中断 部分复制</li><li>长时间网络中断 全量复制</li></ul><p>部分复制的三个核心要素</p><ul><li><p>服务器的运行id（run id）</p><p>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</p><p>组成：运行id由40位字符组成，是一个随机的十六进制字符例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</p><p>作用：运行id被用于在服务器间进行传输，识别身份如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</p><p>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过info Server命令，可以查看节点的runid</p></li><li><p>主服务器的复制积压缓冲区</p><p>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO）的队列，用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</p><ul><li>复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列</li></ul><p>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区</p><p>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</p><p>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</p><p>原理：通过offset区分不同的slave当前数据传播的差异；master记录已发送的信息对应的offset；slave记录已接收的信息对应的offset</p></li><li><p>主从服务器的复制偏移量</p><p>概念：一个数字，描述复制缓冲区中的指令字节位置</p><p>分类：</p><ul><li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li><li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li></ul><p>数据来源：</p><ul><li>master端：发送一次记录一次</li><li>slave端：接收一次记录一次</li></ul><p>作用：同步信息，比对master与slave的差异，当slave断线后，恢复数据使用</p></li></ul></li><li><p>心跳机制</p><ul><li><p>进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</p><p>master心跳：</p><ul><li>指令：PING</li><li>周期：由repl-ping-slave-period决定，默认10秒</li><li>作用：判断slave是否在线</li><li>查询：INFO replication获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li></ul><p>slave心跳任务</p><ul><li>指令：REPLCONF ACK {offset}</li><li>周期：1秒</li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li><li>作用2：判断master是否在线</li></ul></li><li><p>注意事项</p><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作</p><ul><li><p>min-slaves-to-write 2    </p></li><li><p>min-slaves-max-lag 8</p><p>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</p></li></ul><p>slave数量及延迟由slave发送REPLCONF ACK命令做确认</p></li></ul></li></ol></li><li><p>常见问题</p><ul><li><p>伴随着系统的运行，master的数据量会越来越大，一旦master重启，runid将发生变化，会导致全部slave的全量复制操作内部优化调整方案：</p><ol><li>master内部创建master_replid变量，使用runid相同的策略生成，长度41位，并发送给所有slave</li><li>在master关闭时执行命令shutdown save，进行RDB持久化,将runid与offset保存到RDB文件中<ul><li>repl-id repl-offset</li><li>通过redis-check-rdb命令可以查看该信息</li></ul></li><li>master重启后加载RDB文件，恢复数据重启后，将RDB文件中保存的repl-id与repl-offset加载到内存中<ul><li>master_repl_id= repl master_repl_offset= repl-offset</li><li>通过info命令可以查看该信息作用：本机保存上次runid，重启后恢复该值，使所有slave认为还是之前的master</li></ul></li></ol></li><li><p>网络环境不佳，出现网络中断，slave不提供服务</p><ul><li><p>问题原因</p><p>复制缓冲区过小，断网后slave的offset越界，触发全量复制</p></li><li><p>最终结果</p><p>slave反复进行全量复制</p></li><li><p>解决方案</p><p>修改复制缓冲区大小</p></li><li><p>建议设置如下：</p><ol><li>测算从master到slave的重连平均时长second</li><li>获取master平均每秒产生写命令数据总量write_size_per_second</li><li>最优复制缓冲区空间= 2 * second * write_size_per_secondrepl-backlog-size</li></ol></li></ul></li><li><p>master的CPU占用过高或slave频繁断开连接</p><ul><li><p>问题原因</p><ul><li>slave每1秒发送REPLCONF ACK命令到master</li><li>当slave接到了慢查询时（keys * ，hgetall等），会大量占用CPU性能</li><li>master每1秒调用复制定时函数replicationCron()，比对slave发现长时间没有进行响应</li></ul></li><li><p>最终结果</p><p>master各种资源（输出缓冲区、带宽、连接等）被严重占用</p></li><li><p>解决方案</p><p>通过设置合理的超时时间，确认是否释放</p><p>slave slaverepl-timeout 该参数定义了超时时间的阈值（默认60秒），超过该值，释放 </p></li></ul></li><li><p>slave与master连接断开</p><ul><li><p>问题原因</p><ul><li>master发送ping指令频度较低</li><li>master设定超时时间较短</li><li>ping指令在网络中存在丢包</li></ul></li><li><p>解决方案</p><p>提高ping指令发送的频度</p><p>repl-ping-slave-period超时时间repl-time的时间至少是ping指令频度的5到10倍，否则slave很容易判定超时</p></li></ul></li><li><p>多个slave获取相同数据不同步</p><ul><li><p>问题原因</p><p>网络信息不同步，数据发送有延迟</p></li><li><p>解决方案</p><ul><li>优化主从间的网络环境，通常放置在同一个机房部署，如使用阿里云等云服务器时要注意此现象</li><li>监控主从节点延迟（通过offset）判断，如果slave延迟过大，暂时屏蔽程序对该slave的数据访问slave-serve-stale-datayes|no 开启后仅响应info、slaveof等少数命令（慎用，除非对数据一致性要求很高）</li></ul></li></ul></li></ul></li></ul><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><ul><li><p>简介</p><ul><li><p>概念</p><p>哨兵(sentinel) 是一个分布式系统，用于对主从结构中的每台服务器进行监控，当出现故障时通过投票机制选择新的master并将所有slave连接到新的master</p></li><li><p>作用</p><ul><li><p>监控</p><p>不断的检查master和slave是否正常运行。master存活检测、master与slave运行情况检测</p></li><li><p>通知（提醒）</p><p>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</p></li><li><p>自动故障转移</p><p>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</p></li><li><p>注意：哨兵也是一台redis服务器，只是不提供数据服务通常哨兵配置数量为单数</p></li></ul></li><li><p>启用哨兵模式</p><ul><li>配置一拖二的主从结构</li><li>配置三个哨兵（配置相同，端口不同）参看sentinel.conf</li><li>启动哨兵 redis-sentinel sentinel-端口号.conf</li></ul></li><li><p>配置哨兵</p><img src="/2020/02/07/redis/%E9%85%8D%E7%BD%AE%E5%93%A8%E5%85%B5.png" class="" title="配置哨兵"></li><li><p>哨兵在进行主从切换过程中经历三个阶段</p><img src="/2020/02/07/redis/%E7%9B%91%E6%8E%A7%E9%98%B6%E6%AE%B5.png" class="" title="监控阶段"><ul><li><p>监控</p><p>用于同步各个节点的状态信息</p><ul><li><p>获取各个sentinel的状态（是否在线）</p></li><li><p>获取master的状态  </p><p>master属性：runid role</p><p>各个slave的详细信息</p></li><li><p>获取所有slave的状态（根据master中的slave信息）</p><p>slave属性：runid、role、master_host、master_port、offset、……</p></li></ul></li><li><p>通知</p></li></ul><img src="/2020/02/07/redis/%E9%80%9A%E7%9F%A5%E9%98%B6%E6%AE%B5.png" class="" title="通知阶段"><ul><li><p>故障转移</p><p>服务器列表中挑选备选master</p><ul><li><p>在线的</p></li><li><p>响应快的</p></li><li><p>与原master断开时间短的</p></li><li><p>优先原则</p><p>优先级、offset、runid</p></li></ul><p>发送指令（sentinel ）</p><ul><li>向新的master发送slaveof no one</li><li>向其他slave发送slave of 新masterIP端口 </li></ul></li><li><p>总结</p><ol><li><p>监控</p><p>同步信息</p></li><li><p>通知</p><p>保持联通</p></li><li><p>故障转移</p><p>发现问题</p><p>竞选负责人</p><p>优选新master</p><p>新master上任，其他slave切换master，原master作为slave故障回复后连接</p></li></ol></li></ul></li></ul></li></ul><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><ul><li><p>概念</p><p>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，使其对外呈现单机的服务效果</p></li><li><p>作用</p><ul><li>分散单台服务器的访问压力，实现负载均衡</li><li>分散单台服务器的存储压力，实现可扩展性</li><li>降低单台服务器宕机带来的业务灾难</li></ul></li><li><p>数据存储设计</p><ul><li><p>通过算法设计，计算出key应该保存的位置</p></li><li><p>将所有的存储空间计划切割成16384份，每台主机保存一部分</p><p>每份代表的是一个存储空间，不是一个key的保存空间</p></li><li><p>将key按照计算出的结果放到对应的存储空间</p></li></ul></li><li><p>集群内部通讯设计</p><ul><li>各个数据库相互通信，保存各个库中槽的编号数据</li><li>一次命中，直接返回</li><li>一次未命中，告知具体位置</li></ul></li><li><p>搭建方式</p><ul><li>原生安装（单条命令）<ul><li>配置服务器（3主3从）</li><li>建立通信（Meet）</li><li>分槽（Slot）</li><li>搭建主从（master-slave）</li></ul></li><li>工具安装（批处理）</li></ul></li><li><p>Cluster配置</p><ul><li><p>添加节点</p><p>cluster-enabled yes|no</p></li><li><p>cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</p><p>cluster-config-file <filename></p></li><li><p>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</p><p>cluster-migration-barrier <count></p></li><li><p>master连接的slave最小数量</p><p>cluster-node-timeout <milliseconds></p></li></ul></li><li><p>Cluster节点操作命令</p><ul><li><p>查看集群节点信息</p><p>cluster nodes</p></li><li><p>进入一个从节点redis，切换其主节点</p><p>cluster replicate <master-id></p></li><li><p>发现一个新节点，新增主节点</p><p>cluster meet ip:port</p></li><li><p>忽略一个没有solt的节点</p><p>cluster forget <id></p></li><li><p>手动故障转移</p><p>cluster failover</p></li></ul></li><li><p>redis-trib命令</p><ul><li><p>添加节点</p><p>redis-trib.rb add-node</p></li><li><p>删除节点</p><p>redis-trib.rb del-node</p></li><li><p>重新分片</p><p>redis-trib.rb reshard</p></li></ul></li></ul><h2 id="企业级解决方案"><a href="#企业级解决方案" class="headerlink" title="企业级解决方案"></a>企业级解决方案</h2><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><ul><li><p>宕机</p><ul><li>请求数量较高</li><li>主从之间数据吞吐量较大，数据同步操作频度较高</li></ul></li><li><p>解决方案</p><ul><li>前置准备工作：<ol><li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li><li>利用LRU数据删除策略，构建数据留存队列例如：storm与kafka配合</li></ol></li><li>准备工作：<ol><li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li><li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li><li>热点数据主从同时</li></ol></li><li>预热实施：<ol><li>使用脚本程序固定触发数据预热过程</li><li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li></ol></li></ul></li><li><p>总结</p><p>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据</p></li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><ul><li>数据库服务器崩溃<ol><li>系统平稳运行过程中，忽然数据库连接量激增</li><li>应用服务器无法及时处理请求</li><li>大量408，500错误页面出现</li><li>客户反复刷新页面获取数据</li><li>数据库崩溃</li><li>应用服务器崩溃</li><li>重启应用服务器无效</li><li>Redis服务器崩溃</li><li>Redis集群崩溃</li><li>重启数据库后再次被瞬间流量放倒</li></ol></li><li>问题排查<ol><li>在一个较短的时间内，缓存中较多的key集中过期</li><li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li><li>数据库同时接收到大量的请求无法及时处理</li><li>Redis大量请求被积压，开始出现超时现象</li><li>数据库流量激增，数据库崩溃</li><li>重启后仍然面对缓存中无数据可用</li><li>Redis服务器资源被严重占用，Redis服务器崩溃</li><li>Redis集群呈现崩塌，集群瓦解</li><li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li><li>应用服务器，redis，数据库全部重启，效果不理想</li></ol></li><li>分析<ul><li>短时间范围内大量key集中过期</li></ul></li><li>解决方案思路<ol><li>更多的页面静态化处理</li><li>构建多级缓存架构Nginx缓存+redis缓存+ehcache缓存</li><li>检测Mysql严重耗时业务进行优化对数据库的瓶颈排查：例如超时查询、耗时较高事务等</li><li>灾难预警机制监控redis服务器性能指标<ul><li>CPU占用、CPU使用率</li><li>内存容量</li><li>查询平均响应时间</li><li>线程数</li></ul></li><li>限流、降级短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li></ol></li><li>解决方式<ol><li>LRU与LFU切换</li><li>数据有效期策略调整<ul><li>根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟</li><li>过期时间使用固定时间+随机值的形式，稀释集中到期的key的数量</li></ul></li><li>超热数据使用永久key</li><li>定期维护（自动+人工）对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li><li>加锁慎用！</li></ol></li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><ul><li><p>数据库服务器崩溃</p><ol><li>系统平稳运行过程中</li><li>数据库连接量瞬间激增</li><li>Redis服务器无大量key过期</li><li>Redis内存平稳，无波动</li><li>Redis服务器CPU正常</li><li>数据库崩溃</li></ol></li><li><p>问题排查</p><ol><li>Redis中某个key过期，该key访问量巨大</li><li>多个数据请求从服务器直接压到Redis后，均未命中</li><li>Redis在短时间内发起了大量对数据库中同一数据的访问</li></ol></li><li><p>分析</p><ul><li>单个高热数据key过期</li></ul></li><li><p>解决方案</p><ol><li>预先设定以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，加大此类信息key的过期时长注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</li><li>现场调整监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li><li>后台刷新数据启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li><li>二级缓存设置不同的失效时间，保障不会被同时淘汰就行</li><li>加锁分布式锁，防止被击穿，但是要注意也是性能瓶颈，慎重！</li></ol></li><li><p>总结</p><p>缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可</p></li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><ul><li><p>现象</p><ol><li>系统平稳运行过程中</li><li>应用服务器流量随时间增量较大</li><li>Redis服务器命中率随时间逐步降低</li><li>Redis内存平稳，内存无压力</li><li>Redis服务器CPU占用激增</li><li>数据库服务器压力激增</li><li>数据库崩溃</li></ol></li><li><p>问题排查</p><ol><li>Redis中大面积出现未命中</li><li>出现非正常URL访问</li></ol></li><li><p>分析</p><ul><li>获取的数据在数据库中也不存在，数据库查询未得到对应数据</li><li>Redis获取到null数据未进行持久化，直接返回</li><li>下次此类数据到达重复上述过程</li><li>出现黑客攻击服务器</li></ul></li><li><p>解决方案</p><ol><li>缓存null对查询结果为null的数据进行缓存（长期使用，定期清理），设定短时限，例如30-60秒，最高5分钟</li><li>白名单策略<ul><li>提前预热各种分类数据id对应的bitmaps，id作为bitmaps的offset，相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截（效率偏低）</li><li>使用布隆过滤器（有关布隆过滤器的命中问题对当前状况可以忽略）</li></ul></li><li>实施监控实时监控redis命中率（业务正常范围时，通常会有一个波动值）与null数据的占比<ul><li>非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象</li><li>活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控（运营）</li></ul></li><li>key加密问题出现后，临时启动防灾业务key，对key进行业务层传输加密服务，设定校验程序，过来的key校验例如每天随机分配60个加密串，挑选2到3个，混淆到页面数据id中，发现访问key不满足规则，驳回数据访问</li></ol></li><li><p>总结</p><p>缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p></li></ul><h3 id="性能指标监控"><a href="#性能指标监控" class="headerlink" title="性能指标监控"></a>性能指标监控</h3><ul><li>性能指标：Performance<ul><li>latency：Redis响应一个请求的时间</li><li>instantaneous_ops_per_sec：平均每秒处理请求总数</li><li>hit rate(calculated)：缓存命中率</li></ul></li><li>内存指标：Memory<ul><li>used_memory：Redis分配器分配的内存量，也就是实际存储数据的内存总量</li><li>mem_fragmentation_ratio：used_memory_rss /used_memory比值，表示内存碎片率</li><li>evicted_keys：由于maxmemory限制，而被回收内存的key的总数</li><li>blocked_clients：由于阻塞调用(BLPOP、BRPOP、BRPOPLPUSH)而等待的客户端的数量</li></ul></li><li>基本活动指标：Basic activity<ul><li>connected_clients：客户端连接数</li><li>connected_slaves：Slave数量</li><li>master_last_io_seconds_ago：最近一次主从交互之后的秒数</li><li>keyspace：数据库中的key值总数</li></ul></li><li>持久性指标：Persistence<ul><li>rdb_last_save_time：最后一次持久化保存到磁盘的Unix时间戳</li><li>rdb_changes_since_last_save：自最后一次持久化以来数据库的更改数</li></ul></li><li>错误指标：Error<ul><li>rejected_connections：由于maxclients限制而拒绝的连接数量</li><li>keyspace_misses：keyspace未命中次数</li><li>master_link_down_since_seconds：主从断开的持续时间</li></ul></li></ul><h3 id="监控方式"><a href="#监控方式" class="headerlink" title="监控方式"></a>监控方式</h3><ul><li><p>工具</p><ul><li>Cloud Insight Redis</li><li>Prometheus</li><li>Redis-stat</li><li>Redis-faina</li><li>RedisLive</li><li>zabbix</li></ul></li><li><p>命令</p><ul><li>benchmark</li><li>rediscli</li><li>monitor</li><li>slowlogs</li></ul></li><li><p>benchmark</p><ul><li>命令<ul><li>redis-benchmark [-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ]</li></ul></li><li>范例1<ul><li>redis-benchmark</li><li>说明：50个连接，10000次请求对应的性能</li></ul></li><li>范例2<ul><li>redis-benchmark -c 100 -n 5000</li><li>说明：100个连接，5000次请求对应的性能</li></ul></li></ul><img src="/2020/02/07/redis/benchmark%E5%91%BD%E4%BB%A4.png" class="" title="benchmark命令"></li><li><p>moniter</p><ul><li>命令打印服务器调试信息</li></ul></li><li><p>slowlog</p><ul><li><p>命令</p><p>slowlog[operator]</p><ul><li>get ：获取慢查询日志</li><li>len：获取慢查询日志条目数</li><li>reset ：重置慢查询日志</li></ul></li><li><p>相关配置</p><ul><li>slowlog-log-slower-than 1000 #设置慢查询的时间下线，单位：ms</li><li>slowlog-max-len 100          #设置慢查询命令对应的日志显示长度，单位：命令数</li></ul></li></ul></li></ul><script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({ "model": { jsonPath:"https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json","scale": 1 }, "display": { "position": "right","width": 100, "height": 200,"hOffset": 0, "vOffset": -20 }, "mobile": { "show": true, "scale": 0.5 },"react": { "opacityDefault": 0.7, "opacityOnHover": 0.2 } });</script>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 非关系型数据库 </tag>
            
            <tag> Redis集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC入门学习</title>
      <link href="/2020/02/01/springmvc/"/>
      <url>/2020/02/01/springmvc/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>三层架构<ul><li>表现层： 也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求 web 层，web 需要接收 http 请求，完成 http 响应。 表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系） </li><li>业务层： 也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业 务层，但是业务层不依赖 web 层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的， 事务应该放到业务层来控制） </li><li>持久层： 也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进 行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库 中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。</li></ul></li><li>MVC模型<ul><li>MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写， 是一种用于设计创建 Web 应用程序表现层的模式。</li><li>MVC 中每个部分各司其职： <ul><li>Model（模型）： 通常指的就是我们的数据模型。作用一般情况下用于封装数据。 </li><li>View（视图）： 通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。 通常视图是依据模型数据创建的。</li><li>Controller（控制器）： 是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。 它相对于前两个不是很好理解，这里举个例子： 例如： 我们要保存一个用户的信息，该用户信息中包含了姓名，性别，年龄等等。 这时候表单输入要求年龄必须是 1~100 之间的整数。姓名和性别不能为空。并且把数据填充 到模型之中。 此时除了 js 的校验之外，服务器端也应该有数据准确性的校验，那么校验就是控制器的该做 的。 当校验失败后，由控制器负责把错误页面展示给使用者。 如果校验成功，也是控制器负责把数据填充到模型，并且调用业务层实现完整的业务需求。</li></ul></li></ul></li><li>优点<ol><li>清晰的角色划分： <ul><li>前端控制器（DispatcherServlet） 请求到处理器映射（HandlerMapping） </li><li>处理器适配器（HandlerAdapter） </li><li>视图解析器（ViewResolver） 处理器或页面</li><li>控制器（Controller） </li><li>验证器（ Validator） </li><li>命令对象（Command 请求参数绑定到的对象就叫命令对象） </li><li>表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。 </li></ul></li><li>分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。 </li><li>由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。</li><li>和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。</li><li>可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。</li><li>可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。</li><li>功能强大的数据验证、格式化、绑定机制。</li><li>利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。</li><li>本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。</li><li>强大的 JSP 标签库，使 JSP 编写更容易。 ………………还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配 置支持等等。</li></ol></li><li>与Struts2对比<ul><li>共同点： <ul><li>它们都是表现层框架，都是基于 MVC 模型编写的。 </li><li>它们的底层都离不开原始 ServletAPI。 它们处理请求的机制都是一个核心控制器。 </li></ul></li><li>区别： <ul><li>Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter Spring MVC 是基于方法设计的，而 Struts2 是基于类，Struts2 每次执行都会创建一个动作类。所 以 Spring MVC 会稍微比 Struts2 快些。 </li><li>Spring MVC 使用更加简洁,同时还支持 JSR303, 处理 ajax 的请求更方便 (JSR303 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注 解加在我们 JavaBean 的属性上面，就可以在需要校验的时候进行校验了。) </li><li>Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些，但执行效率并没有比 JSTL 提 升，尤其是 struts2 的表单标签，远没有 html 执行效率高。</li></ul></li></ul></li></ul><h3 id="SpringMVC入门"><a href="#SpringMVC入门" class="headerlink" title="SpringMVC入门"></a>SpringMVC入门</h3><ul><li>SpringMVC执行流程原理</li></ul><img src="/2020/02/01/springmvc/springmvc%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8E%9F%E7%90%86.jpg" class="" title="springmvc执行流程原理"><ul><li><p>组件</p><ul><li><p>DispatcherServlet：前端控制器</p><ul><li>用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。</li></ul></li><li><p>HandlerMapping：处理器映射器 </p><ul><li>HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。</li></ul></li><li><p>Handler：处理器 </p><ul><li>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。 </li></ul></li><li><p>HandlAdapter：处理器适配器 </p><ul><li>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。 </li></ul></li><li><p>View Resolver：视图解析器 </p><ul><li>View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 </li></ul></li><li><p>View：视图 </p><ul><li>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView 等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开 发具体的页面。</li></ul></li><li><p>&lt;mvc:annotation-driven&gt;</p><p>在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为SpringMVC 的三大组件。 使用&lt;mvc:annotation-driven&gt;自动加载RequestMappingHandlerMapping（处理映射器）和RequestMappingHandlerAdapter（ 处 理 适 配 器 ）,可 用在SpringMVC.xml配置文件中使用 &lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。它就相当于在xml 中配置了：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span><span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- 相当于 如下配置--></span><span class="token comment" spellcheck="true">&lt;!-- Begin --></span><span class="token comment" spellcheck="true">&lt;!-- HandlerMapping --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- HandlerAdapter --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- HadnlerExceptionResolvers --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- End --></span></code></pre></li></ul></li><li><p>RequestMapping注解</p><ul><li><p>作用： 用于建立请求 URL 和处理请求方法之间的对应关系。</p></li><li><p>出现位置： </p><ul><li><p>类上： 请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。 它出现的目的是为了使我们的 URL 可以按照模块化管理: </p><p>例如</p><p>账户模块： </p><p>/account/add </p><p>/account/update </p><p>/account/delete … </p><p>订单模块： </p><p>/order/add </p><p>/order/update </p><p>/order/delete </p><p>前面的部分就是把 RequsetMappding 写在类上，使我们的 URL 更加精细。 </p></li><li><p>方法上： 请求 URL 的第二级访问目录。 </p></li></ul></li><li><p>属性： </p><ul><li><p>value：用于指定请求的 URL。它和 path 属性的作用是一样的。 </p></li><li><p>method：用于指定请求的方式。 </p></li><li><p>params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和 配置的一模一样。 </p><p>例如： </p><p>params = {“accountName”}，表示请求参数必须有 accountName </p><p>params = {“moeny!100”}，表示请求参数中 money 不能是 100。 </p></li><li><p>headers：用于指定限制请求消息头的条件。</p></li></ul></li></ul></li><li><p>流程小结</p><ol><li>创建工程，导入坐标 </li><li>在web.xml中配置前端控制器（启动服务器，加载springmvc.xml配置文件） </li><li>编写springmvc.xml配置文件 </li><li>编写index.jsp的页面，发送请求</li><li>编写Controller类，编写方法（@RequestMapping(path=”/hello”)），处理请求</li><li>编写配置文件（开启注解扫描），配置视图解析器 </li><li>执行的流程</li><li>@RequestMapping注解</li></ol></li></ul><h3 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h3><ul><li><p>请求参数的绑定说明 </p><ul><li><p>绑定机制 </p><ol><li>表单提交的数据都是k=v格式的 username=haha&amp;password=123 </li><li>SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的</li><li>要求：提交表单的name和参数的名称是相同的 </li></ol></li><li><p>支持的数据类型 </p><ol><li><p>基本数据类型和字符串类型 </p><ul><li>提交表单的name和参数的名称是相同的</li><li>区分大小写 </li></ul></li><li><p>实体类型（JavaBean）</p><ul><li><p>提交表单的name和JavaBean中的属性名称需要一致</p></li><li><p>如果一个JavaBean类中包含其他的引用类型，那么表单的name属性需要编写成：对象.属性 </p><p>例如： address.name </p></li></ul></li><li><p>集合数据类型（List、map集合等） </p></li><li><p>给集合属性数据封装</p><ul><li>JSP页面编写方式：list[0].属性</li></ul></li></ol></li><li><p>请求参数中文乱码的解决 </p><ul><li><p>在web.xml中配置Spring提供的过滤器类</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--配置解决中文乱码的过滤器--></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>characterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>org.springframework.web.filter.CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>encoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>characterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span></code></pre></li></ul></li><li><p>自定义类型转换器 </p><ul><li><p>表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明 Spring框架内部会默认进行数据类型转换。 </p></li><li><p>如果想自定义数据类型转换，可以实现Converter的接口 </p><ol><li><p>自定义类型转换器</p></li><li><p>注册自定义类型转换器，在springmvc.xml配置文件中编写配置</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--配置自定义类型转换器--></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>conversionService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.context.support.ConversionServiceFactoryBean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>converters<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>set</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.itcast.utils.StringToDateConverter<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>set</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre></li></ol></li></ul></li></ul></li></ul><h3 id="常用的注解"><a href="#常用的注解" class="headerlink" title="常用的注解"></a>常用的注解</h3><h4 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="RequestParam注解"></a>RequestParam注解</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path<span class="token operator">=</span><span class="token string">"/hello"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"username"</span><span class="token punctuation">,</span>required<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">)</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"aaaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>作用：把请求中的指定名称的参数传递给控制器中的形参赋值 </li><li>属性 <ul><li>value：请求参数中的名称</li><li>required：请求参数中是否必须提供此参数，默认值是true，必须提供</li></ul></li></ul><h4 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="RequestBody注解"></a>RequestBody注解</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/testRequestBody"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">testRequestBody</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> String body<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>作用：用于获取请求体的内容（注意：get方法不可以） </li><li>属性<ul><li>required：是否必须有请求体，默认值是true</li></ul></li></ul><h4 id="PathVariable注解"><a href="#PathVariable注解" class="headerlink" title="PathVariable注解"></a>PathVariable注解</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/testPathVariable/{sid}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">testPathVariable</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"sid"</span><span class="token punctuation">)</span> String id<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p>作用：拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符 </p></li><li><p>属性 </p><ul><li>value：指定url中的占位符名称 </li></ul></li><li><p>Restful风格的URL </p><p>请求路径一样，可以根据不同的请求方式去执行后台的不同方法 </p><p>restful风格的URL优点 </p><ul><li>结构清晰 </li><li>符合标准 </li><li>易于理解 </li><li>扩展方便</li></ul></li></ul><h4 id="RequestHeader注解"><a href="#RequestHeader注解" class="headerlink" title="RequestHeader注解"></a>RequestHeader注解</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/testRequestHeader"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">testRequestHeader</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestHeader</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"Accept"</span><span class="token punctuation">)</span> String header<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">,</span>HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// return "success";</span>    <span class="token comment" spellcheck="true">// response.sendRedirect(request.getContextPath()+"/anno/testCookieValue");</span>    <span class="token keyword">return</span> <span class="token string">"redirect:/param.jsp"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>作用：获取指定请求头的值</li><li>属性 <ul><li>value：请求头的名称</li></ul></li></ul><h4 id="CookieValue注解"><a href="#CookieValue注解" class="headerlink" title="CookieValue注解"></a>CookieValue注解</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path<span class="token operator">=</span><span class="token string">"/hello"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token annotation punctuation">@CookieValue</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"JSESSIONID"</span><span class="token punctuation">)</span> String cookieValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>cookieValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>作用：用于获取指定cookie的名称的值 </li><li>属性 <ul><li>value：cookie的名称</li></ul></li></ul><h4 id="ModelAttribute注解"><a href="#ModelAttribute注解" class="headerlink" title="ModelAttribute注解"></a>ModelAttribute注解</h4><ul><li><p>作用 </p><ul><li>出现在方法上：表示当前方法会在控制器方法执行前线执行。 </li><li>出现在参数上：获取指定的数据给参数赋值。 </li></ul></li><li><p>应用场景 </p><ul><li>当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据。</li></ul></li><li><p>案例</p><ul><li><p>修饰的方法有返回值</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ModelAttribute</span><span class="token keyword">public</span> User <span class="token function">showUser</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"showUser执行了..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 模拟从数据库中查询对象</span>   User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"哈哈"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   user<span class="token punctuation">.</span><span class="token function">setMoney</span><span class="token punctuation">(</span><span class="token number">100d</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> user<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path<span class="token operator">=</span><span class="token string">"/updateUser"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">updateUser</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>修饰的方法无返回值</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ModelAttribute</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showUser</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> User<span class="token operator">></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"showUser执行了..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 模拟从数据库中查询对象</span>   User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"哈哈"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   user<span class="token punctuation">.</span><span class="token function">setMoney</span><span class="token punctuation">(</span><span class="token number">100d</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path<span class="token operator">=</span><span class="token string">"/updateUser"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">updateUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@ModelAttribute</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"abc"</span><span class="token punctuation">)</span> User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li></ul><h4 id="SessionAttributes注解"><a href="#SessionAttributes注解" class="headerlink" title="SessionAttributes注解"></a>SessionAttributes注解</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/testSessionAttributes"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">testSessionAttributes</span><span class="token punctuation">(</span>Model model<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"testSessionAttributes..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 底层会存储到request域对象中</span>    model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span><span class="token string">"美美"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/getSessionAttributes"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">getSessionAttributes</span><span class="token punctuation">(</span>ModelMap modelMap<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getSessionAttributes..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String msg <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> modelMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/delSessionAttributes"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">delSessionAttributes</span><span class="token punctuation">(</span>SessionStatus status<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"getSessionAttributes..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    status<span class="token punctuation">.</span><span class="token function">setComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>作用：用于多次执行控制器方法间的参数共享 </li><li>属性 <ul><li>value：指定存入属性的名称</li></ul></li></ul><h3 id="响应数据和结果视图"><a href="#响应数据和结果视图" class="headerlink" title="响应数据和结果视图"></a>响应数据和结果视图</h3><h4 id="返回值分类"><a href="#返回值分类" class="headerlink" title="返回值分类"></a>返回值分类</h4><ul><li><p>返回字符串</p><ul><li><p>Controller方法返回字符串可以指定逻辑视图的名称，根据视图解析器为物理视图的地址</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/hello"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello SpringMVC!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 跳转到XX页面</span>   <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>应用</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**    * 请求参数的绑定    */</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"/initUpdate"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">initUpdate</span><span class="token punctuation">(</span>Model model<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 模拟从数据库中查询的数据</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setMoney</span><span class="token punctuation">(</span><span class="token number">100d</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setBirthday</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"update"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-jsp"><code class="language-jsp"><h3>执行成功</h3>    ${user.username}    ${user.password}    ${user.age}</code></pre></li></ul></li><li><p>返回值是void </p><ul><li><p>如果控制器的方法返回值编写成void，执行程序报404的异常，默认查找JSP页面没有找到。</p><p>默认会跳转到@RequestMapping(value=”/initUpdate”) initUpdate的页面。 </p></li><li><p>可以使用请求转发或者重定向跳转到指定的页面</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/testVoid"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testVoid</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"testVoid方法执行了..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 编写请求转发的程序</span>   <span class="token comment" spellcheck="true">// request.getRequestDispatcher("/WEB-INF/pages/success.jsp").forward(request,response);</span>   <span class="token comment" spellcheck="true">// 重定向</span>   <span class="token comment" spellcheck="true">// response.sendRedirect(request.getContextPath()+"/index.jsp");</span>   <span class="token comment" spellcheck="true">// 设置中文乱码</span>   response<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 直接会进行响应</span>   response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"你好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>返回值是ModelAndView对象 </p><ul><li><p>ModelAndView对象是Spring提供的一个对象，可以用来调整具体的JSP视图</p></li><li><p>应用</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/testModelAndView"</span><span class="token punctuation">)</span><span class="token keyword">public</span> ModelAndView <span class="token function">testModelAndView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建ModelAndView对象</span>    ModelAndView mv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"testModelAndView方法执行了..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 模拟从数据库中查询出User对象</span>    User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"小凤"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把user对象存储到mv对象中，也会把user对象存入到request对象</span>    mv<span class="token punctuation">.</span><span class="token function">addObject</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 跳转到哪个页面，过程中会使用视图解析器</span>    mv<span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> mv<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li></ul><h4 id="SpringMVC框架提供的转发和重定向"><a href="#SpringMVC框架提供的转发和重定向" class="headerlink" title="SpringMVC框架提供的转发和重定向"></a>SpringMVC框架提供的转发和重定向</h4><ul><li><p>forward请求转发 </p><ul><li><p>进行请求转发</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/testForwardOrRedirect"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">testForwardOrRedirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"testForwardOrRedirect方法执行了..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"forward:/WEB-INF/pages/success.jsp"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>redirect重定向</p><ul><li><p>进行重定向</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/testForwardOrRedirect"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"testForwardOrRedirect方法执行了..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token string">"redirect:/index.jsp"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>ResponseBody响应json数据</p><ul><li><p>DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而 不能被使用。</p><p>解决方式就是需要配置静态资源不进行拦截，在springmvc.xml配置文件添加mvc:resources标签配置不过滤 </p><ol><li><p>location元素表示webapp目录下的包下的所有文件 </p></li><li><p>mapping元素表示以/static开头的所有请求路径，如/static/a 或者/static/a/b</p><pre class=" language-jsp"><code class="language-jsp"><!-- 设置静态资源不过滤 --><mvc:resources location="/css/" mapping="/css/**"/> <!-- 样式 --><mvc:resources location="/images/" mapping="/images/**"/> <!-- 图片 --><mvc:resources location="/js/" mapping="/js/**"/> <!-- javascript --></code></pre></li></ol></li><li><p>使用@RequestBody获取请求体数据</p><pre class=" language-jsp"><code class="language-jsp"><script>// 页面加载，绑定单击事件    $(function(){        $("#btn").click(function(){            // alert("hello btn");            // 发送ajax请求            $.ajax({                // 编写json格式，设置属性和值                url:"user/testAjax",                contentType:"application/json;charset=UTF-8",                data:'{"username":"hehe","password":"123","age":30}',                dataType:"json",                type:"post",                success:function(data){                    // data服务器端响应的json的数据，进行解析                    alert(data);                }            });        });    });</script></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/testJson"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testJson</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> String body<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>使用@RequestBody注解把json的字符串转换成JavaBean的对象</p></li><li><p>使用@ResponseBody注解把JavaBean对象转换成json字符串，直接响应</p><p>要求方法需要返回JavaBean的对象</p><pre class=" language-jsp"><code class="language-jsp"><script>// 页面加载，绑定单击事件    $(function(){        $("#btn").click(function(){            // alert("hello btn");            // 发送ajax请求            $.ajax({                // 编写json格式，设置属性和值                url:"user/testAjax",                contentType:"application/json;charset=UTF-8",                data:'{"username":"hehe","password":"123","age":30}',                dataType:"json",                type:"post",                success:function(data){                    // data服务器端响应的json的数据，进行解析                    alert(data);                    alert(data.username);                    alert(data.password);                    alert(data.age);                }            });        });    });</script></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/testAjax"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@ResponseBody</span> User <span class="token function">testAjax</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> User user<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"testAjax方法执行了..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 客户端发送ajax的请求，传的是json字符串，后端把json字符串封装到user对象中</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 做响应，模拟查询数据库</span>    user<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"haha"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 做响应</span>    <span class="token keyword">return</span> user<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li></ul><h3 id="SpringMVC实现文件上传"><a href="#SpringMVC实现文件上传" class="headerlink" title="SpringMVC实现文件上传"></a>SpringMVC实现文件上传</h3><h4 id="传统文件上传"><a href="#传统文件上传" class="headerlink" title="传统文件上传"></a>传统文件上传</h4><ul><li><p>导入文件上传的jar包</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>编写文件上传的JSP页面</p><pre class=" language-jsp"><code class="language-jsp"><h3>文件上传</h3><form action="user/fileupload" method="post" enctype="multipart/form-data">    选择文件：<input type="file" name="upload"/><br/>    <input type="submit" value="上传文件"/></form></code></pre></li><li><p>编写文件上传的Controller控制器</p></li></ul><h4 id="SpringMVC方式文件上传"><a href="#SpringMVC方式文件上传" class="headerlink" title="SpringMVC方式文件上传"></a>SpringMVC方式文件上传</h4><ul><li><p>SpringMVC框架提供了MultipartFile对象，该对象表示上传的文件，要求变量名称必须和表单file标签的 name属性名称相同</p><ul><li><p>配置文件解析器对象</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--配置文件解析器对象--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>multipartResolver<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.web.multipart.commons.CommonsMultipartResolver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maxUploadSize<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10485760<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre></li><li><p>实现</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/fileupload2"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">fileupload2</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> MultipartFile upload<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"springmvc文件上传..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用fileupload组件完成文件上传</span>    <span class="token comment" spellcheck="true">// 上传的位置</span>    String path <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRealPath</span><span class="token punctuation">(</span><span class="token string">"/uploads/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断，该路径是否存在</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>file<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建该文件夹</span>    file<span class="token punctuation">.</span><span class="token function">mkdirs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 说明上传文件项</span>    <span class="token comment" spellcheck="true">// 获取上传文件的名称</span>    String filename <span class="token operator">=</span> upload<span class="token punctuation">.</span><span class="token function">getOriginalFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把文件的名称设置唯一值，uuid</span>    String uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    filename <span class="token operator">=</span> uuid<span class="token operator">+</span><span class="token string">"_"</span><span class="token operator">+</span>filename<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 完成文件上传</span>    upload<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>filename<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li></ul><h4 id="跨服务器方式的文件上传"><a href="#跨服务器方式的文件上传" class="headerlink" title="跨服务器方式的文件上传"></a>跨服务器方式的文件上传</h4><ul><li><p>分服务器的目的</p><ul><li><p>在实际开发中，我们会有很多处理不同功能的服务器。</p><p>例如： </p><ul><li>应用服务器：负责部署我们的应用 </li><li>数据库服务器：运行我们的数据库 </li><li>缓存和消息服务器：负责处理大并发访问的缓存和消息 </li><li>文件服务器：负责存储用户上传文件的服务器。</li></ul></li></ul></li><li><p>搭建图片服务器 </p></li><li><p>编写控制器</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/fileupload3"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">fileupload3</span><span class="token punctuation">(</span>MultipartFile upload<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"跨服务器文件上传..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义上传文件服务器路径</span>    String path <span class="token operator">=</span> <span class="token string">"http://localhost:9090/uploads/"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 说明上传文件项</span>    <span class="token comment" spellcheck="true">// 获取上传文件的名称</span>    String filename <span class="token operator">=</span> upload<span class="token punctuation">.</span><span class="token function">getOriginalFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把文件的名称设置唯一值，uuid</span>    String uuid <span class="token operator">=</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    filename <span class="token operator">=</span> uuid<span class="token operator">+</span><span class="token string">"_"</span><span class="token operator">+</span>filename<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建客户端的对象</span>    Client client <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 和图片服务器进行连接</span>    WebResource webResource <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">resource</span><span class="token punctuation">(</span>path <span class="token operator">+</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 上传文件</span>    webResource<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>upload<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token string">"success"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="SpringMVC的异常处理"><a href="#SpringMVC的异常处理" class="headerlink" title="SpringMVC的异常处理"></a>SpringMVC的异常处理</h3><ul><li><p>异常处理思路</p><ul><li>系统中异常包括两类：预期异常和运行时异常 RuntimeException，前者通过捕获异常从而获取异常信息， 后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。</li><li>系统的 dao、service、controller 出现都通过 throws Exception 向上抛出，最后由 springmvc 前端 控制器交由异常处理器进行异常处理</li></ul></li><li><p>异常处理方式</p><ul><li><p>自定义异常类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SysException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 存储提示信息的</span>   <span class="token keyword">private</span> String message<span class="token punctuation">;</span>   <span class="token keyword">public</span> String <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> message<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMessage</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token function">SysException</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>自定义异常处理器</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SysExceptionResolver</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerExceptionResolver</span><span class="token punctuation">{</span>   <span class="token keyword">public</span> ModelAndView <span class="token function">resolveException</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">,</span> Exception ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 获取到异常对象</span>       SysException e <span class="token operator">=</span> null<span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>ex <span class="token keyword">instanceof</span> <span class="token class-name">SysException</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       e <span class="token operator">=</span> <span class="token punctuation">(</span>SysException<span class="token punctuation">)</span>ex<span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>       e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SysException</span><span class="token punctuation">(</span><span class="token string">"系统正在维护...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 创建ModelAndView对象</span>       ModelAndView mv <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       mv<span class="token punctuation">.</span><span class="token function">addObject</span><span class="token punctuation">(</span><span class="token string">"errorMsg"</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       mv<span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> mv<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>配置异常处理器</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--配置异常处理器--></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sysExceptionResolver<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.itcast.exception.SysExceptionResolver<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre></li></ul></li></ul><h3 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a>SpringMVC拦截器</h3><h4 id="拦截器的作用"><a href="#拦截器的作用" class="headerlink" title="拦截器的作用"></a>拦截器的作用</h4><ul><li>Spring MVC 的处理器拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 用户可以自己定义一些拦截器来实现特定的功能。 </li><li>拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 </li><li>区别： <ul><li>过滤器是 servlet 规范中的一部分，任何 java web 工程都可以使用。 </li><li>拦截器是 SpringMVC 框架自己的，只有使用了 SpringMVC 框架的工程才能用。 </li><li>过滤器在 url-pattern 中配置了/*之后，可以对所有要访问的资源拦截。 </li><li>拦截器它是只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦 截的。 </li></ul></li><li>它也是 AOP 思想的具体应用。 我们要想自定义拦截器， 要求必须实现：HandlerInterceptor 接口</li></ul><h4 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h4><ul><li><p>编写拦截器</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterceptor1</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span><span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyInterceptor1执行了...前1111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// request.getRequestDispatcher("/WEB-INF/pages/error.jsp").forward(request,response);</span>       <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">,</span> ModelAndView modelAndView<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyInterceptor1执行了...后1111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// request.getRequestDispatcher("/WEB-INF/pages/error.jsp").forward(request,response);</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">,</span> Exception ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyInterceptor1执行了...最后1111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>配置拦截器</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--配置拦截器--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>interceptors</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--配置拦截器--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>interceptor</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 用于指定拦截的 url --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/user/*<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 用于指定排除的 url        &lt;mvc:exclude-mapping path=""/>        --></span>        <span class="token comment" spellcheck="true">&lt;!--配置拦截器对象--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cn.itcast.controller.cn.itcast.interceptor.MyInterceptor1<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>interceptor</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>interceptors</span><span class="token punctuation">></span></span></code></pre></li></ul><h4 id="拦截器的细节"><a href="#拦截器的细节" class="headerlink" title="拦截器的细节"></a>拦截器的细节</h4><ul><li><p>preHandle方法是controller方法执行前拦截的方法</p><ul><li>可以使用request或者response跳转到指定的页面</li><li>return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。</li><li>return false不放行，不会执行controller中的方法。</li></ul></li><li><p>postHandle是controller方法执行后执行的方法，在JSP视图执行前。</p><ul><li>可以使用request或者response跳转到指定的页面</li><li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示</li></ul></li><li><p>postHandle方法是在JSP执行后执行</p><ul><li>request或者response不能再跳转页面了</li></ul><script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({ "model": { jsonPath:"https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json","scale": 1 }, "display": { "position": "right","width": 100, "height": 200,"hOffset": 0, "vOffset": -20 }, "mobile": { "show": true, "scale": 0.5 },"react": { "opacityDefault": 0.7, "opacityOnHover": 0.2 } });</script></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 开源框架 </tag>
            
            <tag> 前后端分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL技术内幕阅读笔记</title>
      <link href="/2020/01/30/mysql-ji-zhu-nei-mu/"/>
      <url>/2020/01/30/mysql-ji-zhu-nei-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL技术内幕"><a href="#MySQL技术内幕" class="headerlink" title="MySQL技术内幕"></a>MySQL技术内幕</h1><h3 id="InnoDB体系结构"><a href="#InnoDB体系结构" class="headerlink" title="InnoDB体系结构"></a>InnoDB体系结构</h3><img src="/2020/01/30/mysql-ji-zhu-nei-mu/InnoDB%E6%9E%B6%E6%9E%84.jpeg" class="" title="InnoDB架构"><h4 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h4><ul><li><p>Master Thread</p><p>将缓冲池的数据异步刷新到磁盘，保证数据一致性，包括脏页刷新、合并插入缓冲、undo页的回收</p></li><li><p>IO Thread</p><ul><li>write</li><li>read</li><li>insert buffer</li><li>log IO thread</li></ul></li><li><p>Purge Thread</p><p>回收已使用并分配的undo页</p></li><li><p>Page Cleaner Thread</p></li></ul><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><ul><li><p>缓冲池</p><p>主要是索引页和数据页</p><ul><li>索引页</li><li>数据页</li><li>undo页</li><li>插入缓存</li><li>自适应hash索引</li><li>InnoDB的锁信息</li><li>数据字典信息</li></ul></li><li><p>LRU List、Free List、Flush List</p><ul><li><p>LRU 最近最少使用</p><p>其中MySQL进行优化，最近使用的将放入midpoint，默认5/8的位置，可通过innodb_old_blocks_pct设置，其中midpoint前面为热点数据</p><p>此外可以通过设置innodb_old_blocks_time调整放入midpoint多久能进入热点数据</p></li><li><p>Flush List</p><p>LRU List中的页被修改后加入Flush List，并刷入磁盘</p></li></ul></li><li><p>重做缓冲日志</p></li><li><p>额外的内存池</p></li></ul><h4 id="Checkpoint技术"><a href="#Checkpoint技术" class="headerlink" title="Checkpoint技术"></a>Checkpoint技术</h4><p>当前数据库系统基本采用了事务提交时先写重做日志再修改页的策略，宕机时通过重做日志完成数据恢复</p><ul><li>解决的问题<ol><li>缩短恢复时间</li><li>缓冲池不够用时，脏页刷新到磁盘</li><li>重做日志不可用时，刷新脏页</li></ol></li></ul><p>Sharp Checkpoint与Fuzzy Checkpoint，前者为数据库关闭时的默认工作方式，后者采用部分刷新回磁盘的方式，Fuzzy checkpoint包括</p><ul><li><p>Master Thread Checkpoint</p><p>每秒或每十秒从缓冲池中刷新一定比例的页面回磁盘，异步过程，用户查询线程不会阻塞</p></li><li><p>Flush_LRU_List Checkpoint</p><p>innodb_lru_scan_depth控制LRU列表中可用页的数量，默认1024</p></li><li><p>Async/Sync Flush Checkpoint</p><p>保证重做日志的循环使用的可用性</p></li><li><p>Dirty Page too much Checkpoint</p><p>innodb_max_dirty_pages_pct保证缓冲池有足够的页默认75（75%的脏页则强制Checkpoint</p></li></ul><h4 id="Master-Thread工作方式"><a href="#Master-Thread工作方式" class="headerlink" title="Master Thread工作方式"></a>Master Thread工作方式</h4><ul><li>每秒一次的操作<ul><li>日志缓冲刷新到磁盘，即使该事务未提交（总是</li><li>合并插入缓冲（可能</li><li>刷新innodb_io_capacity个InnoDB的缓冲池的脏页到磁盘（可能</li><li>如果当前没有用户活动则切换到background loop（可能</li></ul></li><li>每10秒一次的操作<ul><li>刷新innodb_io_capacity个脏页到磁盘（可能的情况下</li><li>合并5%innodb_io_capacity个插入缓冲（总是</li><li>将日志缓冲刷新到磁盘（总是</li><li>删除无用的undo页（总是</li></ul></li></ul><p>最新的InnoDB版本将刷新脏页的操作放到了Page Cleaner Thread中</p><h4 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h4><ul><li><p>插入缓冲</p><ol><li><p>Insert Buffer</p><p>使用需要满足两个条件</p><ul><li>索引是辅助索引</li><li>索引不是唯一的</li></ul></li><li><p>Change Buffer</p><p>可视为Insert Buffer的升级</p></li><li><p>Insert Buffer实现</p><p>全局有一颗Insert Buffer B+树</p></li><li><p>Merge Insert Buffer</p><p>若发现插入的辅助索引不在缓冲池中，则将辅助索引记录加入B+树，时机可能为</p><ul><li>辅助索引页被读入缓冲池</li><li>Insert Buffer Bitmap追踪到辅助索引页已无可用空间</li><li>Master Thread中每10s进行的merge</li></ul></li></ol></li><li><p>两次写</p><p>由两部分组成，内存中的doublewriter buffer和共享表空间中的连续的128个页，先写memcpy到内存，再写入共享表同步磁盘</p></li><li><p>自适应哈希索引</p><p>通过缓冲池的B+树页构造而来，InnoDB会自动根据访问的频率和模式为热点页建立哈希索引</p></li><li><p>异步IO</p><p>可以进行合并页访问</p></li><li><p>刷新邻接页</p><p>针对机械硬盘的优化</p></li></ul><h4 id="启动关闭和恢复"><a href="#启动关闭和恢复" class="headerlink" title="启动关闭和恢复"></a>启动关闭和恢复</h4><ul><li><p>innodb_fast_shutdown </p><ul><li><p>为0时</p><p>关闭时完成全部full purge、merge insert buffer，将所有脏页刷新回磁盘；</p><p>升级时使用</p></li><li><p>为1时（默认值</p><p>关闭时刷新部分脏页</p></li><li><p>为2时</p><p>将日志写回日志文件，下次启动进行恢复操作</p></li></ul></li><li><p>innodb_force_recovery</p><p>默认0，非0值控制选择性恢复</p></li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><h4 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h4><ul><li>参数<ul><li>采用K-V描述</li></ul></li><li>参数类型<ul><li>动态 可通过运行时 set</li><li>静态 运行期不可改</li></ul></li></ul><h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><ul><li><p>错误日志</p><pre class=" language-mysql"><code class="language-mysql">show variables like 'log_error'\g;</code></pre></li><li><p>慢查询日志</p><ul><li><p>long_query_time</p><p>慢查询的阈值</p></li><li><p>log_slow_queries</p><p>慢查询开启</p></li><li><p>log_queries_not_using_indexes</p><p>记录索引失效</p></li></ul></li><li><p>查询日志</p><p>记录全部操作</p></li><li><p>二进制日志</p><p>记录所有更改数据库的操作</p></li></ul><h4 id="套接字文件"><a href="#套接字文件" class="headerlink" title="套接字文件"></a>套接字文件</h4><p>UNIX系统，socket控制</p><h4 id="pid文件"><a href="#pid文件" class="headerlink" title="pid文件"></a>pid文件</h4><p>记录自身进程ID</p><h4 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h4><p>frm文件记录表结构定义</p><h4 id="InnoDB储存引擎文件"><a href="#InnoDB储存引擎文件" class="headerlink" title="InnoDB储存引擎文件"></a>InnoDB储存引擎文件</h4><ul><li><p>表空间文件</p><ul><li><p>innodb_data_file_path设置共享表空间位置</p></li><li><p>innodb_file_per_table设置是否为表设置独立表空间</p></li></ul></li><li><p>重做日志文件</p><ul><li>记录了事务日志，多个大小一致的重做日志文件组循环写入</li></ul></li></ul><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><h4 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h4><ul><li>选择或创建主键<ul><li>判断是否有非空的唯一索引，有则为主键</li><li>否则自动创建6byte的指针</li></ul></li></ul><h4 id="逻辑储存引擎"><a href="#逻辑储存引擎" class="headerlink" title="逻辑储存引擎"></a>逻辑储存引擎</h4><img src="/2020/01/30/mysql-ji-zhu-nei-mu/InnoDB%E9%80%BB%E8%BE%91%E5%82%A8%E5%AD%98%E7%BB%93%E6%9E%84.png" class="" title="InnoDB逻辑储存结构"><ul><li><p>表空间</p><ul><li>未启用独立表空间则放在共享表空间</li><li>开启则讲数据、索引、插入缓冲和Bitmap页放入独立表空间</li></ul></li><li><p>段</p><ul><li>数据段为叶子节点</li><li>索引段为非叶子节点</li></ul></li><li><p>区</p></li><li><p>页</p><p>InnoDB管理磁盘的最小单位</p></li><li><p>行</p></li></ul><h4 id="InnoDB行记录格式"><a href="#InnoDB行记录格式" class="headerlink" title="InnoDB行记录格式"></a>InnoDB行记录格式</h4><h4 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h4><h3 id="索引与算法"><a href="#索引与算法" class="headerlink" title="索引与算法"></a>索引与算法</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>InnoDB常用索引<ul><li>B+树</li><li>全文索引</li><li>hash索引</li></ul></li></ul><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><ul><li><p>B+树的插入</p><img src="/2020/01/30/mysql-ji-zhu-nei-mu/B+%E6%A0%91%E6%8F%92%E5%85%A5%E7%9A%843%E7%A7%8D%E6%83%85%E5%86%B5.png" class="" title="B+树插入的3种情况"></li><li><p>B+树的删除</p><img src="/2020/01/30/mysql-ji-zhu-nei-mu/B+%E6%A0%91%E5%88%A0%E9%99%A4%E7%9A%843%E7%A7%8D%E6%83%85%E5%86%B5.png" class="" title="B+树删除的3种情况"></li></ul><h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><ul><li>聚集索引（并不是物理储存上连续<ul><li>页通过双向链表连接，按照主键的顺序排序</li><li>每个页中的记录也是通过双向链表进行维护的</li></ul></li><li>辅助索引</li></ul><h4 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h4><ul><li><p>索引管理</p><p>show index显示结果</p><ul><li>Table：所在表名</li><li>Non_unique：非唯一的索引，primary key则为0</li><li>key_name：索引名</li><li>seq_in_index：索引中该列位置</li><li>column_name：索引列名称</li><li>collation：列以什么方式储存在索引中，可以为A或NULL，B+树索引为A（排序的</li><li>Cardinality：表示索引中唯一值的数目的估计值，Cardinality表的行数应尽可能接近1，若非常小，可考虑删除此索引</li><li>Packed：关键字如何被压缩</li><li>NULL：索引列是否含有NULL值</li><li>Index_type：索引类型</li><li>Comment：注释</li></ul><p>Fast Index Creation</p><ul><li>对于辅助索引不需要重建表，通过内部视图建立、删除</li></ul><p>Online Schema Change</p><p>Online DDL</p></li><li><p>Cardinality值</p></li></ul><h4 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h4><ul><li>联合索引</li><li>覆盖索引</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="lock与latch"><a href="#lock与latch" class="headerlink" title="lock与latch"></a>lock与latch</h4><img src="/2020/01/30/mysql-ji-zhu-nei-mu/lock%E4%B8%8Elatch.png" class="" title="lock与latch"><ul><li>latch为轻量级的锁，要求锁定的时间短，否则性能差，InnoDB中分为两种<ul><li>lock</li><li>latch</li></ul></li><li>lock对象针对事务，用于锁定表页行</li></ul><h4 id="储存引擎中的锁"><a href="#储存引擎中的锁" class="headerlink" title="储存引擎中的锁"></a>储存引擎中的锁</h4><ul><li>锁的类型<ul><li>共享锁</li><li>排他锁</li></ul></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 关系型数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis入门学习</title>
      <link href="/2020/01/20/mybatis/"/>
      <url>/2020/01/20/mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul><li><p>mybatis 是一个优秀的基于 java 的持久层框架，它内部封装了 jdbc，使开发者只需要关注 sql 语句本身， 而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。 </p></li><li><p>mybatis 通过 xml 或注解的方式将要执行的各种 statement 配置起来，并通过 java 对象和 statement 中 sql 的动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并 返回。 </p></li><li><p>采用 ORM 思想解决了实体和数据库映射的问题，对 jdbc 进行了封装，屏蔽了 jdbc api 底层访问细节，使我 们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。</p></li><li><p>ORM（Object Relational Mappging）对象关系映射</p><p>即把数据库表和实体类即实体类的属性对应起来，让我们可以操作实体类实现操作数据库表</p></li></ul><h2 id="2-入门"><a href="#2-入门" class="headerlink" title="2.入门"></a>2.入门</h2><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><ul><li><p>创建maven工程并导入坐标</p></li><li><p>创建实体类和dao的接口</p></li><li><p>创建Mybatis的主配置文件</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置环境 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 配置mysql的环境--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 配置事务的类型--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 配置数据源（连接池） --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 配置连接数据库的4个基本信息 --></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.mysql.jdbc.Driver<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://localhost:3306/eesy<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">></span></span></code></pre></li><li><p>创建映射配置文件</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima.dao.IUserDao<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--配置查询所有--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAll<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima.domain.User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre></li><li><p>环境搭建注意事项</p><ul><li>在mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper</li><li>mybatis的映射配置文件配置必须和dao接口的包结构相同。</li><li>映射配置文件的Mapper标签和namesplace的属性值必须是dao接口的全限定类名。</li><li>映射配置文件的操作配置(select)，id属性的取值必须是dao类接口。</li><li>当我们遵从了以上注意项之后，我们在开发中就无需再写dao的实现类。</li></ul></li></ul><h4 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1.读取配置文件</span>InputStream in <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"SqlMapConfig.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2.创建SqlSessionFactory工厂</span>SqlSessionFactoryBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SqlSessionFactory factory <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3.使用工厂生产SqlSession对象</span>SqlSession session <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4.使用SqlSession创建Dao接口的代理对象</span>IUserDao userDao <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>IUserDao<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//5.使用代理对象执行方法</span>List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>User user <span class="token operator">:</span> users<span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//6.释放资源</span>session<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>注意事项：</p><p>不要忘记在映射配置中告知Mybatis要封装到哪个实体类中，配置的方式:指定实体类的全限定类名</p><ul><li><p>Mybatis基于注解的入门案例：</p><ul><li>把IUserDao移除，在dao接口的方法上使用@Select注解，并且指定SQL语句，同时需要在SqlMapConfig.xml的Mapper配置时，使用class属性指定dao接口的全限定类名</li><li>实际开发中一般不写dao实现类（无论是xml还是注解，而Mybatis也支持写dao实现类</li></ul></li><li><p>自定义Mybatis的设计模式</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1.读取配置文件</span>InputStream in <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"SqlMapConfig.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2.创建SqlSessionFactory工厂</span>SqlSessionFactoryBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SqlSessionFactory factory <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3.使用工厂生产SqlSession对象</span>SqlSession session <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//4.使用SqlSession创建Dao接口的代理对象</span>IUserDao userDao <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>IUserDao<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//5.使用代理对象执行方法</span>List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> userDao<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><p>工厂模式</p></li><li><p>构造者模式</p><p>在创建工厂时使用SqlSessionFactoryBuilder进行构建</p></li><li><p>代理模式</p></li></ul></li></ul><h4 id="自定义Mybatis的分析"><a href="#自定义Mybatis的分析" class="headerlink" title="自定义Mybatis的分析"></a>自定义Mybatis的分析</h4><ol><li><p>根据配置文件的信息创建Connection对象</p><p>注册驱动获取链接</p></li><li><p>获取预处理对象PreparedStatement</p><p>conn.preparedStatement(sql);</p></li><li><p>执行查询</p><p><code>ResultSet resultSet=preparedStatement.executeQuery();</code></p></li><li><p>遍历结果进行封装</p><pre class=" language-java"><code class="language-java">List list<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>resultSet<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    E element<span class="token operator">=</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span>Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>配置的全限定类名<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**    * 进行封装，把每个rs的内容都添加到element中       * 我们就把表的列名看成实体类的属性名称       * 就可以使用反射的方式来根据名称获得每个属性，并把值赋进去       */</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><ul><li><p>使以上方法执行需要提供两个信息</p><ul><li><p>连接信息</p></li><li><p>映射信息</p><p>映射信息包含执行的sql以及封装的实体类的全限定类名，二者合并为一个对象Mapper</p></li></ul></li><li><pre class=" language-java"><code class="language-java">IUserDao userDao <span class="token operator">=</span> session<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>IUserDao<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据Dao接口的字节码创建dao的代理对象</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">getMapper</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> daoInterface<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**    * 类加载器：使用和被代理对象相同的类加载器    * 代理对象实现的接口：和被代理对象相同的接口    * 如何被代理：即InvocationHandler接口的自定义实现类，并实现selectList方法    */</span>    Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>类加载器，代理对象要实现的接口字节码，如何代理<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h2 id="3-MyBatisCRUD"><a href="#3-MyBatisCRUD" class="headerlink" title="3.MyBatisCRUD"></a>3.MyBatisCRUD</h2><h4 id="MyBatis自定义流程"><a href="#MyBatis自定义流程" class="headerlink" title="MyBatis自定义流程"></a>MyBatis自定义流程</h4><ul><li><p>SqlSessionFactoryBuilder接收SqlMapConfig.xml文件流，构建出SqlSessionFactory对象</p></li><li><p>SqlSessionFactory读取SqlMapConfig.xml中连接数据库信息和mapper映射信息，用来生产出真正操作数据库的SqlSession对象</p></li><li><p>SqlSession作用  无论哪个分支，除了获取数据库信息，还需要得到sql语句</p><ul><li><p>生成代理接口  </p><p>SqlSessionImpl对象的getMapper方法分两步来实现</p><ol><li>先用SqlSessionFactory读取的数据库连接信息建立Connection对象</li><li>通过jdk代理模式创建出代理对象作为getMapper的方法返回值，这里主要是在创建代理对象时第三个参数处理类里面得到sql语句执行对应的CRUD操作</li></ol></li><li><p>定义通用CRUD方法</p><p>SqlSessionImpl对象中提供selectList()方法</p><ol><li>用SqlSessionFactory读取的数据库连接信息创建出jdbc的Connection对象</li><li>直接得到sql语句，使用jdbc的Connection对象进行对应的CRUD操作</li></ol></li></ul></li><li><p>封装结果集</p><p>将结果封装为java对象返回调用者，因此需要获取返回的结果类型</p></li></ul><h4 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h4><ul><li><p>查询</p><pre class=" language-xml"><code class="language-xml">  <span class="token comment" spellcheck="true">&lt;!--根据id查询--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findById<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima.domain.User<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      select * from user where id = #{uid}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><p>resultType属性：用于指定结果集的类型。</p><p>parameterType属性：用于指定传入参数的类型。</p><p>sql语句中使用#{}字符：它代表占位符，相当于jdbc部分的?，都是用于执行语句时替换实际的数据。具体的数据是由#{}里面的内容决定的。</p><p>#{}中内容的写法：由于数据类型是基本类型，所以此处可以随意写。</p></li><li><p>插入</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--保存用户--></span>&lt;insertid="saveUser" parameterType="com.itheima.domain.User">    insert into user(username,birthday,sex,address)         values(#{username},#{birthday},#{sex},#{address})<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span></code></pre><p>parameterType属性：代表参数的类型，因为我们要传入的是一个类的对象，所以类型就写类的全名称。sql语句中使用#{}字符：它代表占位符，相当于jdbc部分的?，都是用于执行语句时替换实际的数据。具体的数据是由#{}里面的内容决定的。</p><p>#{}中内容的写法：由于我们保存方法的参数是一个User对象，此处要写User对象中的属性名称。它用的是ognl表达式。</p><p>ognl表达式：它是apache提供的一种表达式语言，全称是：Object Graphic Navigation Language  对象图导航语言它是按照一定的语法格式来获取数据的。语法格式就是使用#{对象.对象}的方式，#{user.username}它会先去找user对象，然后在user对象中找到username属性，并调用getUsername()方法把值取出来。但是我们在parameterType属性上指定了实体类名称，所以可以省略user.而直接写username</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 新增用户后，同时还要返回当前新增用户的id值，因为id是由数据库的自动增长来实现的，所以就相当于我们要在新增后将自动增长auto_increment的值返回。 --></span>&lt;insertid="saveUser" parameterType="USER">    <span class="token comment" spellcheck="true">&lt;!--配置保存时获取插入的id --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>selectKey</span> <span class="token attr-name">keyColumn</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select last_insert_id();    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>selectKey</span><span class="token punctuation">></span></span>    insert into user(username,birthday,sex,address) values(#{username},#{birthday},#{sex},#{address})<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span></code></pre></li><li><p>更新用户</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--更新用户--></span>&lt;updateid="updateUser" parameterType="com.itheima.domain.User">    update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address} where id=#{id}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>update</span><span class="token punctuation">></span></span></code></pre></li><li><p>删除用户</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--删除用户--></span>&lt;deleteid="deleteUser" parameterType="java.lang.Integer">    delete from user where id = #{uid}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>delete</span><span class="token punctuation">></span></span></code></pre></li><li><p>模糊查询</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--根据名称模糊查询--></span>&lt;selectid="findByName" resultType="com.itheima.domain.User" parameterType="String">    select * from user where usernamelike #{username}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><ul><li><p>#{}表示一个占位符号</p><p>通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。#{}可以接收简单类型值或pojo属性值。如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。</p></li><li><p>${}表示拼接sql串</p><p>通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换，${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。</p></li></ul></li></ul><ul><li><p>SqlMapConfig.xml</p><ul><li><p>-properties（属性）</p><p>–property</p></li><li><p>-settings（全局配置参数）</p><p>–setting</p></li><li><p>-typeAliases（类型别名）</p><p>–typeAliase</p><p>–package</p></li><li><p>-typeHandlers（类型处理器）</p></li><li><p>-objectFactory（对象工厂）</p></li><li><p>-plugins（插件）</p></li><li><p>-environments（环境集合属性对象）</p><p>–environment（环境子属性对象）</p><ul><li>—transactionManager（事务管理）</li><li>—dataSource（数据源）</li></ul></li><li><p>-mappers（映射器）</p><ul><li>–mapper</li><li>–package</li></ul></li></ul><pre class=" language-xml-dtd"><code class="language-xml-dtd"><configuration>    <!-- 配置properties        可以在标签内部配置连接数据库的信息。也可以通过属性引用外部配置文件信息        resource属性： 常用的            用于指定配置文件的位置，是按照类路径的写法来写，并且必须存在于类路径下。        url属性：            是要求按照Url的写法来写地址            URL：Uniform Resource Locator 统一资源定位符。它是可以唯一标识一个资源的位置。            它的写法：                http://localhost:8080/mybatisserver/demo1Servlet                协议      主机     端口       URI            URI:Uniform Resource Identifier 统一资源标识符。它是在应用中可以唯一定位一个资源的。    -->    <properties url="file:///C:/Users/hawk4/IdeaProjects/MybatisLearning/Mybatis_day02/day02_eesy_01mybatisCRUD/src/main/resources/jdbcConfig.properties">    </properties>    <!--使用typeAliases配置别名，它只能配置domain中类的别名 -->    <typeAliases>        <!--typeAlias用于配置别名。type属性指定的是实体类全限定类名。alias属性指定别名，当指定了别名就再区分大小写         <typeAlias type="com.itheima.domain.User" alias="user"></typeAlias>-->        <!-- 用于指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写-->        <package name="com.itheima.domain"/>    </typeAliases>    <!--配置环境-->    <environments default="mysql">        <!-- 配置mysql的环境-->        <environment id="mysql">            <!-- 配置事务 -->            <transactionManager type="JDBC"/>            <!--配置连接池-->            <dataSource type="POOLED">                <property name="driver" value="${jdbc.driver}"/>                <property name="url" value="${jdbc.url}"/>                <property name="username" value="${jdbc.username}"/>                <property name="password" value="${jdbc.password}"/>                <!--<property name="driver" value="com.mysql.jdbc.Driver"/>                <property name="url" value="jdbc:mysql://localhost:3306/eesy"/>                <property name="username" value="root"/>                <property name="password" value="1234"/>-->            </dataSource>        </environment>    </environments>    <!-- 配置映射文件的位置 -->    <mappers>        <!--<mapper resource="com/itheima/dao/IUserDao.xml"></mapper>-->        <!-- package标签是用于指定dao接口所在的包,当指定了之后就不需要在写mapper以及resource或者class了 -->        <package name="com.itheima.dao"/>    </mappers></configuration></code></pre></li><li><p>mybatis中的连接池</p><p>可以减少我们获取连接所消耗的时间</p><p>mybatis连接池提供了3种方式的配置：</p><ul><li><p>配置的位置：<br>主配置文件SqlMapConfig.xml中的dataSource标签，type属性就是表示采用何种连接池方式。</p></li><li><p>type属性的取值：</p><ul><li><p>POOLED</p><p>采用传统的javax.sql.DataSource规范中的连接池，mybatis中有针对规范的实现</p></li><li><p>UNPOOLED</p><p>采用传统的获取连接的方式，虽然也实现Javax.sql.DataSource接口，但是并没有使用池的思想。</p></li><li><p>JNDI</p><p>采用服务器提供的JNDI技术实现，来获取DataSource对象，不同的服务器所能拿到DataSource是不一样。注意：如果不是web或者maven的war工程，是不能使用的。</p></li></ul></li></ul></li></ul><h4 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h4><ul><li><p>&lt;if&gt;</p></li><li><p>&lt;where&gt;</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findUserByCondition<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from user        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userName !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                and username = #{userName}            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userSex !<span class="token punctuation">=</span> null<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                and sex = #{userSex}            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li><p>&lt;foreach&gt;</p><pre class=" language-xaml"><code class="language-xaml"><!-- 根据queryvo中的Id集合实现查询用户列表 -->    <select id="findUserInIds" resultMap="userMap" parameterType="queryvo">        <include refid="defaultUser"/>        <where>            <if test="ids != null and ids.size()>0">                <foreach collection="ids" open="and id in (" close=")" item="uid" separator=",">                    #{uid}                </foreach>            </if>        </where>    </select></code></pre></li></ul><ul><li><p>多表查询</p><ul><li><p>一对一查询（多对一</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 定义封装account和user的resultMap --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountUserMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>account<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aid<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>uid<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>uid<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>money<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>money<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 一对一的关系映射：配置封装user的内容--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>uid<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>association</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--查询所有账户同时包含用户名和地址信息--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAllAccount<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountuser<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select a.*,u.username,u.address from account a , user u where u.id = a.uid;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li><p>一对多查询</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 定义User的resultMap--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userAccountMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 配置user对象中accounts集合的映射 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accounts<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>account<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aid<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>uid<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>uid<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>money<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>money<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 查询所有 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAll<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userAccountMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from user u left outer join account a on u.id = a.uid    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li><p>多对多查询</p><pre class=" language-xml"><code class="language-xml">    <span class="token comment" spellcheck="true">&lt;!-- 定义User的resultMap--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 配置角色集合的映射 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roles<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>role<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleId<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rid<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleName<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>role_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>roleDesc<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>role_desc<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>collection</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 查询所有 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAll<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select u.*,r.id as rid,r.role_name,r.role_desc from user u         left outer join user_role ur  on u.id = ur.uid         left outer join role r on r.id = ur.rid    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li></ul></li><li><p>延迟加载策略</p><ul><li><p>多对一</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 定义封装account和user的resultMap --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountUserMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>account<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>uid<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>uid<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>money<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>money<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 一对一的关系映射：配置封装user的内容        select属性指定的内容：查询用户的唯一标识：        column属性指定的内容：用户根据id查询时，所需要的参数的值        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>association</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>uid<span class="token punctuation">"</span></span> <span class="token attr-name">javaType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima.dao.IUserDao.findById<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 查询所有 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAll<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountUserMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from account    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li><li><p>一对多</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 定义User的resultMap--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userAccountMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>address<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>birthday<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 配置user对象中accounts集合的映射 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>collection</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accounts<span class="token punctuation">"</span></span> <span class="token attr-name">ofType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>account<span class="token punctuation">"</span></span> <span class="token attr-name">select</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima.dao.IAccountDao.findAccountByUid<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 查询所有 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findAll<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>userAccountMap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li></ul></li></ul><h4 id="Mybatis缓存"><a href="#Mybatis缓存" class="headerlink" title="Mybatis缓存"></a>Mybatis缓存</h4><ul><li><p>缓存是存在于内存中的临时数据。<br>减少和数据库的交互次数，提高执行效率。</p><ul><li>适用于缓存：<br>经常查询并且不经常改变的。<br>数据的正确与否对最终结果影响不大的。</li><li>不适用于缓存：<br>经常改变的数据<br>数据的正确与否对最终结果影响很大的。例如：商品的库存，银行的汇率，股市的牌价。</li></ul></li><li><p>Mybatis中的一级缓存和二级缓存</p><ul><li><p>一级缓存：<br>Mybatis中SqlSession对象的缓存。<br>当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块区域中。<br>该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去sqlsession中<br>查询是否有，有的话直接拿出来用。<br>当SqlSession对象消失时，mybatis的一级缓存也就消失了。</p></li><li><p>二级缓存:<br>Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory对象创建的SqlSession共享其缓存。<br>二级缓存的使用步骤：</p><ol><li><p>让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span></code></pre></li><li><p>让当前的映射文件支持二级缓存（在IUserDao.xml中配置）</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--开启user支持二级缓存--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span><span class="token punctuation">/></span></span></code></pre></li><li><p>让当前的操作支持二级缓存（在select标签中配置）</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 根据id查询用户 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>findById<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>INT<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span> <span class="token attr-name">useCache</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from user where id = #{uid}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre></li></ol></li></ul></li></ul><h4 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h4><pre><code>* 一对一、多对一  ```java  /**  * 查询所有账户，并且获取每个账户所属的用户信息  * @return  */      @Select(&quot;select * from account&quot;)      @Results(id=&quot;accountMap&quot;,value = {          @Result(id=true,column = &quot;id&quot;,property = &quot;id&quot;),          @Result(column = &quot;uid&quot;,property = &quot;uid&quot;),          @Result(column = &quot;money&quot;,property = &quot;money&quot;),          @Result(property = &quot;user&quot;,column = &quot;uid&quot;, one=@One(select=&quot;com.itheima.dao.IUserDao.findById&quot;,fetchType= FetchType.EAGER))      })  List&lt;Account&gt; findAll();  /**  * 根据用户id查询账户信息  * @param userId  * @return  */  @Select(&quot;select * from account where uid = #{userId}&quot;)  List&lt;Account&gt; findAccountByUid(Integer userId);  ```* 一对多  ```java  /**  * 查询所有用户  * @return  */  @Select(&quot;select * from user&quot;)      @Results(id=&quot;userMap&quot;,value={          @Result(id=true,column = &quot;id&quot;,property = &quot;userId&quot;),          @Result(column = &quot;username&quot;,property = &quot;userName&quot;),          @Result(column = &quot;address&quot;,property = &quot;userAddress&quot;),          @Result(column = &quot;sex&quot;,property = &quot;userSex&quot;),          @Result(column = &quot;birthday&quot;,property = &quot;userBirthday&quot;),          @Result(property = &quot;accounts&quot;,column = &quot;id&quot;,              many = @Many(select = &quot;com.itheima.dao.IAccountDao.findAccountByUid&quot;,                  fetchType = FetchType.LAZY))      })  List&lt;User&gt; findAll();  /**  * 根据id查询用户  * @param userId  * @return  */  @Select(&quot;select * from user  where id=#{id} &quot;)  @ResultMap(&quot;userMap&quot;)  User findById(Integer userId);   /**   * 根据用户名称模糊查询   * @param username   * @return   */   @Select(&quot;select * from user where username like #{username} &quot;)   @ResultMap(&quot;userMap&quot;)   List&lt;User&gt; findUserByName(String username);  ```* 缓存配置  ```java  @CacheNamespace(blocking = true)  ```</code></pre><script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({ "model": { jsonPath:"https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json","scale": 1 }, "display": { "position": "right","width": 100, "height": 200,"hOffset": 0, "vOffset": -20 }, "mobile": { "show": true, "scale": 0.5 },"react": { "opacityDefault": 0.7, "opacityOnHover": 0.2 } });</script>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> MyBatis </tag>
            
            <tag> ORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring入门学习</title>
      <link href="/2020/01/18/spring/"/>
      <url>/2020/01/18/spring/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Spring概述"><a href="#1-Spring概述" class="headerlink" title="1.Spring概述"></a>1.Spring概述</h3><blockquote><p>IoC 反转控制 AOP面向切片编程为内核</p></blockquote><ul><li>Spring优势：方便解耦，简化开发，AOP变成的支持，声明式事务的支持，方便程序的测试，方便继承各种优秀的框架，降低java EE API的使用难度，java源码经典学习范例</li><li>Spring体系结构</li></ul><img src="/2020/01/18/spring/Spring%E8%BF%90%E8%A1%8C%E6%97%B6%E7%BB%93%E6%9E%84.png" class="" title="Spring运行时结构"><h3 id="2-IoC的概念"><a href="#2-IoC的概念" class="headerlink" title="2. IoC的概念"></a>2. IoC的概念</h3><ul><li><p>jdbcDemo1 debug小记</p><p>更换版本5.1.6-&gt;5.1.46</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.46<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li></ul><p>程序的耦合和解耦</p><ul><li>开发中应注意编译期不依赖，运行时才依赖</li><li>解耦思路<br>使用反射来创建对象，避免使用new关键字<br>通过读取配置文件来获取要创建的对象全限定类名</li></ul><p>工厂模式解耦</p><ul><li><p>创建Bean对象的工厂，Bean指可重用的组件</p><pre class=" language-java"><code class="language-java">IAccountService as <span class="token operator">=</span> <span class="token punctuation">(</span>IAccountService<span class="token punctuation">)</span> BeanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"accountService"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h3 id="3-使用Spring的IoC解决程序的耦合"><a href="#3-使用Spring的IoC解决程序的耦合" class="headerlink" title="3.使用Spring的IoC解决程序的耦合"></a>3.使用Spring的IoC解决程序的耦合</h3><h4 id="IoC创建对象的时刻"><a href="#IoC创建对象的时刻" class="headerlink" title="IoC创建对象的时刻"></a>IoC创建对象的时刻</h4><ul><li><p>ApplicationContext: 单例对象适用（实际多采用此接口      </p><p>它在构建核心容器时，创建对象采取的策略是采用立即加载的方式。也就是说，只要一读取完配置文件马上就创建配置文件中配置的对象。</p></li></ul><h4 id="BeanFactory创建对象的时刻"><a href="#BeanFactory创建对象的时刻" class="headerlink" title="BeanFactory创建对象的时刻"></a>BeanFactory创建对象的时刻</h4><ul><li><p>BeanFactory: 多例对象使用</p><p>它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象</p></li></ul><h4 id="Spring对Bean的管理细节"><a href="#Spring对Bean的管理细节" class="headerlink" title="Spring对Bean的管理细节"></a>Spring对Bean的管理细节</h4><ul><li><p>创建Bean的三种方式</p><ul><li><p>第一种方式：使用默认构造函数构建</p><p>在spring配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建</p></li><li><p>第二种方式： 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>instanceFactory<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima.factory.InstanceFactory<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">factory-bean</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>instanceFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getAccountService<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre></li><li><p>第三种方式：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器)</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>accountService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima.factory.StaticFactory<span class="token punctuation">"</span></span> <span class="token attr-name">factory-method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getAccountService<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre></li></ul></li><li><p>bean标签的scope属性：   </p><p>作用：用于指定bean的作用范围    </p><p>取值： 常用的就是单例的和多例的        </p><ul><li><p>singleton：单例的（默认值）</p><p>一个应用只有一个对象的实例。它的作用范围就是整个引用。 </p><p>生命周期： </p><ol><li>对象出生：当应用加载，创建容器时，对象就被创建了。 </li><li>对象活着：只要容器在，对象一直活着。</li><li>对象死亡：当应用卸载，销毁容器时，对象就被销毁了。</li></ol><p>单例对象的生命周期与容器相同</p></li><li><p>prototype：多例的</p><p>每次访问对象时，都会重新创建对象实例。</p><p> 生命周期：</p><ol><li>对象出生：当使用对象时，创建新的对象实例。 </li><li>对象活着：只要对象在使用中，就一直活着。 </li><li>对象死亡：当对象长时间不用时，被 java 的垃圾回收器回收了。</li></ol></li><li><p>request：作用于web应用的请求范围，同一次请求创建一个实例</p></li><li><p>session：作用于web应用的会话范围，同一个session创建一个实例</p></li><li><p>global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session</p></li><li><p>init-method：指定类中的初始化方法名称。 destroy-method：指定类中销毁方法名称。</p></li></ul></li></ul><h3 id="4-依赖注入（Dependency-Injection"><a href="#4-依赖注入（Dependency-Injection" class="headerlink" title="4.依赖注入（Dependency Injection)"></a>4.依赖注入（Dependency Injection)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li><p>依赖注入：Dependency Injection。</p><p>它是 spring 框架核心 ioc 的具体实现，依赖关系的维护就称之为依赖注入。 </p><p>我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况。 ioc 解耦只是降低他们的依赖关系，但不会消除。例如：我们的业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p></li></ul><h4 id="三类能注入的数据"><a href="#三类能注入的数据" class="headerlink" title="三类能注入的数据"></a>三类能注入的数据</h4><ul><li>基本类型和String</li><li>其他bean类型（在配置文件中或者注解配置过的bean）</li><li>复杂类型/集合类型</li></ul><h4 id="三种注入方式"><a href="#三种注入方式" class="headerlink" title="三种注入方式"></a>三种注入方式</h4><ul><li><p>第一种：使用构造函数提供</p><p>使用的标签:constructor-arg    </p><p>标签出现的位置：bean标签的内部    </p><p>标签中的属性：     </p><ol><li>type：用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型</li><li>index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值。索引的位置是从0开始</li><li>name：用于指定给构造函数中指定名称的参数赋值（常用</li><li>value：用于提供基本类型和String类型的数据</li><li>ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</li><li>优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功</li><li>弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供</li></ol></li><li><p>第二种：使用set方法提供（更常用的方式</p><p>涉及的标签：property </p><p>出现的位置：bean标签的内部</p><p>标签的属性</p><ol><li>name：用于指定注入时所调用的set方法名称</li><li>value：用于提供基本类型和String类型的数据</li><li>ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象</li><li>优势：创建对象时没有明确的限制，可以直接使用默认构造函数    </li><li>弊端：如果有某个成员必须有值，则获取对象是有可能set方法没有执行。</li></ol></li><li><p>第三种：使用注解提供</p></li></ul><h3 id="5-Spring基于注解的IOC以及IOC的案例"><a href="#5-Spring基于注解的IOC以及IOC的案例" class="headerlink" title="5.Spring基于注解的IOC以及IOC的案例"></a>5.Spring基于注解的IOC以及IOC的案例</h3><h4 id="Spring中IOC的常用注解"><a href="#Spring中IOC的常用注解" class="headerlink" title="Spring中IOC的常用注解"></a>Spring中IOC的常用注解</h4><ul><li><p>用于创建对象的</p><p>作用与在XML配置文件中<bean>标签实现的功能相同</p><p>@Component 用于把当前类对象存入Spring容器中</p><p>属性：</p><ul><li>value：用于指定bean的id，默认值为当前类名，且首字母小写</li></ul><p>以下三个注解他们的作用和属性与Component相同，spring框架提供了明确的三层使用的注解，使三层对象更加清晰</p><ul><li>Controller：一般用在表现层</li><li>Service：一般用在业务层</li><li>Repository：一般用在持久层</li></ul></li><li><p>用于注入数据的</p><p>作用与在xml配置文件中的bean标签中<property>标签实现的功能相同</p><ul><li><p>@Autowired: </p><p>作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功；如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错；</p><p>如果Ioc容器中有多个类型匹配时：会出现报错</p><p>出现位置：可以是变量上，也可以是方法上</p><p>细节：在使用注解注入时，set方法就不是必须的了</p></li><li><p>@Qualifier</p><p>作用：在按照类中注入的基础之上再按照名称注入，它在给类成员注入时不能单独使用，而是与Autowired搭配使用，但是在给方法参数注入时可以</p><p>属性value：用于指定注入bean的id</p></li><li><p>@Resource</p><p>作用：直接按照bean的id注入。它可以独立使用</p><p>属性：</p><p>name：用于指定bean的id。</p></li></ul><p>以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。</p><p>另外，集合类型的注入只能通过XML来实现。</p><ul><li><p>Value</p><p>作用：用于注入基本类型和String类型的数据</p><p>属性value：用于指定数据的值。它可以使用spring中SpEL(也就是spring的el表达式）</p><p>SpEL的写法：${表达式}</p><p>@Value的值有两类：<br>① ${ property : default_value }<br>② #{ obj.property? :default_value }<br>第一个注入的是外部配置文件对应的property，第二个则是SpEL表达式对应的内容。 default_value即前面的值为空时的默认值。注意二者的不同，#{}里面那个obj代表对象。</p></li></ul></li><li><p>用于改变作用范围的</p><p>作用与在xml配置文件中的bean标签中<scope>标签实现的功能相同</p><ul><li><p>@Scope</p><p>作用：用于指定bean的作用范围</p><p>属性value：指定范围的取值。常用取值：singleton prototype</p></li></ul></li><li><p>与生命周期相关</p><p>作用与在xml配置文件中的bean标签中<init-method>和<destroy-method>标签实现的功能相同</p><ul><li><p>@PreDestroy</p><p>作用：用于指定销毁方法</p></li><li><p>@PostConstruct</p><p>作用：用于指定初始化方法</p></li></ul></li><li><p>案例使用xml方式与注解方式实现单表的CRUD操作（持久层技术选择：dubtils</p></li><li><p>改造基于注解的IOC案例，使用纯注解的方式实现即新注解使用</p></li></ul><h4 id="spring中的新注解"><a href="#spring中的新注解" class="headerlink" title="spring中的新注解"></a>spring中的新注解</h4><ul><li><p>Configuration</p><p>作用：指定当前类是一个配置类</p><p>细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。</p></li><li><p>ComponentScan</p><p>作用：用于通过注解指定spring在创建容器时要扫描的包</p><p>属性value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包。</p><p>使用此注解就等同于在xml中配置了:</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre></li><li><p>Bean</p><p>作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中</p><p>属性name：用于指定bean的id。当不写时，默认值是当前方法的名称</p><p>细节：当我们使用注解配置方法时，如果方法有参数，spring框架会</p><p>去容器中查找有没有可用的bean对象。</p><p>查找的方式和Autowired注解的作用是一样的</p></li><li><p>PropertySource</p><p>作用：用于指定properties文件的位置</p><p>属性value：指定文件的名称和路径。</p><p>关键字：classpath，表示类路径下</p></li><li><p>给容器中注册组件</p><ol><li><p>包扫描+组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的类]</p></li><li><p>@Bean[导入的第三方包里面的组件]</p></li><li><p>@Import[快速给容器中导入一个组件]</p><ul><li>@Import(要导入到容器中的组件)；容器中就会自动注册这个组件，id默认是全类名</li><li>ImportSelector:返回需要导入的组件的全类名数组</li><li>ImportBeanDefinitionRegistrar:手动注册bean到容器中</li></ul></li><li><p>使用Spring提供的 FactoryBean（工厂Bean</p><ul><li><p>默认获取到的是工厂bean调用getObject创建的对象</p></li><li><p>要获取工厂Bean本身，我们需要给id前面加一个&amp;</p><p>​    &amp;colorFactoryBean</p></li></ul></li></ol></li><li><p>bean的生命周期</p><ol><li><p>bean创建—初始化—-销毁的过程</p></li><li><p>容器管理bean的生命周期</p><p>我们可以自定义初始化和销毁方法，容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法</p><ol><li><p>构造（对象创建）</p><p>单实例：在容器启动的时候创建对象</p><p>多实例：在每次获取的时候创建对象</p></li><li><p>销毁：</p><p>单实例：容器关闭的时候</p><p>多实例：容器不会管理这个bean；容器不会调用销毁方法；</p></li><li><p>指定初始化和销毁方法</p><p>通过@Bean指定init-method和destroy-method</p></li><li><p>通过让Bean实现</p><p>InitializingBean（定义初始化逻辑），DisposableBean（定义销毁逻辑）</p></li><li><p>可以使用JSR250</p><p>@PostConstruct：在bean创建完成并且属性赋值完成，来执行初始化方法</p><p>@PreDestroy：在容器销毁bean之前通知我们进行清理工作</p></li></ol></li><li><p>BeanPostProcessor原理</p><p>遍历得到容器中所有的BeanPostProcessor；挨个执行beforeInitialization，一但返回null，跳出for循环，不会执行后面的BeanPostProcessor.postProcessorsBeforeInitialization</p></li><li><p>BeanPostProcessor【interface】：bean的后置处理器；</p><ul><li>在bean初始化前后进行一些处理工作；</li><li>postProcessBeforeInitialization:在初始化之前工作</li><li>postProcessAfterInitialization:在初始化之后工作</li></ul></li><li><p>Spring底层对 BeanPostProcessor 的使用；</p><p> bean赋值，注入其他组件，@Autowired，生命周期注解功能，@Async,xxx BeanPostProcessor;</p></li></ol></li></ul><h3 id="6-AOP"><a href="#6-AOP" class="headerlink" title="6.AOP"></a>6.AOP</h3><h4 id="Spring和Junit整合"><a href="#Spring和Junit整合" class="headerlink" title="Spring和Junit整合"></a>Spring和Junit整合</h4><ul><li><p>Junit单元测试中，没有main方法也能执行，junit集成了一个main方法，该方法就会查找当前测试类中的@Test注解并执行</p></li><li><p>Junit不检测是否使用Spring框架，因此不会读取配置文件/类、创建Spring核心容器</p></li><li><p>Spring整合junit的配置</p><ol><li>导入spring整合junit的jar(坐标)</li><li>使用Junit提供的一个注解把原有的main方法替换了，替换成spring提供的@Runwith</li><li>告知spring的运行器，spring和ioc创建是基于xml还是注解的，并且说明位置@ContextConfiguration<ul><li>locations：指定xml文件的位置，加上classpath关键字，表示在类路径下</li><li>classes：指定注解类所在地位置</li></ul></li></ol></li></ul><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><ul><li><p>特点：字节码随用随创建，随用随加载</p></li><li><p>作用：不修改源码的基础上对方法增强</p></li><li><p>分类：</p><ul><li><p>基于子类的动态代理</p><ul><li><p>涉及的类：Enhancer</p></li><li><p>提供者：第三方cglib库</p></li><li><p>如何创建代理对象：使用Enhancer类中的create方法</p></li><li><p>创建代理对象的要求：被代理类不能是最终类</p></li><li><p>create方法的参数：</p><ol><li><p>Class：字节码</p><p>它是用于指定被代理对象的字节码。</p></li><li><p>Callback：用于提供增强的代码</p><p>它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。</p><p>我们一般写的都是该接口的子接口实现类：MethodInterceptor </p><p>此接口的实现类都是谁用谁写</p></li></ol></li></ul></li><li><p>基于接口的动态代理：</p><ul><li><p>涉及的类：</p></li><li><p>如何创建代理对象：使用Proxy类中的newProxyInstance方法</p></li><li><p>创建代理对象的要求：被代理类最少实现一个接口，如果没有则不能使用  </p></li><li><p>newProxyInstance方法的参数：</p><ol><li><p>ClassLoader：类加载器</p><p>它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。</p></li><li><p>Class[]：字节码数组</p><p>它是用于让代理对象和被代理对象有相同方法。固定写法。*      </p></li><li><p>InvocationHandler：用于提供增强的代码</p><p>它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。此接口的实现类都是谁用谁写。</p></li></ol></li></ul></li></ul></li></ul><h4 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h4><ul><li><p>Joinpoint(连接点): 所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的连接点。 </p></li><li><p>Pointcut(切入点): 所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。</p></li><li><p>Advice(通知/增强): 所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。 </p></li><li><p>Introduction(引介): 引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。 </p></li><li><p>Target(目标对象): 代理的目标对象。 </p></li><li><p>Weaving(织入): 是指把增强应用到目标对象来创建新的代理对象的过程。 spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。 </p></li><li><p>Proxy（代理）: 一个类被 AOP 织入增强后，就产生一个结果代理类。 </p></li><li><p>Aspect(切面): 是切入点和通知（引介）的结合。</p></li></ul><h4 id="Spring中基于xml和注解的AOP配置"><a href="#Spring中基于xml和注解的AOP配置" class="headerlink" title="Spring中基于xml和注解的AOP配置"></a>Spring中基于xml和注解的AOP配置</h4><ul><li><p>spring中基于XML的AOP配置步骤</p><ol><li><p>把通知Bean也交给spring来管理</p></li><li><p>使用aop:config标签表明开始AOP的配置</p></li><li><p>使用aop:aspect标签表明配置切面           </p><p>id属性：是给切面提供一个唯一标识</p><p>ref属性：是指定通知类bean的Id。    </p></li><li><p>在aop:aspect标签的内部使用对应标签来配置通知的类型</p><p>我们现在示例是让printLog方法在切入点方法执行之前之前：所以是前置通知 </p><p>aop:before：表示配置前置通知</p><ul><li>method属性：用于指定Logger类中哪个方法是前置通知                </li><li>pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强        </li></ul><p>切入点表达式的写法：</p><ul><li><p>关键字：execution(表达式) </p></li><li><p>表达式：</p><p>访问修饰符  返回值  包名.包名.包名…类名.方法名(参数列表)            标准的表达式写法：                </p><p>​    public void com.itheima.service.impl.AccountServiceImpl.saveAccount()            访问修饰符可以省略</p><p>​    void com.itheima.service.impl.AccountServiceImpl.saveAccount()            返回值可以使用通配符，表示任意返回值</p><p>​    * com.itheima.service.impl.AccountServiceImpl.saveAccount()            包名可以使用通配符，表示任意包。但是有几级包，就需要写几个</p><p>​    * *.*.*.*.AccountServiceImpl.saveAccount())</p><p>包名可以使用..表示当前包及其子包 </p><p>​    * *..AccountServiceImpl.saveAccount() </p><p>类名和方法名都可以使用*来实现通配</p><p>​    *..*.*() </p><p>参数列表：可以直接写数据类型：</p><ol><li>基本类型直接写名称           int</li><li>引用类型写包名.类名的方式   java.lang.String </li></ol><p>可以使用通配符表示任意类型，但是必须有参数</p><p>可以使用..表示有无参数均可，有参数可以是任意类型</p><p>全通配写法：</p><p>​    *..*.*(..)            </p><p>实际开发中切入点表达式的通常写法：</p><p>切到业务层实现类下的所有方法</p><p>​    * com.itheima.service.impl.*.*(..)</p></li></ul></li></ol></li><li><p>@Pointcut </p><p>作用： 指定切入点表达式 </p><p>属性：</p><p>​    value：指定表达式的内容 </p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* com.itheima.service.impl.*.*(..))"</span><span class="token punctuation">)</span> <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">pt1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>引用方式：<span class="token comment" spellcheck="true">/*** 环绕通知* @param pjp* @return*/</span><span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"pt1()"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//注意：千万别忘了写括号</span><span class="token keyword">public</span> Object <span class="token function">transactionAround</span><span class="token punctuation">(</span>ProceedingJoinPoint pjp<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//定义返回值</span>    Object rtValue <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取方法执行所需的参数</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span> pjp<span class="token punctuation">.</span><span class="token function">getArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//前置通知：开启事务</span>        <span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//执行方法</span>        rtValue <span class="token operator">=</span> pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//后置通知：提交事务</span>        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Throwable e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//异常通知：回滚事务</span>        <span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//最终通知：释放资源</span>        <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> rtValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="7-Spring中JDBCTemplate"><a href="#7-Spring中JDBCTemplate" class="headerlink" title="7.Spring中JDBCTemplate"></a>7.Spring中JDBCTemplate</h3><ul><li><p>JdbcTemplate的作用：用于和数据库交互，实现CRUD</p></li><li><p>如何创建</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置一个数据库的操作模板：JdbcTemplate --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbcTemplate<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.springframework.jdbc.core.JdbcTemplate<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dataSource<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span></code></pre></li><li><p>常用方法</p><ul><li>第一种方式：在 dao 中定义 JdbcTemplate</li><li>第二种方式：让 dao 继承 JdbcDaoSupport</li><li>区别：<ul><li>第一种在 Dao 类中定义 JdbcTemplate 的方式，适用于所有配置方式（xml 和注解都可以）。 </li><li>第二种让 Dao 继承 JdbcDaoSupport 的方式，只能用于基于 XML 的方式，注解用不了。</li></ul></li></ul></li></ul><h3 id="8-Spring中事务控制"><a href="#8-Spring中事务控制" class="headerlink" title="8.Spring中事务控制"></a>8.Spring中事务控制</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul><li><p>PlatformTransactionManager接口提供事务操作的方法，包含有3个具体的操作</p><ul><li><p>获取事务状态信息</p><p>TransactionStatus getTransaction(TranscationDefinition definition)</p></li><li><p>提交事务</p><p>void commit(TransactionStatus status)</p></li><li><p>回滚事务</p><p>void rollback(TransactionStatus status)</p></li></ul></li><li><p>真正管理事务的对象 org.springframework.jdbc.datasource.DataSourceTransactionManager 使用 Spring JDBC 或 iBatis 进行持久化数据时使用 org.springframework.orm.hibernate5.HibernateTransactionManager 使用 Hibernate 版本进行持久化数据时使用</p></li><li><p>TransactionDefinition</p><ul><li><p>获取事务对象名称</p><p>String getName()</p></li><li><p>获取事务隔离级别</p><p>int getIsolationLevel()</p></li><li><p>获取事务传播行为</p><p>int getPropagationBehavior</p><p>事务的传播行为</p><ul><li>REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</li><li>SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</li><li>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 </li><li>REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。 </li><li>NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li><li>NEVER:以非事务方式运行，如果当前存在事务，抛出异常</li><li>NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED 类似的操作。</li></ul></li><li><p>获取事务超时时间</p><p>int getTimeout()</p></li><li><p>获取事务是否只读</p><p>boolean isReadOnly()</p></li></ul></li><li><p>TransactionStatus接口描述了某个时间点上事务对象的状态信息，包含六个具体的操作</p><ul><li><p>刷新事务</p><p>void flush()</p></li><li><p>获取是否存在储存点</p><p>boolean isCompleted()</p></li><li><p>获取事务是否完成</p><p>boolean isNewTransaction()</p></li><li><p>获取事务是否回滚</p><p>boolean isRollbackOnly()</p><p>设置事务回滚</p><p>void setRollbackOnly()</p></li></ul></li></ul><h4 id="基于XML"><a href="#基于XML" class="headerlink" title="基于XML"></a>基于XML</h4><ol><li><p>配置事务管理器</p></li><li><p>配置事务的通知</p><p>此时我们需要导入事务的约束tx名称空间和约束，同时也需要aop的        使用tx:advice标签配置事务通知</p><p>属性：</p><ul><li>id：给事务通知起一个唯一标识</li><li>transaction-manager：给事务通知提供一个事务管理器引用</li></ul></li><li><p>配置AOP中的通用切入点表达式</p></li><li><p>建立事务通知和切入点表达式的对应关系</p></li><li><p>配置事务的属性</p><p>在事务的通知tx:advice标签的内部</p><ul><li>isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。</li><li>propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。</li><li>read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。</li><li>timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。</li><li>rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。</li><li>no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。</li></ul></li></ol><h4 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h4><ol><li>配置事务管理器</li><li>开启spring对注解事务的支持</li><li>在需要事务支持的地方使用@Transactional注解</li></ol><h3 id="9-Spring5新特性"><a href="#9-Spring5新特性" class="headerlink" title="9.Spring5新特性"></a>9.Spring5新特性</h3><p>待完善</p><script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({ "model": { jsonPath:"https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json","scale": 1 }, "display": { "position": "right","width": 100, "height": 200,"hOffset": 0, "vOffset": -20 }, "mobile": { "show": true, "scale": 0.5 },"react": { "opacityDefault": 0.7, "opacityOnHover": 0.2 } });</script>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> JavaEE </tag>
            
            <tag> 开源框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL优化</title>
      <link href="/2020/01/14/mysql-you-hua/"/>
      <url>/2020/01/14/mysql-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h2><p>笔记主要来自<a href="https://www.cnblogs.com/lyjun/p/11371851.html,原课程来自Bilibili" target="_blank" rel="noopener">https://www.cnblogs.com/lyjun/p/11371851.html,原课程来自Bilibili</a></p><p>完整的mysql优化需要很深的功底，大公司甚至有专门的DBA写上述</p><ul><li>mysql内核</li><li>sql优化工程师</li><li>mysql服务器的优化</li><li>各种参数常量设定</li><li>查询语句优化</li><li>主从复制</li><li>软硬件升级</li><li>容灾备份</li><li>sql编程</li></ul><h3 id="mysqL-Linux版的安装"><a href="#mysqL-Linux版的安装" class="headerlink" title="mysqL-Linux版的安装"></a>mysqL-Linux版的安装</h3><ul><li><p>mysql5.5</p><ul><li>检查当前系统是否安装过mysql：<ul><li>查询命令：rpm -qa|grep -i mysql</li><li>删除命令：rpm -e RPM软件包名称<ul><li>删除自带的mysql：yum -y remove mysql-libs-5.1.73-7.el6.x86_64</li></ul></li></ul></li></ul></li><li><p>安装mysql服务端（注意提示）：</p><ul><li>rpm -ivh MySQL-server-5.5.48-1.linux2.6.i386.rpm<ul><li>如果报错libc.so.6：<a href="https://blog.csdn.net/xiyuliuyang/article/details/90750049" target="_blank" rel="noopener">https://blog.csdn.net/xiyuliuyang/article/details/90750049</a></li><li>如果警告key ID 5072e1f5: NOKEY：<a href="https://blog.csdn.net/Aaron960214/article/details/78451321" target="_blank" rel="noopener">https://blog.csdn.net/Aaron960214/article/details/78451321</a></li></ul></li></ul></li><li><p>安装mysql客户端</p><ul><li>rpm -ivh MySQL-client-5.5.48-1.linux2.6.i386.rpm</li></ul></li><li><p>查看MySQL安装时创建的mysql用户和mysql组</p><ul><li>cat /etc/passwd|grep mysql<ul><li>cat /etc/group|grep mysql</li><li>mysqladmin –version</li></ul></li></ul></li><li><p>mysql服务的启+停</p><ul><li><p>service mysql start</p></li><li><p>service mysql start</p><ul><li><p>如果报错ERROR! The server quit without updating PID file (/var/lib/mysql/localhost.localdomain.pid).</p></li><li><p>解决办法：<a href="https://www.cnblogs.com/bingco/p/8068243.html" target="_blank" rel="noopener">https://www.cnblogs.com/bingco/p/8068243.html</a></p><pre><code>mysql_install_db --datadir=/var/lib/mysqlchown mysql:mysql /var/lib/mysql -R</code></pre></li></ul></li><li><p>查看mysql的进程：ps -ef|grep mysql</p></li></ul></li><li><p>mysql服务启动后，开始连接</p><ul><li>首次连接成功：mysql（不需要输入密码）<ul><li>给root用户设置密码：/usr/bin/mysqladmin -u root password 123456</li></ul></li></ul></li><li><p>自启动mysql服务</p><ul><li>设置开机自启动mysql：chkconfig mysql on<ul><li>查看mysql的等级：chkconfig –list | grep mysql</li><li>查看不同等级代表的含义：cat /etc/inittab</li><li>查看开机自动服务有哪些：ntsysv</li></ul></li></ul></li><li><p>修改配置文件位置</p><ul><li><p>版本5.5：cp /usr/share/mysql/my-huge.cnf/etc/my.cnf</p><ul><li>版本5.6：cp /usr/share/mysql/<strong>my-default.cnf</strong> /etc/my.cnf</li></ul></li></ul></li><li><p>修改字符集和数据存储路径</p><ul><li>查看字符集<ul><li>show variables like ‘character%’;</li><li>show variables like ‘%char%’;</li><li>由于默认的是客户端和服务器都使用的latin1，所以都是乱码</li><li>修改</li><li>重启mysql</li><li>重新连接后，原来的库由于建立于修改字符集之前，所以中文依然是乱码，而新建表中文不是乱码</li></ul></li></ul></li></ul><ul><li>MySQL的安装位置<ul><li>/var/lib/mysql：mysql数据库文件的存放路径</li><li>/usr/share/mysql：配置文件目录</li><li>/usr/bin：相关命令目录</li><li>/etc/init.d/mysql：启停相关脚本</li></ul></li></ul><h3 id="mysql配置文件"><a href="#mysql配置文件" class="headerlink" title="mysql配置文件"></a>mysql配置文件</h3><ul><li>主要配置文件<ul><li>二进制日志log-bin<ul><li>主从复制</li></ul></li><li>错误日志log-error<ul><li>默认是关闭的，记录严重的警告和错误信息，每次启动和关闭的详细信息等。</li></ul></li><li>查询日志log<ul><li>默认关闭，记录查询的sql语句，如果开启会降低mysql的整体性能，因为记录日志也是需要消耗系统资源的。</li></ul></li><li>数据文件<ul><li>两系统<ul><li>windows：D:\devSoft\MySQLServer5.5\data目录下可以挑选很多库</li><li>linux<ul><li>看看当前系统中的全部库后再进去</li><li>默认路径：/var/lib/mysql</li></ul></li></ul></li><li>frm文件：存放表结构</li><li>myd文件：存放表数据</li><li>myi文件：存放表索引</li></ul></li><li>如何配置<ul><li>windows：my.ini文件</li><li>Linux：/etc/my.cnf文件</li></ul></li></ul></li></ul><h2 id="mysql逻辑架构介绍"><a href="#mysql逻辑架构介绍" class="headerlink" title="mysql逻辑架构介绍"></a>mysql逻辑架构介绍</h2><ul><li>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。</strong>这种架构可以根据业务的需求和时机需要选择合适的存储引擎。</li></ul><img src="/2020/01/14/mysql-you-hua/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png" class="" title="MySQL逻辑架构"><ul><li><p>从上到下，连接层，服务层，引擎层，存储层</p><ul><li><p>连接层</p><p>最上层是一些客户端和连接服务，包含本地socket通信和大多数基于客户端/服务端工具实显得类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p></li><li><p>服务层</p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否能够利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p></li><li><p>引擎层</p><p>存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</p></li><li><p>存储层</p><p>数据存储层，主要是将数据存储在运行于罗设备的文件系统之上，并完成于存储引擎的交互</p></li></ul></li><li><p>MySQL存储引擎</p><ul><li><p>查看命令</p><ul><li>如何用命令查看<ul><li>看你的mysql现在已提供什么存储引擎：show engines;</li><li>看你的mysql当前默认的存储引擎：show variables like ‘%storage_engine%’;</li></ul></li></ul></li><li><p>MyISAM和InnoDB</p><table><thead><tr><th align="center">对比项</th><th align="center">MyISAM</th><th align="center">InnoDB</th></tr></thead><tbody><tr><td align="center">主外键</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">事务</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">行表锁</td><td align="center">表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td align="center">行锁，操作时只锁某一行，不对其他行有影响，适合高并发的操作</td></tr><tr><td align="center">缓存</td><td align="center">只缓存索引</td><td align="center">不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td align="center">表空间</td><td align="center">小</td><td align="center">大</td></tr><tr><td align="center">关注点</td><td align="center">性能</td><td align="center">事务</td></tr><tr><td align="center">默认安装</td><td align="center">是</td><td align="center">是</td></tr></tbody></table></li></ul></li><li><p>索引优化分析</p><ul><li>性能下降SQL慢<ul><li>执行时间长，等待时间长<ul><li>查询语句写的烂</li><li>索引失效<ul><li>单值索引</li><li>复合索引</li></ul></li><li>关联查询太多join（设计缺陷或不得已的需求）</li><li>服务器调优及各个参数设置（缓冲、线程数等）</li></ul></li></ul></li></ul></li><li><p>常见通用的Join查询</p><ul><li><p>SQL执行顺序</p><ul><li><p>手写</p><pre class=" language-mysql"><code class="language-mysql">select distinct <select_list>from <left_table> <join_type>join <right_table> on <join_condition>where <where_condition>group by <group_by_list>having <having_condition>order by <order_by_condition>limit <limit_number></code></pre></li><li><p>机读</p><pre class=" language-mysql"><code class="language-mysql">from <left_table> on <join_condition><join_type> join <right_table>where <where_condition>group by <group_by_list>having <having_condition>selectdistinct <select_list>order by <order_by_condition>limit <limit_number></code></pre></li><li><p>总结</p><img src="/2020/01/14/mysql-you-hua/SQL%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F.png" class="" title="SQL解析顺序"></li></ul></li></ul></li><li><p>7种Join</p></li></ul><img src="/2020/01/14/mysql-you-hua/SQL-Join-1.png" class="" title="SQL-Join-1"><img src="/2020/01/14/mysql-you-hua/SQL-Join-2.png" class="" title="SQL-Join-2"><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li><p>定义</p><ul><li><p>MySQL官方定义：索引（Index）是帮助MySQL高效获取数据的数据结构。索引本质是字段与实际数据的映射</p></li><li><p>排好序的快速查找数据结构</p><img src="/2020/01/14/mysql-you-hua/B%E6%A0%91%E7%BB%93%E6%9E%84.png" class="" title="B树结构"></li><li><p>结论</p><p>数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引</p></li><li><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。</p></li><li><p><strong>我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树）结构组织的索引。</strong>其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认的都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈希索引（hash index）等。</p></li></ul></li><li><p>优势</p><ul><li>类似大学图书馆建书目索引，<strong>提高数据检索的效率</strong>，降低数据库的IO成本。</li><li>通过索引列对数据进行排序，<strong>降低数据排序的成本</strong>，降低了CPU的消耗。</li></ul></li><li><p>劣势</p><ul><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</li><li>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或者优化查询。</li></ul></li><li><p>MySQL索引分类</p><ul><li><p>单值索引：即一个索引只包含单个列，一个表可以有多个单列索引</p></li><li><p>唯一索引：索引列的值必须唯一，但允许有空值</p></li><li><p>复合索引：即一个索引包含多个列</p></li><li><p>基本语法</p><ul><li><p>创建：</p><pre class=" language-mysql"><code class="language-mysql">create [unique] index indexname on mytable(columnname(length));alter mytable add [unique] index [indexname] on (columnname(length))</code></pre><ul><li>如果是char，varchar类型，length可以小于字段实际长度；如果是blob和text类型，必须指定length。</li></ul></li><li><p>删除：drop index [indexname] on mytable;</p></li><li><p>查看：show index from table_name\G</p></li><li><p>使用alter命令</p><pre class=" language-mysql"><code class="language-mysql">#该语句添加一个主键，这一意味着索引值必须是唯一的，且不能为NULLalter table tbl_name add primary key(column_list)#这条语句创建索引的值必须是唯一的（除NULL外，NULL可能会出现多次alter table tbl_name add unique index_name(column_list)#添加普通索引，索引值可出现多次alter table tbl_name add index index_name(column_list)#该语句指定了索引为FULLTEXT，用于全文索引alter table tbl_name add fulltext_index index_name(column_list)</code></pre></li></ul></li></ul></li><li><p>mysql索引结构</p><ul><li><p>BTree索引</p><ul><li><p>索引原理</p><img src="/2020/01/14/mysql-you-hua/B-Tree%E7%B4%A2%E5%BC%95.png" class="" title="B-Tree索引"><ol><li>初始化介绍<br>一颗b树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），<br>如磁盘块1包含数据项17和35，包含指针P1、P2、P3，<br>P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。<br><strong>真实的数据存在于叶子节点</strong>即3、5、9、10、13、15、28、29、36、60、75、79、90、99。<br><strong>非叶子节点不存储真实的数据，只存储指引搜索方向的数据项</strong>，如17、35并不真实存在于数据表中。</li><li>查找过程<br>如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。</li><li>真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</li></ol></li></ul></li><li><p>Hash索引</p></li><li><p>full-text全文索引</p></li><li><p>R-Tree索引</p></li></ul></li><li><p>哪些情况需要创建索引</p><ul><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>频繁更新的字段不适合创建索引，因为每次更新不单单是更新了记录，还会更新索引，加重IO负担</li><li>where条件里用不到的字段不创建索引</li><li>单键/组合索引的选择问题，who？（在高并发下倾向创建组合索引）</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ul></li><li><p>哪些情况不需要创建索引</p><ul><li>表记录太少</li><li>经常增删改的表<ul><li>Why：提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</li></ul></li><li>数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li></ul></li><li><p>性能分析</p><ul><li><p>MySQL Query Optimizer</p><ol><li><p>mysql中有专门负责优化 select 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为窗户端请求的query提供它认为最优的执行计划（不一定是DBA认为最优的，这部分最耗费时间）</p></li><li><p>当客户端向mysql发送一条query，命令解析器模块完成请求分类，区别出是select并转发给 mysql query optimizer时，mysql query optimizer首先会对整条query进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对query中的查询条件进行简化和调整，如去掉一些无用或显而易见的条件、结构调整等。然后分析query中的hint信息（如果有），看显示hint信息是否可以完全确定该query的执行计划。如果没有hint或hint信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据query进行写相应的计算分析，然后再得出最后的执行计划。</p></li></ol></li><li><p>MySQL常见瓶颈</p><ul><li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li><li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li><li>服务器硬件的性能瓶颈：top，free，iostat和vmstat来查看系统的性能状态</li></ul></li><li><p>Explain</p><ul><li><p>查看执行计划</p><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</p></li><li><p>用途</p><ol><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的应用</li><li>每张表有多少行被优化器查询</li></ol></li><li><p>使用方式</p><ol><li>Explain+SQL语句</li><li>执行计划包含的信息</li></ol><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>extra</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li></ul><ul><li><p>各字段解释</p><ul><li><p>id</p><ul><li>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</li><li>三种情况：<ol><li>id相同，执行顺序由上至下</li><li>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li><li>id相同不同，同时存在</li></ol></li><li>衍生：DERIVED</li></ul></li><li><p>select_type：</p><p>查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询</p><ol><li>SIMPLE：简单的select查询，查询中不包含子查询或者UNION。</li><li>PRIMARY：查询中包含任何复杂的子部分，最外层查询则被标记为PRIMARY。</li><li>SUBQUERY：在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放在临时表里。</li><li>DERIVED：在FROM列表中包含的子查询被标记为DERIVED（衍生）。MySQL会递归执行这些子查询，把结果放在临时表里。</li><li>UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED。</li><li>UNION RESULT：从UNION表中获取结果的SELECT。</li></ol></li><li><p>table：显示这一行的数据是关于哪些表的。</p></li><li><p>type：</p><ol><li><p>访问类型排序</p><ul><li><p><strong>type显示的是访问类型</strong>，是较为重要的一个指标，结果值<strong>从最好到最坏依次是</strong>：</p><p><strong>system&gt;const&gt;eq_ref&gt;ref&gt;fulltext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;range&gt;index&gt;All</strong></p></li></ul></li><li><p>显示查询使用了何种类型，从最好到最差依此是：</p><p>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;All</p></li><li><p>system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计。</p></li><li><p>const：表示通过索引一次就找到了，const用于比较primary key或则unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量。</p></li><li><p>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</p></li><li><p>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。</p></li><li><p>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不会扫描全部索引。</p></li><li><p>index：Full Index Scan，index与All区别为index类型只遍历索引树。这通常比All快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）</p></li><li><p>all：Full Table Scan，将遍历全表以找到匹配的行。</p></li><li><p>一般来说，<strong>得保证查询至少达到range级别，最好能达到ref</strong>。</p></li></ol></li><li><p>possible_keys：显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出。<strong>但不一定被查询实际使用</strong>。</p></li><li><p>key：实际使用的索引。如果为NULL，则没有使用索引。<strong>查询中若使用了覆盖索引，则该索引仅出现在key列表中，不会出现在possible_keys列表中。</strong>（覆盖索引：查询的字段与建立的复合索引的个数一一吻合）</p></li><li><p>key_len：表示索引中使用的字节数（使用的最左前缀的长度），可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。key_len显示的值为索引字段的最大可能长度，<strong>并非实际使用长度</strong>，即key_len是根据表定义计算而得，不是通过表内检索出的。</p></li><li><p>ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。<strong>查询中与其它表关联的字段，外键关系建立索引</strong>。</p></li><li><p>rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。</p></li><li><p>Extra：包含不适合在其他列中显示但十分重要的额外信息。</p><ol><li><p><em>Using filesort</em>：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作成为“文件排序”。</p></li><li><p><em>Using temporary</em>：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</p></li><li><p><em>Using index</em>：表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。</p><p>覆盖索引： </p><p>理解方式1：SELECT的数据列只需要从索引中就能读取到，不需要读取数据行，MySQL可以利用索引返回SELECT列表中 的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖 </p><p>理解方式2：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此他不必读取整个行。 毕竟索引叶子节点存储了他们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了，一个索引 包含了（覆盖）满足查询结果的数据就叫做覆盖索引 注意： 如果要使用覆盖索引，一定要注意SELECT列表中只取出需要的列，不可SELECT *, 因为如果所有字段一起做索引会导致索引文件过大查询性能下降</p></li><li><p>Using where：表明使用了where过滤。</p></li><li><p>Using join buffer：使用了连接缓存。</p></li><li><p>impossible where：where子句的值总是false，不能用来获取任何元组。（查询语句中where的条件不可能被满足，恒为False）</p></li><li><p>select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p></li><li><p>distinct：优化distinct操作，在找到第一匹配的元组后即停止找相同值的动作。</p></li></ol></li></ul></li><li><p>Case：</p><img src="/2020/01/14/mysql-you-hua/MySQL%E7%B4%A2%E5%BC%95Case.png" class="" title="MySQL索引Case"><img src="/2020/01/14/mysql-you-hua/MySQL%E7%B4%A2%E5%BC%95Case%E8%A7%A3%E9%87%8A.png" class="" title="MySQL索引Case解释"></li></ul></li></ul></li></ul><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><ul><li><p>思路</p><ol><li>查询是否使用了索引，key是否为null</li><li>索引连接类型是否符合，type为range以上级别</li><li>查看extra字段是否出现using temporary和using filesort</li><li>检查索引的选择，顺序，长度等设计是否合理</li><li>寻找替代的索引、调整已有索引或新建索引</li></ol></li><li><p>索引分析</p><ul><li><p>单表</p><ul><li><p>建表SQL</p><pre class=" language-mysql"><code class="language-mysql">create table if not exists `article`(`id` int(10) unsigned not null primary key auto_increment,`author_id` int(10) unsigned not null,`category_id` int(10) unsigned not null,`views` int(10) unsigned not null,`comments` int(10) unsigned not null,`title` varbinary(255) not null,`content` text not null);insert into `article`(`author_id`,`category_id`,`views`,`comments`,`title`,`content`)values(1,1,1,1,'1','1'),(2,2,2,2,'2','2'),(1,1,3,3,'3','3');</code></pre></li><li><p>案例</p><pre class=" language-mysql"><code class="language-mysql">#查询查询 category_id 为 1 且 comments 大于 1 的情况下,views 最多的 article_idselect id,author_idfrom articlewhere category_id=1 AND comments>1order by views desclimit 1;</code></pre><img src="/2020/01/14/mysql-you-hua/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2explain%E7%BB%93%E6%9E%9C1.png" class="" title="单表查询explain结果1"><p>很显然,type 是 ALL,即最坏的情况。Extra 里还出现了 Using filesort,也是最坏的情况。优化是必须的</p><pre class=" language-mysql"><code class="language-mysql">create index idx_article_ccv on article(category_id,comments,views);</code></pre><img src="/2020/01/14/mysql-you-hua/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2explain%E7%BB%93%E6%9E%9C2.png" class="" title="单表查询explain结果2"><p>type 变成了 range,这是可以忍受的。但是 extra 里使用 Using filesort 仍是无法接受的。但是我们已经建立了索引,为啥没用呢?这是因为按照 BTree 索引的工作原理,先排序 category_id,如果遇到相同的 category_id 则再排序 comments,如果遇到相同的 comments 则再排序 views。当 comments 字段在联合索引里处于中间位置时,因comments &gt; 1 条件是一个范围值(所谓 range),MySQL 无法利用索引再对后面的 views 部分进行检索,即 range 类型查询字段后面的索引无效</p><pre class=" language-mysql"><code class="language-mysql"> drop index idx_article_ccv on article;create index idx_article_cv on article(category_id,views);</code></pre><img src="/2020/01/14/mysql-you-hua/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2explain%E7%BB%93%E6%9E%9C3.png" class="" title="单表查询explain结果3"><p>可以看到,type 变为了 ref,Extra 中的 Using filesort 也消失了,结果非常理想</p></li></ul></li><li><p>两表</p><ul><li><p>建表SQL</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE IF NOT EXISTS `class` (`id` int(10) unsigned NOT NULL AUTO_INCREMENT,`card` int(10) unsigned NOT NULL,PRIMARY KEY (`id`));CREATE TABLE IF NOT EXISTS `book` (`bookid` int(10) unsigned NOT NULL AUTO_INCREMENT,`card` int(10) unsigned NOT NULL,PRIMARY KEY (`bookid`));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `class`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));insert into `book`(card ) values (floor(1+(rand()*20)));</code></pre><pre class=" language-mysql"><code class="language-mysql">#explain分析explain select * from class left join bookon class.card=book.card;#添加索引优化1alter table `book` add index Y(`card`)#添加索引优化2alter table `class` add index Y(`card`)</code></pre><img src="/2020/01/14/mysql-you-hua/%E4%B8%A4%E8%A1%A8%E6%9F%A5%E8%AF%A2explain%E7%BB%93%E6%9E%9C1.png" class="" title="单表查询explain结果1"><p>索引优化1</p><img src="/2020/01/14/mysql-you-hua/%E4%B8%A4%E8%A1%A8%E6%9F%A5%E8%AF%A2explain%E7%BB%93%E6%9E%9C2.png" class="" title="单表查询explain结果3"><p>索引优化2</p><img src="/2020/01/14/mysql-you-hua/%E4%B8%A4%E8%A1%A8%E6%9F%A5%E8%AF%A2explain%E7%BB%93%E6%9E%9C3.png" class="" title="单表查询explain结果3"></li><li><p>结论</p><p>第一次优化的type变为了ref，rows优化也比较明显</p><p>左连接特性，left join 条件用于确定如何从右表搜索行，左边一定都有，所以右表是我们的关键点，一定需要建立索引</p><p>而右连接特性，right join 条件用于确定如何从左表搜索行，右边一定都有，所以左表是我们的关键点，一定需要建立索引</p></li></ul></li><li><p>三表</p><ul><li><p>建表</p><pre class=" language-mysql"><code class="language-mysql">create table if not exists `phone`(    `phoneid` int(10) unsigned not null auto_increment,    `card` int(10) unsigned not null,    primary key (`phoneid`));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));insert into `phone`(card ) values (floor(1+(rand()*20)));</code></pre><pre class=" language-mysql"><code class="language-mysql">#explain分析explain select * from class left join book on class.card=book.card left join phone on book.card = phone.card;#添加索引优化alter table `phone` add index Z(`card`);alter table `book` add index Y(`card`);</code></pre><img src="/2020/01/14/mysql-you-hua/%E4%B8%89%E8%A1%A8%E6%9F%A5%E8%AF%A2explain%E7%BB%93%E6%9E%9C1.png" class="" title="单表查询explain结果1"><p>索引优化</p><img src="/2020/01/14/mysql-you-hua/%E4%B8%89%E8%A1%A8%E6%9F%A5%E8%AF%A2explain%E7%BB%93%E6%9E%9C2.png" class="" title="单表查询explain结果2"><p>后 2 行的 type 都是 ref 且总 rows 优化很好,效果不错</p></li></ul></li><li><p>总结</p><ul><li>尽可能减少Join语句中的NestedLoop的循环总次数：“永远用小结果集驱动大的结果集”。优先优化NestedLoop的内层循环；</li><li>保证Join语句中被驱动表上Join条件字段已经被索引；</li><li>当无法保证被驱动表的Join字段被索引且内存资源充足的前提下，不要太吝惜JoinBuffer的设置；</li></ul></li></ul></li><li><p>索引失效</p><ul><li><p>建表</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE `staffs`(    id int primary key auto_increment,    name varchar(24) not null default "" comment'姓名',    age int not null default 0 comment '年龄',    pos varchar(20) not null default ""  comment'职位',    add_time timestamp not null default current_timestamp comment '入职时间'    )charset utf8 comment '员工记录表';</code></pre></li></ul></li></ul><pre><code>insert into staffs(name,age,pos,add_time) values(&#39;z3&#39;,22,&#39;manage&#39;,now());insert into staffs(name,age,pos,add_time) values(&#39;july&#39;,23,&#39;dev&#39;,now());insert into staffs(name,age,pos,add_time) values(&#39;2000&#39;,23,&#39;dev&#39;,now());select * from staffs;alter table staffs add index idx_staffs_nameAgePos(name,age,pos);```</code></pre><ul><li><p>索引失效案例</p><ul><li><p>全值匹配</p><pre><code>explain select * from staffs where name=&#39;July&#39;;explain select * from staffs where name=&#39;July&#39; and age=23;explain select * from staffs where name=&#39;July&#39; and age=23 and pos=&#39;dev&#39;;</code></pre><img src="/2020/01/14/mysql-you-hua/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88-%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D1.png" class="" title="索引失效-全值匹配1"><img src="/2020/01/14/mysql-you-hua/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88-%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D2.png" class="" title="索引失效-全值匹配2"><img src="/2020/01/14/mysql-you-hua/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88-%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D3.png" class="" title="索引失效-全值匹配3"><pre class=" language-mysql"><code class="language-mysql">explain select * from staffs where age=23 and pos='dev';explain select * from staffs where pos='dev';explain select * from staffs where name='July';</code></pre><img src="/2020/01/14/mysql-you-hua/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88-%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D4.png" class="" title="索引失效-全值匹配4"></li><li><p><strong>最佳左前缀法则</strong>：</p><ul><li>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。（==带头大哥不能死，中间兄弟不能断==哈哈哈）</li></ul></li><li><p>不在索引列上作任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</p><pre class=" language-mysql"><code class="language-mysql">explain select * from staffs where name='July';explain select * from staffs where left(name,4)='July';</code></pre><img src="/2020/01/14/mysql-you-hua/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.png" class="" title="索引失效-表达式匹配"></li><li><p>存储引擎不能使用索引中范围条件右边的列</p><pre class=" language-mysql"><code class="language-mysql">explain select * from staffs where name='z4';explain select * from staffs where name='z4' and age=22;explain select * from staffs where name='z4' and age=22 and pos='manager';explain select * from staffs where name='z4' and age>11 and pos='manager';</code></pre><img src="/2020/01/14/mysql-you-hua/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88-%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6%E5%8F%B3%E5%80%BC%E5%8C%B9%E9%85%8D.png" class="" title="索引失效-范围条件右值匹配"></li><li><p>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *</p><pre class=" language-mysql"><code class="language-mysql">explain select name,age,pos from staffs where name='July' and age=25 and pos='dev';explain select * from staffs where name='July' and age=25 and pos='dev';explain select name,age,pos from staffs where name='July' and age>25 and pos='dev';explain select name,age,pos from staffs where name='July' and age=25;explain select name from staffs where name='July' and age=25;</code></pre><img src="/2020/01/14/mysql-you-hua/%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.png" class="" title="尽量使用覆盖索引"></li><li><p>mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</p><pre class=" language-mysql"><code class="language-mysql">explain select * from staffs where name='July';explain select * from staffs where name!='July';explain select * from staffs where name<>'July';</code></pre><img src="/2020/01/14/mysql-you-hua/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88-%E4%BD%BF%E7%94%A8%E4%B8%8D%E7%AD%89%E4%BA%8E%E5%8C%B9%E9%85%8D.png" class="" title="索引失效-使用不等于匹配"></li><li><p>is null，is not null也无法使用索引</p><pre class=" language-mysql"><code class="language-mysql">explain select * from staffs where name is null;explain select * from staffs where name is not null;</code></pre></li><li><p>like以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描的操作</p><pre class=" language-mysql"><code class="language-mysql">explain select * from staffs where name like '%July%';explain select * from staffs where name like '%July';explain select * from staffs where name like 'July%';</code></pre><img src="/2020/01/14/mysql-you-hua/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88-%E4%BD%BF%E7%94%A8like%E5%8C%B9%E9%85%8D.png" class="" title="索引失效-使用like匹配"><ul><li><p><strong>like%加右边</strong></p></li><li><p>问题：解决like ‘%字符串%’时索引不被使用的方法？</p><p>利用覆盖索引解决两边%的优化问题。</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE `tb1_user`(    id int not null auto_increment,    name varchar(20)  default null,    age int(11) default null ,    email varchar(20)  default null ,     primary key(`id`)    )engine=innodb auto_increment=1 default charset=utf8;</code></pre></li></ul></li></ul></li></ul><pre><code>    insert into tb1_user(name,age,email) values (&#39;1aa1&#39;,&#39;21&#39;,&#39;b@163.com&#39;);    insert into tb1_user(name,age,email) values (&#39;2aa2&#39;,&#39;222&#39;,&#39;a@163.com&#39;);    insert into tb1_user(name,age,email) values (&#39;3aa3&#39;,&#39;265&#39;,&#39;c@163.com&#39;);    insert into tb1_user(name,age,email) values (&#39;4aa4&#39;,&#39;21&#39;,&#39;d@163.com&#39;);     create index idx_nameAge on tb1_user(name,age);    ```    ```    explain select name,age from tb1_user where name like &#39;%aa%&#39;;    explain select id from tb1_user where name like &#39;%aa%&#39;;    explain select name from tb1_user where name like &#39;%aa%&#39;;    explain select age from tb1_user where name like &#39;%aa%&#39;;    explain select id,name from tb1_user where name like &#39;%aa%&#39;;    explain select name,age from tb1_user where name like &#39;%aa%&#39;;    explain select * from tb1_user where name like &#39;%aa%&#39;;    explain select id,name,age,email from tb1_user where name like &#39;%aa%&#39;;    ```    {% asset_img 索引失效-使用like匹配-覆盖索引.png 索引失效-使用like匹配-覆盖索引 %}* 字符串不加单引号索引失效  ```mysql  explain select * from staffs where name=&#39;2000&#39;;  explain select * from staffs where name=2000;  ```  {% asset_img 索引失效-字符串未加单引号.png 索引失效-字符串未加单引号 %}  该问题同问题3，是索引列上做了类型转换！  - **VARCHAR类型绝对不能失去单引号!*** 少用or，用它来连接时会索引失效  ```  explain select * from staffs name=&#39;July&#39; or name=&#39;z3&#39;;  ```  {% asset_img 索引失效-使用or连接.png 索引失效-使用or连接 %}* 总结  {% asset_img 索引失效-总结.png 索引失效-总结 %}</code></pre><ul><li><p>案例讲解</p><ul><li><p>建表</p><pre class=" language-mysql"><code class="language-mysql">create table test03(    id int primary key not null auto_increment,    c1 char(10),    c2 char(10),    c3 char(10),    c4 char(10),    c5 char(10));insert into test03(c1,c2,c3,c4,c5) values ('a1','a2','a3','a4','a5');insert into test03(c1,c2,c3,c4,c5) values ('b1','b2','b3','b4','b5');insert into test03(c1,c2,c3,c4,c5) values ('c1','c2','c3','c4','c5');insert into test03(c1,c2,c3,c4,c5) values ('d1','d2','d3','d4','d5');insert into test03(c1,c2,c3,c4,c5) values ('e1','e2','e3','e4','e5');</code></pre><ul><li><p>分析</p><pre class=" language-mysql"><code class="language-mysql">#索引分析explain select * from test03 where c1='a1';explain select * from test03 where c1='a1' and c2='a2';explain select * from test03 where c1='a1' and c2='a2' and c3='a3';explain select * from test03 where c1='a1' and c2='a2' and c3='a3' and c4='a4';#MySQL自带优化 依然可以使用四条索引explain select * from test03 where c1='a1' and c2='a2' and c3='a3' and c4='a4';#范围后失效explain select * from test03 where c1='a1' and c2='a2' and c3>'a3' and c4='a4';explain select * from test03 where c1='a1' and c2='a2' and c4>'a4' and c3='a3';#c3用于排序explain select * from test03 where c1='a1' and c2='a2' and c4>'a4' order by c3;explain select * from test03 where c1='a1' and c2='a2' order by c3;#只用到c1 c2 using filesortexplain select * from test03 where c1='a1' and c2='a2' order by c4;#只用c1一个字段索引，但是c2、c3用于排序，无filesortexplain select * from test03 where c1='a1' and c5='a5' order by c2,c3;#违背索引顺序，出现了filesortexplain select * from test03 where c1='a1' and c5='a5' order by c3,c2;explain select * from test03 where c1='a1' and c2='a2' order by c2,c3;#用c1,c2两个字段索引，但是c2,c3用于排序，无filesort0explain select * from test03 where c1='a1' and c5='a5' order by c2,c3;#有常量c2时为特例，无filesortexplain select * from test03 where c1='a1' and c2='a2' and c5='a5' order by c3,c2;explain select * from test03 where c1='a1' and c4='a4' group by c2,c3;#using temporary;using filesortexplain select * from test03 where c1='a1' and c4='a4' group by c3,c2;</code></pre></li></ul></li><li><p>定值、范围还是排序，一般order by是给个范围</p></li><li><p>group by基本上都需要进行排序，会有临时表产生</p></li><li><p>一般性建议</p><ul><li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好</li><li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li></ul></li></ul></li></ul><h3 id="查询截取分析"><a href="#查询截取分析" class="headerlink" title="查询截取分析"></a>查询截取分析</h3><ul><li>分析<ol><li>观察，至少跑1天，看看生产的慢SQL情况。</li><li>开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来。</li><li>explain+慢SQL分析</li><li>show profile</li><li>运维经理 or DBA，进行SQL数据库服务器参数调优。</li></ol></li><li>总结<ol><li>慢查询的开启并捕获</li><li>explain+慢SQL分析</li><li>show profile查询SQL在Mysql服务器里面的执行细节和生命周期情况</li><li>SQL数据库服务器的参数调优</li></ol></li></ul><ul><li><p>查询优化</p><ul><li><p><strong>永远小表驱动大表</strong>，类似嵌套循环Nested Loop</p><ul><li><p>优化原则：小表驱动大表，即小的数据集驱动大的数据集。</p></li><li><p>当B表的数据集必须小于A表的数据集时，用in优于exists</p><pre class=" language-mysql"><code class="language-mysql">select * from a where id in (select id from b)#等价于for select id from bfor select * from a where a.id=b.id</code></pre></li><li><p>当A表的数据集必须小于B表的数据集时，用exists优于in</p><pre class=" language-mysql"><code class="language-mysql">select * from a where exists(select 1 from b where b.id=a.id)#等价于for select * from afor select * from b where b.id=a.id</code></pre></li><li><p>注意：A表与B表的ID字段应建立索引。</p></li><li><p>EXISTS</p><ol><li>SELECT … FROM table WHERE EXISTS(subquery)</li><li>该语法可以理解为：<strong>将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE或FALSE）来决定主查询的数据结果是否得以保留。</strong></li></ol></li><li><p>提示</p><ol><li><p>EXISTS（subquery）只返回TRUE或FALSE，因此子查询中的SELECT *也可以是SELECT 1或SELECT ‘X’，官方说法是实际执行时会忽略SELECT清单，因此没有区别。</p></li><li><p>EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担心效率问题，可进行实际检验以确定是否有效率问题。</p></li><li><p>EXISTS子查询往往也可以用条件表达式/其他子查询或者JOIN来替代，何种最优需要具体问题具体分析。</p></li></ol></li><li><p>总结</p><p>in后面为小表，exists后面为大表</p><p>对于exists的subquery使用可以理解为，讲主查询的数据放入子查询中做条件验证，根据验证结果决定主查询的数据是否保留</p></li></ul></li><li><p>order by关键字优化</p><ul><li><p>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序</p><ul><li><p>建表</p><pre class=" language-mysql"><code class="language-mysql">create table tb1A(    #id int primary key not null auto_increment,    age int,    birth timestamp not null);insert into tb1A(age,birth) values (22,now());insert into tb1A(age,birth) values (23,now());insert into tb1A(age,birth) values (24,now());create index idx_A_ageBirth on tb1A(age,birth);</code></pre></li><li><p>Case</p><pre class=" language-mysql"><code class="language-mysql">explain select * from tb1A where age>20 order by age;explain select * from tb1A where age>20 order by age,birth;explain select * from tb1A where age>20 order by birth;</code></pre><img src="/2020/01/14/mysql-you-hua/orderby%E5%AD%90%E5%8F%A5%E6%A1%88%E4%BE%8B1.png" class="" title="orderby子句案例1"><pre class=" language-mysql"><code class="language-mysql">explain select * from tb1A order by birth;explain select * from tb1a where birth>'2020-01-14 00:00:00' order by birth;explain select * from tb1a where birth>'2020-01-14 00:00:00' order by age;explain select * from tb1A order by age asc,birth desc;</code></pre><img src="/2020/01/14/mysql-you-hua/orderby%E5%AD%90%E5%8F%A5%E6%A1%88%E4%BE%8B2.png" class="" title="orderby子句案例2"></li><li><p>MySQL支持两种方式的排序</p><ul><li>FileSort和Index，Index效率高。FileSort方式效率较低。</li><li>Using Index，它指MySQL扫描索引本身完成排序。</li></ul></li><li><p>ORDER BY满足两种情况，会使用Index方式排序：</p><ul><li>ORDER BY语句使用索引最左前列</li><li>使用Where子句与ORDER BY子句条件列组合满足索引最左前列</li></ul></li></ul></li><li><p>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀</p></li><li><p>如果不在索引列上，filesort有两种算法：</p><p>mysql就要启动双路排序和单路排序</p><ul><li><p>双路排序</p><ul><li>MySQL4.1之前是使用双路排序，字面意思就是<strong>两次</strong>扫描磁盘，最终得到数据。读取行指针和order by列，对他们进行排序，然后扫描已经排好序的列表，按照列表中的值重新从列表中读取对应的数据输出。</li><li>从磁盘取排序字段，在buffer进行排序，再从磁盘读取其他字段。</li></ul></li><li><p>取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序</p></li><li><p>单路排序</p><ul><li>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间。</li></ul></li><li><p>结论及引申出的问题</p><ul><li><p>由于单路是后出的，总体而言好过双路</p></li><li><p>单路存在的问题</p><p>在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出，所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序(创建tmp文件，多路合并)，排完再取sort_buffer容量大小，再排序，从而多次IO；问题即是多次IO操作（原因：数据的总大小超过sort_buffer的容量）</p></li></ul></li></ul></li><li><p>优化策略</p><ol><li><p>增大sort_buffer_size参数的设置</p></li><li><p>增大max_length_for_sort_data参数的设置</p></li><li><p>原因</p><p>提高ORDER BY的速度</p><ol><li><p>order by时select * 是一个大忌，应当只Query需要的字段</p><p>1.1 当Query的字段大小总和小于max_length_for_sort_data而且排序字段不是TEXT|BLOB类型时，回用改进后的算法-单路排序，否则用老算法多路排序</p><p>1.2 两种算法都有可能超出sort_buffer的容量，超出过后，会创建tmp文件进行合并排序，导致多次IO（单路算法的风险更大，所以应提高sort_buffer_size</p></li><li><p>尝试提高sort_buffer_size</p></li><li><p>尝试提高max_length_for_sort_data</p><p>提高此参数会增加改进算法的概率，但如果设置的太高，数组总容量超出sort_buffer_size的概率就增大，明显症状是高磁盘IO活动和低CPU使用率</p></li></ol></li></ol></li><li><p>总结</p><p>为排序使用索引</p><ol><li>MySQL两种排序方式：文件排序或扫描有序索引排序</li><li>MySQL能为排序与查询使用相同的索引</li></ol><pre class=" language-mysql"><code class="language-mysql">KEY a_b_c(a,b,c)#order by能使用索引最左前缀order by aorder by a,border by a,b,corder by a desc,b desc,c desc#如果where使用索引的最左前缀定义为常量，则order by能使用索引where a=const order by b,cwhere a=const and b=const order by b,cwhere a=const and b>const order by b,c#不能用索引进行排序#排序不一致order by a asc,b desc,c desc;#丢失a索引where g=const order by b,c;#丢失b索引where a=const order by c;#d不是索引的一部分where a=const order by a,d;#对于排序来说，多个想等条件也是范围查询where a in(...) order by b,c</code></pre></li></ul></li><li><p>GROUP BY关键字优化</p><ul><li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀。</li><li>当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置。</li><li>where高于having，能写在where限定的条件就不要去having限定了。</li></ul></li></ul></li></ul><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><ul><li><p>MySQL锁机制</p><ul><li><p>锁是计算机协调多个进程并发访问某一资源的机制。</p><p>在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如果保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素，从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂</p></li></ul></li><li><p>锁的分类</p><ul><li>从对数据操作的类型（读/写）分<ul><li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li><li>写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</li></ul></li><li>从对数据操作的粒度分<ul><li>表锁</li><li>行锁</li></ul></li></ul></li><li><p>开销、加锁速度、死锁、粒度、并发性能</p></li><li><p>只能就具体应用的特点来说那种锁更合适</p></li><li><p>表锁（偏读锁）</p><ul><li><p>特点：偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p></li><li><p>案例分析</p><ul><li><p>建表</p><pre class=" language-mysql"><code class="language-mysql">create table mylock(id int not null primary key auto_increment,name varchar(20))engine myisam;insert into mylock(name) values('a');insert into mylock(name) values('b');insert into mylock(name) values('c');insert into mylock(name) values('d');insert into mylock(name) values('e');select * from mylock;#手动添加表锁lock table 表名字 read(write), 表名字2 read(write)#查看是否加锁表show open tables;#释放锁unlock tables;</code></pre></li><li><p>加读锁（我们为mylock表加read锁（读阻塞写例子））</p><img src="/2020/01/14/mysql-you-hua/%E6%A1%88%E4%BE%8B-%E8%AF%BB%E5%86%99%E9%94%811.png" class="" title="案例-读写锁1"><img src="/2020/01/14/mysql-you-hua/%E6%A1%88%E4%BE%8B-%E8%AF%BB%E5%86%99%E9%94%812.png" class="" title="案例-读写锁2"></li><li><p>加写锁（我们为mylock表加write锁（MyISAM存储引擎的写阻塞读例子））</p><img src="/2020/01/14/mysql-you-hua/%E6%A1%88%E4%BE%8B-%E8%AF%BB%E5%86%99%E9%94%813.png" class="" title="案例-读写锁3"></li></ul></li><li><p>案例结论</p><ul><li><p>对MyISAM的读操作，不会阻塞其他用户对同一表请求，但会阻塞对同一表的写请求；</p></li><li><p>对MyISAM的写操作，则会阻塞其他用户对同一表的读和写操作；</p></li><li><p>MyISAM表的读操作和写操作之间，以及写操作之间是串行的。</p></li><li><p>当一个线程获得对一个表的写锁后，只有持有锁线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。</p></li></ul></li><li><p>表锁分析</p><ul><li>看看哪些表被加锁了：show open tables;</li><li>如何分析表锁定：可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定。<ul><li>show status like ‘table%’;</li><li>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量的说明如下：<ul><li>Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1；</li><li>Table_locks_waited：出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值加1），此值高则说明存在着较严重的表级锁争用情况。</li></ul></li><li><strong>此外，MyISAM的读写锁调度是写优先，这也是MyISAM不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</strong></li></ul></li></ul></li></ul></li><li><p>行锁（偏写锁）</p><ul><li><p>特点</p><ul><li>偏向Innodb存储引擎，开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。</li><li>Innodb与MyISAM的最大不同有两点：<ul><li>一是支持事务（TRANSACTION）</li><li>而是采用了行级锁</li></ul></li></ul></li><li><p>案例分析</p><pre class=" language-mysql"><code class="language-mysql"># 行锁分析建表create table test(a int(11), b varchar(16))engine=innodb;insert into test(a,b)values(1,'b2'),(3,'3'),(4,'4000'),(5,'5000'),(6,'6000'),(7,'7000'),(8,'8000'),(9,'9000'),(1,'b1');create index idx_test_innodb_a on test(a);create index idx_test_innodb_b on test(b);select * from test;# 自动提交关了，必须手动写commit才能提交set autocommit = 0;</code></pre><img src="/2020/01/14/mysql-you-hua/%E6%A1%88%E4%BE%8B-%E5%81%8F%E5%86%99%E9%94%811.png" class="" title="案例-偏写锁1"></li><li><p>无索引行锁升级为表锁</p><ul><li>如果在更新数据的时候出现了强制类型转换导致索引失效，使得行锁变表锁，即在操作不同行的时候，会出现阻塞的现象。</li></ul></li><li><p>间隙锁危害</p><pre class=" language-mysql"><code class="language-mysql">#进程1update test set b='0629' where a>1 and a<6;#进程2insert into test values(2,'2000');</code></pre><img src="/2020/01/14/mysql-you-hua/%E6%A1%88%E4%BE%8B-%E9%97%B4%E9%9A%99%E9%94%81.png" class="" title="案例-间隙锁"><ul><li>当我们用范围条件而不是相等条件索引数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</li><li>危害：<ol><li>因为Query执行过程中通过范围查找的话，会锁定整个范围内所有的索引键值，即使这个键值并不存在。</li><li>间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。</li></ol></li></ul></li><li><p>面试题：常考如何锁定一行</p><ul><li>select * from 表 where 某一行的条件 for update;</li></ul></li><li><p>案例结论</p><ul><li>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势了。</li><li>但是，InnoDB的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</li></ul></li><li><p>行锁分析</p><ul><li><p>如何分析行锁定</p><ul><li><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p><p>show status like ‘innodb_row_lock%’;</p><img src="/2020/01/14/mysql-you-hua/%E6%A1%88%E4%BE%8B-%E8%A1%8C%E9%94%81%E5%88%86%E6%9E%90.png" class="" title="案例-行锁分析"></li><li><p>对各个状态量的说明如下：</p><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</li><li>innodb_row_lock_time：从系统启动到现在锁定总时间长度；</li><li>innodb_row_lock_time_avg：每次等待所花平均时间；</li><li>innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间；</li><li>innodb_row_lock_waits：系统启动后到现在总共等待的次数。</li></ul></li><li><p>对于这5个变量，比较重要的是</p><ul><li>innodb_row_lock_time_avg（等待平均时长）</li><li>innodb_row_lock_waits（等待总次数）</li><li>innodb_row_lock_time（等待总时长）</li><li>这三项尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ul><li><p>复制的基本原理</p><ul><li><p>slave会从master读取binlog来进行数据同步</p></li><li><p>三步骤+原理图</p><img src="/2020/01/14/mysql-you-hua/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E4%B8%89%E6%AD%A5%E9%AA%A4%E5%8E%9F%E7%90%86%E5%9B%BE.png" class="" title="主从复制-三步骤原理图"></li><li><p>复制的基本原则</p><ul><li>每个slave只有一个master</li><li>每个slave只能有一个唯一的服务器ID</li><li>每个master可以有多个slave</li></ul></li><li><p>复制的问题</p><ul><li>延时</li></ul></li><li><p>一主一从常见配置</p><ul><li>mysql版本一致且后台以服务运行</li><li>主从都配置在[mysqld]结点下，都是小写</li><li>主机修改my.ini配置文件<ul><li>【必须】主服务器唯一ID<ul><li>server-id=1</li></ul></li><li>【必须】启用二进制日志<ul><li>log-bin=自己本地的路径/mysqlbin</li><li>log-bin=D:/devSoft/MySQLServer5.5/data/mysqlbin</li></ul></li><li>【可选】启用错误日志<ul><li>log-err=自己本地的路径/mysqlerr</li><li>log-err=D:/devSoft/MySQLServer5.5/data/mysqlerr</li></ul></li><li>【可选】根目录<ul><li>basedir=自己本地路径</li><li>basedir=”D:/devSoft/MySQLServer5.5/“</li></ul></li><li>【可选】临时目录<ul><li>tmpdir=自己本地路径</li><li>tmpdir=”D:/devSoft/MySQLServer5.5/“</li></ul></li><li>【可选】数据目录<ul><li>datadir=自己本地路径/Data/</li><li>datadir=”D:/devSoft/MySQLServer5.5/data”</li></ul></li><li>read-only=0<ul><li>主机，读写都可以</li></ul></li><li>【可选】设置不要复制的数据库<ul><li>binlog-ignore-db=mysql</li></ul></li><li>【可选】设置需要复制的数据库<ul><li>binlog-do-db=需要复制的主数据库名字</li></ul></li></ul></li></ul></li><li><p>从机修改my.cnf配置文件</p><ul><li>【必须】从服务器唯一ID<ul><li>server-id=2</li></ul></li><li>【可选】启用二进制日志</li></ul></li><li><p>因修改过配置文件，请主机+从机都重启后台mysql服务</p></li><li><p>主机从机都关闭防火墙</p><ul><li>windows手动关闭</li><li>关闭虚拟机linux防火墙：service iptables stop</li></ul></li><li><p>在Windows主机上建立账户并授权slave</p><ul><li><p><code>GRANT REPLICATION SLAVE ON *.* TO &#39;zhangsan&#39; @ &#39;192.168.14.167【从机数据库IP】&#39; IDENTIFIED BY &#39;123456&#39;;</code></p></li><li><p>flush privileges;</p></li><li><p>查询master的状态</p><ul><li><p>show master status</p><img src="/2020/01/14/mysql-you-hua/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B61.png" class="" title="主从复制1"></li><li><p>记录下File和Position的值</p></li></ul></li><li><p>执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化</p></li></ul></li><li><p>在Linux从机上配置需要复制的主机</p><pre class=" language-shell"><code class="language-shell">CHANGE MASTER TO MASTER_HOST='主机IP', MASTER_USER='zhangsan', MASTER_PASSWORD='123456', MASTER_LOG_FILE='file名字', MASTER_LOG_POS=position数字;</code></pre><img src="/2020/01/14/mysql-you-hua/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B62.png" class="" title="主从复制2"></li><li><p>启动从服务器复制功能</p><ul><li>start slave;</li></ul></li><li><p>show slave status\G</p><ul><li><p>下面两个参数都是Yes，则说明主从配置成功！</p></li><li><p>Slave_IO_Running：Yes</p></li><li><p>Slave_SQL_Running：Yes</p><img src="/2020/01/14/mysql-you-hua/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B63.png" class="" title="主从复制3"></li></ul></li><li><p>主机新建库、新建表、insert记录，从机复制</p></li><li><p>如何停止从服务复制功能</p><ul><li>stop slave;</li></ul></li></ul></li></ul><script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({ "model": { jsonPath:"https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json","scale": 1 }, "display": { "position": "right","width": 100, "height": 200,"hOffset": 0, "vOffset": -20 }, "mobile": { "show": true, "scale": 0.5 },"react": { "opacityDefault": 0.7, "opacityOnHover": 0.2 } });</script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 关系型数据库 </tag>
            
            <tag> MySQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL架构与优化</title>
      <link href="/2020/01/07/mysql-gao-ji/"/>
      <url>/2020/01/07/mysql-gao-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><p><a href="https://www.cnblogs.com/lyjun/p/11371851.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyjun/p/11371851.html</a></p><h1 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h1><ul><li><p>大表的影响 </p><ul><li>慢查询</li><li>建立索引需要很长时间</li><li>修改表结构需要长时间锁表</li></ul></li><li><p>处理数据库中的大表</p><ul><li>分库分表把一张大表分成多个小表<ul><li>分表主键的选择</li><li>分表后跨分区数据的查询和统计</li></ul></li><li>大表的历史数据归档 减少前后端业务的影响<ul><li>归档时间点的选择</li><li>如何进行归档</li></ul></li></ul></li><li><p>事务</p><blockquote><p>事务时数据库系统区别于其他一切文件系统的重要特性之一</p></blockquote><ul><li><p>原子性</p><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败，对于一个事务来说，不可能只执行其中的一部分操作</p></li><li><p>一致性</p><p>一致性是指事务将数据库从一种一致性状态转换到另外一种一致性状态，在事务开始之前和事务结束之后数据库中的数据完整性没有被破坏</p></li><li><p>隔离性</p><p>隔离性要求一个事务对数据库中数据的修改，在未提交完成前对于其它事务是不可见的</p><ul><li>未提交读(READ UNCOMMITED)（脏读）</li><li>已提交读(READ COMMITED) 一般的SQL数据库的级别 （这就是不可重复读）</li><li>可重复读(REPEATABLE READ)</li><li>可串行化(SERIALIZABLE) 很少用，因为容易锁</li></ul></li><li><p>持久性</p><p>一旦事务提交，这其所作的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失。</p></li></ul></li><li><p>大事务 运行时间比较长，操作的数据比较多的事务</p><ul><li>锁定太多的数据，造成大量的阻塞和锁超时</li><li>回滚时所需的时间比较长</li><li>执行时间长，容易造成主从延迟</li></ul></li></ul><h2 id="影响性能的几个方面"><a href="#影响性能的几个方面" class="headerlink" title="影响性能的几个方面"></a>影响性能的几个方面</h2><ul><li><p>硬件</p></li><li><p>操作系统</p><ul><li><p>CentOS 系统参数优化</p><p>影响重大的a tiile优化参数</p><ul><li><p>增加连接数</p><pre><code>+ net.core.somaxconn=65535+ net.core.netdev_max_backlog=65535+ net.ipv4.tcp_max_syn_backlog=65535</code></pre></li><li><p>加快TCP回收效率</p><pre><code>+ net.ipv4.tcp_fin_timeout=10+ net.ipv4.tcp_tw_reuse=1+ net.ipv4.tcp_tw_recycle=1</code></pre></li><li><p>缓冲区接受的默认值和最大值</p><pre><code>+ net.core.wmem_default=87380+ net.core.wmem_max=16777216+ net.core.rmem_default=87380+ net.core.rmem_max=16777216</code></pre></li><li><p>失效连接所占用TCP系统资源，加快系统回收的效率</p><pre><code>+ net.ipv4.tcp_keepalive_time=120+ net.ipv4.tcp_keepalive_intvl=30+ net.ipv4.tcp_keepalive_probes=3</code></pre></li><li><p>内存相关的参数</p><pre><code>+ kernel.shmmax=4294967295Linux 内核参数中最重要的参数之一，用于定义单个共享内存段的最大值。&gt; 注意：    1. 这个参数应该设置的足够大，以便能在一个共享内存段下容纳下整个    的Innodb缓冲池的大小。    2. 这个值的大小对于64位linux系统，可取的最大值为物理内存值-1byte，    建议值为大于物理内存的一半，一半取值大于Innodb 缓着冲池的大小即可，    可以去物理内存-1byte。+ vm.swappiness=0这个参数当内存不足时会对性能参数比较明显的影响Linux系统内存交换区:    在Linux系统安装时都会有一个特殊的磁盘分区，称之为系统交换分区。    使用 free -m 在系统中可以看到类似下面内容其中swap就是交换分区。    当操作系统因为没有足够内存时就会将一些&lt;font color=&quot;red&quot;&gt;虚拟内存    &lt;/font&gt;写到&lt;font color=&quot;red&quot;&gt;磁盘的交换区&lt;/font&gt;中这样就会发生    内存交换在MySQL服务器上是否要使用交换分区有一些争议:    在MySQL服务所在的Linux系统上完全禁用交换分区。    带来的风险：      1. 降低操作系统的性能      2. 容易造成内存溢出、崩溃，或都被操作系统Kill掉结论：    在MySQL服务器上保留交换区还是很必要的，但是要控制何时使用交换分区vm.swappiness=0就是告诉Linux内核除非虚拟内存完全满了，否则不要使用交换区。</code></pre></li><li><p>增加资源限制(/etc/security/limit.conf)</p><pre><code>这个文件实际上是Linux PAM 也就是插入式认证模块的配置文件。  打开文件数的限制。  * soft nofile 65535  * hard nofile 65535  加到limit.conf 文件末尾就可以了  *      表示对所有用户有效  soft    指的是当前系统生效的设置  hard    表明系统中能设定的最大值  nofile  表示所限制的资源是打开文件的最大数目  65535  就是限制的数量  结论：    把可打开的文件数量增加到了65535个以保证可以打开足够多的文件句柄。  注意：    这个文件的修改需要重启系统才可以生效。</code></pre></li></ul></li></ul></li></ul><pre><code>* 磁盘调度策略(/sys/block/devname/queue/scheduler)  ```  cat /sys/block/sda/queue/scheduler  noop anticipatory deadline [cfq]  noop(电梯式调度策略)      NOOP实现了一个FIFO队列，它像电梯的工作方法一样对I/O请求进行组织，当      有一个新的请求到来时，它将强求合并最近的请求之后，以此来保证请求同一      介质。NOOP倾向饿死读而利于写，因此NOOP对于闪存设备、RAM及嵌入式系统      是最好的选择。  deadline(截止时间调度策略)       Deadline确保了再一个截止时间内服务请求，这个截止时间是可调整的，而      默认读期限短语写期限。这样就防止了写操作因为不能被读取而饿死的现象，      Deadline对数据库类应用是最好的选择。  anticipatory(预料I/O调度策略)      本质上与Deadline一样，但在最后一次读操作后，要等6ms，才能继续进行对      其它I/O请求进行调度。他会在每个6ms中插入行的I/O操作，而会将一些小写      入流合并成一个大写入流，用写入延时换区最大的写入吞吐量。AS适合于*写      入较多的环境*，比如文件服务器，AS对数据库环境表现很差。  ```</code></pre><ul><li><p>数据库存储引擎的选择</p></li><li><p><strong>数据库参数配置</strong></p></li><li><p>数据库结构设计和SQL语句</p></li></ul><h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><img src="/2020/01/07/mysql-gao-ji/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" class="" title="MySQL体系结构"><ul><li><p>客户端</p><ul><li>PHP\JAVA\C API\.Net\ODBC\JDBC</li></ul></li><li><p>存储引擎</p><ul><li>InnoDB\MyISAM\CSV\Memory\ARCHIVE\xtraDB</li></ul></li></ul><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ul><li>特性<ul><li>并发性与锁级别（表锁）（读写的话并发性支持不好，只读可以）</li><li>表损坏修复（因为不是修复事务，可能会造成数据丢失）</li><li>MyISAM表支持的索引类型<ul><li>Btree + 全文索引</li></ul></li><li>MyISAM表支持数据压缩<ul><li>命令行：myisampack 且压缩表只读</li></ul></li></ul></li><li>限制<ul><li>版本&lt; MySQL5.0默认表大小为4G</li><li>如存储大表则要修改MAX_Rows 和 AVG_ROW_LENGTH</li><li>版本&gt; MySQL5.0时默认支持为256TB</li></ul></li><li>使用场景<ul><li>非事务型应用</li><li>只读类应用</li><li>空间类应用</li></ul></li></ul><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ul><li><p>MySQL5.5.8及以后的版本默认存储引擎</p></li><li><p>Innodb 使用表空间进行 数据存储</p><pre class=" language-css"><code class="language-css">innodb_file_per_table 参数<span class="token property">ON</span><span class="token punctuation">:</span>独立表空间：tablename <span class="token number">.</span>ibd<span class="token property">OFF</span><span class="token punctuation">:</span>系统表空间<span class="token punctuation">:</span> ibdataX</code></pre></li></ul><ul><li><p>系统表和独立表空间要如何选择 推荐使用独立表空间</p><ul><li><p>比较</p><ul><li><p>系统表空间无法简单的收缩文件大小<br>独立表空间可以通过optimeize table命令收缩系统文件</p></li><li><p>系统表空间会产生IO瓶颈<br>独立表空间可以同时向多个文件刷新数据</p></li></ul></li></ul></li><li><p>把原来存在于系统表空间中的表转移到独立表空间的方法</p><ol><li>使用mysqldump导出所有数据库表数据</li></ol></li></ul><ol start="2"><li>停止MySQL服务，修改参数，并删除InnoDB相关文件<ol start="3"><li>重启MySQL服务，重建Innodb系统表空间</li><li>重新导入数据</li></ol></li></ol><ul><li><p>特性</p><ul><li>Innodb是一种事务性存储引擎</li><li>完全支持事务的ACID特性（原子 一致 隔离 持久）</li><li>Redo Log（持久性） 和 Undo Log</li><li>Innodb支持行级锁</li><li>行级锁可以最大程度的支持并发</li><li>行级锁是由存储引擎层实现的</li></ul></li><li><p>适用场景</p><ul><li>Innodb适合于大多数的OLTP应用</li><li>5.7版本之后支持全文索引和空间函数</li></ul></li></ul><h4 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h4><ul><li>文件系统<ul><li>数据以文本方式存储在文件中</li><li>.CSV文件存储表内容</li><li>.CSM文件存储表的元数据如表状态和数据量</li><li>.frm文件存储表结构信息</li></ul></li><li>特点<ul><li>以CSV格式进行数据存储</li><li>所有列必须都是不能为NULL</li><li>不支持索引，不适合大表，不适合在线处理</li><li>可以对数据文件直接编辑 保存文本文件内容</li></ul></li><li>适用场景<ul><li>适合做为数据交换的中间表<ul><li>excel-&gt;CSV文件-&gt;MySQL数据目录</li><li>数据-&gt;CSV文件-&gt;其他web程序</li></ul></li></ul></li></ul><h4 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h4><ul><li>文件系统<ul><li>以zlib对表数据进行压缩，磁盘I/O更少</li><li>数据存储在ARZ为后缀的文件中</li></ul></li><li>特点<ul><li>只支持insert和select操作</li><li>只允许在自增ID列上加索引</li></ul></li><li>适用场景<ul><li>日志和数据采集类应用</li></ul></li></ul><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><ul><li>文件系统<ul><li>也称为HEAP存储引擎，所以数据保存在内存中</li><li>重启后表数据丢失，表结构会保留</li></ul></li><li>特点<ul><li>支持HASH索引和BTree索引<ul><li>等值查找用HASH</li><li>范围查找用BTree</li></ul></li><li>所有字段都为固定长度<ul><li>计算使用varchar(10) 也等于 char(10)</li></ul></li><li>不支持BLOG和TEXT等大字段</li><li>Memory存储引擎使用表级锁</li><li>最大大小由max_heap_table_size参数决定</li></ul></li><li>适用场景<ul><li>用于查找或者是映射表，例如邮编和地区的对应表</li><li>用于保存数据分析中产生的中间表</li><li>用于缓存周期性聚合数据的结果表</li></ul></li><li>与临时表的差别<ul><li>临时表<ul><li>系统使用的临时表<ul><li>超过限制使用myisam临时表</li><li>未超限制使用Memory表</li></ul></li><li>create temporary table 建立的临时表</li></ul></li></ul></li></ul><h4 id="Federated"><a href="#Federated" class="headerlink" title="Federated"></a>Federated</h4><ul><li><p>特点</p><ul><li>提供了访问远程MySQL服务器上表的方法</li><li>本地不存储数据，数据全部放到远程服务器上</li><li>本地需要保存表结构和远程服务器的连接信息</li></ul></li><li><p>默认禁止，启用需要在启动时增加federated参数</p><blockquote><pre class=" language-shell"><code class="language-shell">mysql://username[:password]@host_name[:port_num]/db_name/tbl_name</code></pre></blockquote></li><li><p>适用场景</p><ul><li>偶尔的统计分析及手工查询</li></ul></li></ul><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>锁对主要作用是管理共享资源的并发访问，用于实现事务的隔离性</p><table><thead><tr><th>写锁</th><th>读锁</th><th></th></tr></thead><tbody><tr><td>写锁（独占锁</td><td>不兼容</td><td>不兼容</td></tr><tr><td>读锁（共享锁</td><td>不兼容</td><td>兼容</td></tr></tbody></table><ul><li>表级锁（并发支持不好）</li><li>行级锁（开销大）</li></ul><h3 id="MySQL服务器参数"><a href="#MySQL服务器参数" class="headerlink" title="MySQL服务器参数"></a>MySQL服务器参数</h3><ul><li><p>MySQL获取配置信息路径</p><ul><li><p>命令行参数</p><p>mysqlid_safe – datadir=/data/sql_data</p></li><li><p>配置文件</p><p>mysqlid –help –verbose | grep -A 1 ‘Default options’</p><p>/etc/my.cnf /etc/mysql/my.cnf /home/mysql/my.cnf ~/.my.cnf</p></li></ul></li><li><p>MySQL配置参数的作用域</p><ul><li><p>全局参数</p><p>set global 参数名=参数值</p><p>set @@global.参数名:=参数值</p></li><li><p>会话参数</p><p>set[session]参数名=参数值</p><p>set @@session.参数名:=参数值</p></li></ul></li><li><p>内存配置相关参数</p><ul><li><p>确定可以使用的内存上限</p></li><li><p>确定MySQL的<strong>每个连接</strong>使用的内存</p><ul><li>排序缓存区的尺寸    sort_buffer_size</li><li>每个线程使用连接缓冲区的大小    join_buffer_size</li><li>MYISAM表进行全表扫描时,所分配的读缓存池的大小    read_buffer_size</li><li>控制的是索引缓冲区的大小    read_rnd_buffer_size</li></ul></li><li><p>确定需要为操作系统保存多少内存</p></li><li><p>如何为缓存池分配内存</p><p>总内存 - (每个线程所需要的内存*连接数) - 系统保留内存</p><ul><li>innodb所使用的缓冲池的大小    Innodb_buffer_pool_size</li></ul></li></ul></li><li><p>I/O相关配置参数</p><ul><li><p>Innodb_log_file_size</p></li><li><p>Innodb_log_files_in_group</p></li><li><p>事务日志总大小 = Innodb_log_files_in_group*Innodb_log_file_size</p></li><li><p>Innodb_log_buffer_size</p></li><li><p>Innodb_flush_log_at_trx_commit</p><ul><li>0：每秒钟进行一次log写入到操作系统cache,并刷新log到磁盘</li><li>1[默认]：每次在事务提交的时候呢,都会执行log写入操作系统cache,并刷新操作系统cache log到磁盘文件持久化的存储的操作</li><li>2[建议]：表示事务提交后,执行log数据写入到操作系统cache的这个操作,并且每秒钟执行一次从操作系统的cache刷新到磁盘文件的log操作</li></ul></li><li><p>Innodb刷新的方式 Innodb_flush_method=O_DIRECT</p><p>这个设置会通知操作系统,不要缓存数据,也不要预读,也就是说,这个选项完全关闭了操作系统的缓存,并且使所有读和写呢,都直接通过存储设备,来完成,避免了Innodb和操作系统,对于数据的双重缓存</p></li><li><p>控制Innodb如何使用表空间 Innodb_file_per_table=1</p><p>为每一个表建立一个单独的表空间,否则就会把所有的Innodb表的数据呢,存储到系统表空间中</p></li><li><p>控制innodb是否双写缓存 Innodb_doublewrite=1</p><p>避免没有写完整所导致的数据损坏</p></li></ul></li><li><p>安全相关配置参数</p></li><li><p>其他常用配置参数</p></li></ul><h3 id="数据库设计对性能的影响"><a href="#数据库设计对性能的影响" class="headerlink" title="数据库设计对性能的影响"></a>数据库设计对性能的影响</h3><ul><li>过份的反范式化为表建立太多的列</li><li>过份的范式化造成太多的表关联</li><li>在OLTP环境中使用不恰当的分区表</li><li>使用外键保证数据的完整性</li></ul><h3 id="性能优化顺序"><a href="#性能优化顺序" class="headerlink" title="性能优化顺序"></a>性能优化顺序</h3><ul><li>数据库结构设计和SQL语句</li><li>数据库存储引擎的选择和参数配置</li><li>系统选择及优化</li><li>硬件升级</li></ul><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><blockquote><p>基准测试是一种测量和评估软件性能指标的活动用于建立某个时刻的性能基准，以便当系统发生软硬件变化时重新进行基准测试以评估变化对性能的影响</p></blockquote><ul><li><p>对比</p><ul><li>基准测试    直接、简单、易于比较 ，用于评估服务器的处理能力</li><li>压力测试    对真实的业务数据进行测试，获得真实系统所能承受的压力</li></ul></li><li><p>目的</p><ul><li>建立MySQL服务器的性能基准线<br>确定当前MySQL服务器运行情况</li><li>模拟比当前系统更高的负载，以找出系统的扩展瓶颈</li><li>测试不同的硬件、软件和操作系统配置</li><li>证明新的硬件设备是否配置正确</li></ul></li><li><p>常用指标</p><ul><li><p>单位时间内所处理的事务数（TPS）</p></li><li><p>单位时间内所处理的查询数（QPS）</p></li><li><p>响应时间</p><blockquote><p>平均响应时间、最小响应时间、最大响应时间、各时间所占百分比</p></blockquote></li><li><p>并发量：同时处理的查询请求的数量</p><blockquote><p>并发量不等于连接数</p></blockquote></li></ul></li></ul><h2 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h2><ul><li>目的<ul><li>减少数据冗余</li><li>尽量避免数据维护中出现更新，插入和删除异常<ul><li>插入异常：如果表中的某个实体随着另一个实体而存在</li><li>更新异常：如果更改表中的某个实体的单独属性时，需要对多行进行更新</li><li>删除异常：如果删除表中某一实体则会导致其他实体的消失</li></ul></li><li>节约数据存储空间</li><li>节省数据查询效率</li></ul></li></ul><h3 id="数据库结构设计的步骤"><a href="#数据库结构设计的步骤" class="headerlink" title="数据库结构设计的步骤"></a>数据库结构设计的步骤</h3><ul><li>需求分析：全面了解产品设计的存储需求<ul><li>存储需求</li><li>数据处理需求</li><li>数据的安全性和完整性</li></ul></li><li>逻辑设计：设计数据的逻辑存储结构<ul><li>数据实体之间的逻辑关系，解决数据冗余和数据维护异常</li></ul></li><li>物理设计：根据所使用的数据库特点进行表结构设计<ul><li>关系型数据库：Oralce，SQLServer，MySQL，postgresSQL</li><li>非关系型数据库： mongo,Redis,Hadoop</li></ul></li><li>维护优化：根据实际情况对索引、存储结构等进行优化</li></ul><h4 id="数据库设计的第一范式"><a href="#数据库设计的第一范式" class="headerlink" title="数据库设计的第一范式"></a>数据库设计的第一范式</h4><ul><li>数据库表中的所有字段都只具有单一属性</li><li>单一属性的列是由基本的数据类型所构成的</li><li>设计出来的表都是简单的二维表</li></ul><h4 id="数据库设计的第二范式"><a href="#数据库设计的第二范式" class="headerlink" title="数据库设计的第二范式"></a>数据库设计的第二范式</h4><ul><li><p>要求一个表中只有具有一个业务主键</p><blockquote><p>也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系</p></blockquote></li></ul><h4 id="数据库设计的第三范式"><a href="#数据库设计的第三范式" class="headerlink" title="数据库设计的第三范式"></a>数据库设计的第三范式</h4><ul><li><p>每一个非主属性既不部分依赖于也不传递依赖于业务主键</p><blockquote><p>也就是在第二范式的基础上消除了非主属性对主键的传递依赖</p></blockquote></li></ul><h3 id="需求分析及逻辑设计"><a href="#需求分析及逻辑设计" class="headerlink" title="需求分析及逻辑设计"></a>需求分析及逻辑设计</h3><h4 id="范式化设计"><a href="#范式化设计" class="headerlink" title="范式化设计"></a>范式化设计</h4><ul><li><p>需求</p><ul><li>本网站只销售图书类商品</li><li>需要具有以下功能<ul><li>用户登录</li><li>用户管理</li><li>商品展示</li><li>商品管理</li><li>供应商管理</li><li>在线销售</li></ul></li></ul></li><li><p>用户登录及用户管理功能</p><ul><li><p>用户必须注册并登录系统才能进行网上交易</p><p> 用户名作为业务主键</p></li><li><p>同一时间一个用户只能在一个地方登录</p></li><li><p>用户属性：{用户名，密码，手机号，姓名，注册日期，在线状态，出生日期} 用户名为主键</p><blockquote><p>只有一个业务主键，一定是符合第二范式<br> 没有属性和业务主键存在传递依赖关系，符合第三范式</p></blockquote></li></ul></li><li><p>商品展示和商品管理功能</p><ul><li><p>商品信息:{商品名称，分类名称，出版社名称，图书价格，图书描述，作者}</p><blockquote><p>商户名称和分类名称为主键 不满足第二范式</p></blockquote><ul><li>商品信息：{商品名称，出版社名称，图书价格，图书描述，作者}</li><li>分类信息：{分类名称，分类描述}</li><li>商品分类（对应关系表）：{商品名称，分类名称}</li></ul></li></ul></li><li><p>供应商管理功能</p><ul><li>供应商信息：{出版社名称，地址，电话，联系人，银行账号} 出版社信息PERMARY KEY</li></ul></li><li><p>在线销售功能</p><ul><li><p>在线销售：{订单编号，下单用户名，下单日期，订单金额，订单商品分类，订单商品名，订单商品单价，订单商品数量，支付金额，物流单号}</p><ol><li>只有一个业务主键，符合第二范式</li><li>订单商品单价，订单商品数量，订单编号 存在着传递关系，不符合第三范式</li><li>数据冗余=&gt;订单商品信息和订单信息表中的数据</li></ol></li><li><p>拆分</p><ul><li>订单表：{订单编号，下单用户名，下单日期，支付金额，物流单号}</li><li>订单商品关联表：{订单编号，订单商品分类，订单商品名，商品数量}</li></ul></li><li><p>编写SQL查询出每一个用户的订单总金额</p><pre class=" language-mysql"><code class="language-mysql">select 下单用户名,sum(d.商品价格*b.商品数量) from 订单表 a join 订单商品关联表 b on a.订单编号=b.订单编号 join 商品分类关联表 c on c.商品名称=b.商品名称 and c.分类名称=b.订单商品分类 join 商品信息表 d on d.商品名称=c.商品名称 group by 下单用户名</code></pre></li></ul></li></ul><h4 id="反范式化设计"><a href="#反范式化设计" class="headerlink" title="反范式化设计"></a>反范式化设计</h4><blockquote><p>反范式化是针对范式化而言的，在前面介绍了数据库设计的范式，所谓的反范式化就是为了性能和读取效率的考虑而适当的对数据库设计范式的要求进行违反，而允许存在少量的数据冗余，换句话来说反范式化就是使用空间来换取时间</p></blockquote><ul><li><p>原来的表：</p><ul><li>商品信息：{商品名称，出版社名称，图书价格，图书描述，作者}</li><li>分类信息：{分类名称，分类描述}</li><li>商品分类关系：{商品名称，分类名称}</li></ul></li><li><p>改造后的表</p><ul><li>商品信息：{商品名称，分类名称，出版社名称，图书价格，图书描述，作者}</li><li>分类信息：{分类名称，分类描述}</li></ul></li><li><p>原来的表：</p><ul><li>订单表：{订单编号，下单用户名，下单日期，支付金额，物流单号}</li><li>订单商品关联表：{订单编号，订单商品分类，订单商品名，商品数量}</li></ul></li><li><p>改造后的表：</p><ul><li>订单表：{订单编号，下单用户名，手机号，下单日期，支付金额，物流单号，订单金额}</li><li>订单商品关联表：{订单编号，订单商品分类，订单商品名，商品数量，商品单价}</li></ul></li><li><p>编写SQL查询出每一个用户的订单总金额</p><pre class=" language-mysql"><code class="language-mysql">select 下单用户名,sum(订单金额) from 订单表 group by 下单用户名</code></pre></li></ul><ul><li><p>编写SQL查询出下单用户和订单详情</p><pre class=" language-mysql"><code class="language-mysql">select a.订单编号, a.用户名, a.手机号, b.商品名称, b.商品单价, b.商品数量 from 订单表 a join 订单商品</code></pre></li></ul><ul><li>总结<ul><li>不能完全按照范式化的要求进行设计</li><li>考虑以后如何使用表</li></ul></li></ul><h4 id="范式化与反范式化对比"><a href="#范式化与反范式化对比" class="headerlink" title="范式化与反范式化对比"></a>范式化与反范式化对比</h4><ul><li>范式化<ul><li>优点：<ul><li>可以尽量的减少数据冗余,数据表更新快体积小</li><li>范式化的更新操作比反范式化更快</li><li>范式化的表通常比反范式化更小</li></ul></li><li>缺点：<ul><li>对于查询需要对多个表进行关联</li><li>更难进行索引优化</li></ul></li></ul></li><li>反范式化<ul><li>优点：<ul><li>可以减少表的关联</li><li>可以更好的进行索引优化</li></ul></li><li>缺点：<ul><li>存在数据冗余及数据维护异常</li><li>对数据的修改需要更多的成本</li></ul></li></ul></li></ul><h3 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h3><h4 id="物理设计的内容"><a href="#物理设计的内容" class="headerlink" title="物理设计的内容"></a>物理设计的内容</h4><ul><li><p>定义数据库、表及字段的命名规范</p><ul><li>数据库、表及字段的命名要遵守<strong>可读性</strong>原则</li><li>数据库、表及字段的命名要遵守<strong>表意性</strong>原则</li><li>数据库、表及字段的命名要遵守<strong>长名</strong>原则</li></ul></li><li><p>选择合适的存储引擎</p><table><thead><tr><th>存储引擎</th><th>事务</th><th>锁粒度</th><th>主要应用</th><th>忌用</th></tr></thead><tbody><tr><td>MyISAM</td><td>不支持</td><td>支持并发插入的表级锁</td><td>SELECT,INSERT</td><td>读写操作频繁</td></tr><tr><td>MRG_MYISAM</td><td>不支持</td><td>支持并发插入的表级锁</td><td>分段归档，数据仓库</td><td>全局查找过多的场景</td></tr><tr><td>Innodb</td><td>支持</td><td>支持MVCC的行级锁</td><td>事务处理</td><td>无</td></tr><tr><td>Archive</td><td>不支持</td><td>行级锁</td><td>日志记录，只支持insert，select</td><td>需要随机读取，更新，删除</td></tr><tr><td>Ndb</td><td>支持</td><td>行级锁</td><td>高可用性</td><td>大部分应用</td></tr></tbody></table></li><li><p>为表中的字段选择合适的数据类型</p><ul><li><p>为表中的字段选择合适的数据类型</p><ul><li>当一个列可以选择多种数据类型时，应该优先考虑素质类型</li><li>其次是日期或二进制类型，最后是支付类型</li><li>对于相同级别的数据类型，应该优先选择占用空间小的数据类型</li></ul></li><li><p>选择合适的整数类型</p><table><thead><tr><th>列类型</th><th>存储空间</th><th>SINGED</th><th>UNSINGED</th></tr></thead><tbody><tr><td>tinyint</td><td>1字节</td><td>-128<del>127 (-27</del>(27)-1)</td><td>0~255 ((2^8)-1)</td></tr><tr><td>smallint</td><td>2字节</td><td>-32768~32767 (-2^15 ~ (2^15)-1)</td><td>0~65535 ((2^16)-1)</td></tr><tr><td>mediumint</td><td>3字节</td><td>-8388608~8388607 (-2^23 ~ (2^23)-1)</td><td>0~16777215 ((2^24)-1)</td></tr><tr><td>int</td><td>4字节</td><td>-2147483648~2147483647 (-2^31 ~ (2^31)-1)</td><td>0~4294967295 ((2^32)-1))</td></tr><tr><td>bigint</td><td>8字节</td><td>-9223372036854775808  ~ 9223372036854775807 (-2^63 ~ (2^63)-1)</td><td>0 ~18446744073709551615 ((2^64)-1)</td></tr></tbody></table></li><li><p>选择合适的实数类型</p><table><thead><tr><th>列类型</th><th>存储空间</th><th>是否精确类型</th></tr></thead><tbody><tr><td>FLOAT</td><td>4个字节</td><td>否</td></tr><tr><td>DOUBLE</td><td>8个字节</td><td>否</td></tr><tr><td>DECIMAL</td><td>每4个字节存9个数字，小数点占一个字节</td><td>是</td></tr></tbody></table></li><li><p>VARCHAR与CHAR类型的选择</p><ul><li>varchar类型的存储特点<ol><li>varchar用于存储边长字符串，只占必要的存储空间</li><li>列的最大长度小于255则只占用一个额外字节用于记录字符串长度</li><li>列的最大长度大于255这要占用两个额外字节用于记录字符串长度</li><li>正因为两个字节记录字符串长度，varchar最大长度为 65535，最大存储字符数量(defalut null 则 65535-2-1=65532，not null 则 65535-2=65533)</li></ol></li><li>varchar长度选择<ol><li>使用最小的符合需求的长度</li><li>varchar(5)和varchar(200)存储 ‘MySQL’ 字符串性能不同</li></ol></li><li>varchar适用场景<ol><li>字符串列的最大长度比平均长度大很多</li><li>字符串列很少被更新</li><li>使用了多字节字符集存储字符串</li></ol></li><li>char类型存储特点<ol><li>CHAR类型是定长的</li><li>字符串存储在CHAR类型的列中会删除末尾的空格</li><li>CHAR类型的最大宽度为255</li></ol></li><li>char类型适用场景<ol><li>CHAR类型适合存储所长度近似的值</li><li>CHAR类型适合存储短字符串</li><li>CHAR类型适合存储经常更新的字符串列</li></ol></li></ul></li><li><p>选择合适的日期类型</p><ul><li><p>DATETIME类型</p><blockquote><p>以YYYY-MM-DD HH:MM:SS[.fraction] 格式存储日期时间</p><p> datetime = YYYY-MM-DD HH:MM:SS</p><p> datetime(6) = YYYY-MM-DD HH:MM:SS.fraction(微秒需要datetime(6))</p><p> DATETIME类型与时区无关，占用8个字节的存储空间</p><p> 时间范围1000-01-01 00:00:00到9999-12-31 23:59:59</p></blockquote></li><li><p>TIMESTAMP类型</p><blockquote><p>存储了由格林尼治时间1970年1月1日到当前时间的秒数</p><p> 以YYYY-MM-DD HH:MM:SS.[fraction]的格式显示，占用4个字节(timestamp(6))</p><p> 时间范围1970-01-01到2038-01-19</p></blockquote><p>timestamp类型显示依赖于所指定的时区</p><p>在行的数据修改时可以自动修改timestamp列的值</p></li><li><p>DATE类型的优点</p><ol><li><p>占用的字节数比使用字符串（8字节）、datetime（8字节）、int（4字节）存储要少，使用date类型只需要3个字节</p></li><li><p>使用Date类型还可以利用日期时间函数进行日期之间的计算</p><p>date类型用于保存1000-01-01到9999-12-31之间的日期</p></li></ol></li><li><p>TIME类型</p><p>time类型用于存储时间数据，格式为HH:MM:SS</p></li></ul></li><li><p>注意事项</p><ul><li><p>不要使用字符串类型来存储日期时间数据</p><p> 日期时间类型通常比字符串占用的存储空间小</p><p> 日期时间类型在进行查找过滤时可以利用日期来进行对比</p><p> 日期时间类型还有丰富的处理函数，可以方便的对时期类型进行日期计算</p></li><li><p>使用INT存储日期时间不如使用TIMESTAMP类型（<strong>存疑待研究</strong>）</p></li></ul></li></ul></li><li><p>总结</p><ul><li>没有特殊要求推荐使用INNODB</li><li>为表中的每个列选择合适的类型</li><li>如何选择表的主键<ul><li>主键应该尽可能的小</li><li>主键应该是顺序增长的</li></ul></li><li>增加数据的插入效率<ul><li>Innodb的主键和业务主键可以不同（为了业务主键的唯一性，可以使用唯一索引）</li></ul></li><li>数据库结构<ul><li>查询性能要求</li><li>范式化要求</li></ul></li></ul></li><li><p>建立数据库架构</p></li></ul><h3 id="数据库索引优化"><a href="#数据库索引优化" class="headerlink" title="数据库索引优化"></a>数据库索引优化</h3><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><ul><li><p>优势</p><ul><li>因为文件与数据库都是需要较大的存储——不可能全部存储在内存中，故要存储到磁盘上</li></ul><ol start="2"><li>所谓索引，即是快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数(B+树相比B树，其非叶子节点占用更小的空间，可以有更多非叶子节点存放在再内存中，减少大量的IO)</li><li>局部性原理与磁盘预读，预读的长度一般为页(page)的整倍数，(在许多操作系统中，页得大小通常为4k)</li><li>数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，(由于节点中有两个数组，所以地址连续)。而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性</li></ol><ul><li>B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因</li></ul></li><li><p>特点</p><ul><li>B-tree索引以B+树的结构存储数据</li><li>B-tree索引能够加快数据的查询速度</li><li>B-tree索引更适合进行范围查找</li></ul></li><li><p>用到B-Tree索引的情况</p><ul><li>全值匹配的查询<ul><li>order_sn=’9876432119900’</li></ul></li><li>匹配最左前缀的查询<ul><li>联合索引的最左侧的字段有用到就可以用到，索引 index(a,b,c), 当查询条件where a=’xxx’  时就可以用到，顺序很重要 where a=’xxx’ and b=’yyy’也可以用到，但 where b=’xxx’ and c=’yyy’ and a=’zzz’ 就用不了了</li></ul></li><li>匹配列前缀查询<ul><li>order_sn like ‘9876%’</li></ul></li><li>匹配范围值的查询<ul><li>order_sn&gt;’9876432119900’ and order_sn &lt;’9876432119999’</li></ul></li><li>精确匹配左前列并范围匹配另外一列</li><li>只访问索引的查询</li></ul></li></ul><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><ul><li><p>特点</p><ul><li><p>Hash 索引时基于Hash表实现的，只有查询条件精确匹配Hash索引中的所有列时，才能够使用到Hash索引。</p><p>对于Hash索引中的所有列，存储引擎都会为每一行计算一个Hash码，Hash索引中存储的就是Hash码。</p></li></ul></li><li><p>限制</p><ul><li>如果不是按照索引最左列开始查找，则无法使用索引</li><li>使用索引时不能跳过索引中的列</li><li>NOT IN 和 &lt;&gt; 操作无法使用索引</li><li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引</li></ul></li></ul><h4 id="索引优劣"><a href="#索引优劣" class="headerlink" title="索引优劣"></a>索引优劣</h4><ul><li>优势<ul><li>索引大大减少了存储引擎需要扫描的数据量</li><li>索引可以帮助我们进行排序以避免使用临时表</li><li>索引可以把随机I/O变为顺序I/O</li></ul></li><li>劣势<ul><li>索引会增加写操作的成本</li><li>太多索引会增加查询优化器的选择时间</li></ul></li></ul><h4 id="索引优化策略"><a href="#索引优化策略" class="headerlink" title="索引优化策略"></a>索引优化策略</h4><ul><li><p>索引列上不能使用表达式或函数</p></li><li><p>前缀索引和索引列的选择性</p><pre class=" language-mysql"><code class="language-mysql">CREATE INDEX index_name ON table(col_name(n));# 索引的选择性是不重复的索引值和表的记录数的比值</code></pre></li><li><p>联合索引</p><ul><li>如何选择索引列的顺序<ul><li>经常会被使用到的列优先</li><li>选择性高的列优先</li><li>宽度小的列优先</li></ul></li></ul></li><li><p>覆盖索引</p><ul><li>优点：<ul><li>可以优化缓存，减少磁盘IO操作</li><li>可以减少随机IO，变随机IO操作变为顺序IO操作</li><li>可以避免对Innodb主键索引的二次查询</li><li>可以避免MyISAM表进行系统调用</li></ul></li><li>无法使用覆盖索引的情况<ul><li>存储引擎不支持覆盖索引</li><li>查询中使用了太多的列</li><li>使用了双%%号的like查询</li></ul></li></ul></li></ul><ul><li><p>使用索引扫描来优化排序</p><ul><li>通过排序操作</li><li>按照索引顺序扫描数据</li><li>索引的列顺序和Order By子句的顺序完全一致</li><li>索引中所有列的放行（升序，降序）和Order by子句完全一致</li><li>Order by中的字段全部在关联表中的第一张表中</li></ul></li><li><p>使用索引优化锁</p><ul><li>索引可以减少锁定的行数</li><li>索引可以加快处理速度，同时也加快了锁的释放</li></ul></li><li><p>索引的维护和优化</p><ul><li>删除重复和冗余的索引<ul><li>primary key(id),unique key(id),index(id) -&gt; primary key(id)</li><li>index(a),index(a,b) -&gt; index(a,b)</li><li>primary key(id),index(a,id) -&gt; primary key(id),index(a)</li></ul></li><li>pt-duplicate-key-checker h=127.0.0.1 查询是否有冗余索引</li><li>查找未被使用过的索引</li></ul></li></ul><ul><li>更新索引统计信息及减少索引碎片<ul><li>analyze table table_name</li><li>optimize table table_name</li></ul></li></ul><h3 id="SQL查询优化"><a href="#SQL查询优化" class="headerlink" title="SQL查询优化"></a>SQL查询优化</h3><h4 id="获取有性能问题的SQL"><a href="#获取有性能问题的SQL" class="headerlink" title="获取有性能问题的SQL"></a>获取有性能问题的SQL</h4><ul><li>通过用户反馈获取存在性能问题的SQL（比较被动）</li><li>通过慢查日志获取存在性能问题的SQL</li><li>实时获取存在性能问题的SQL</li></ul><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><ul><li>开销<ul><li>磁盘IO<ul><li>顺序写入的，对大部分情况来说可以忽略不计</li></ul></li><li>存储日志所需要的磁盘空间<ul><li>主要要考虑存储日志所需要的大量的磁盘空间</li></ul></li></ul></li><li>语句<ul><li>slow_query_log 启动停止记录慢查日志<ul><li>ON为开启</li><li>set global</li><li>可以通过脚本定时开关参数</li></ul></li><li>slow_query_log_file 制定慢查日志的存储路径及文件<ul><li>默认情况下保存在MySQL的数据目录中</li><li>日志存储和数据存储分开存储</li></ul></li><li>long_query_time 制定记录慢查日志SQL执行时间的伐值<ul><li>默认值为10秒，最低到微秒，如果是100微秒 则要表达为 0.0001</li><li>一般设置为0.001秒 ，一毫秒比较合适</li></ul></li><li>log_queries_not_using_indexes 是否记录未使用索引的SQL</li></ul></li></ul><script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({ "model": { jsonPath:"https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json","scale": 1 }, "display": { "position": "right","width": 100, "height": 200,"hOffset": 0, "vOffset": -20 }, "mobile": { "show": true, "scale": 0.5 },"react": { "opacityDefault": 0.7, "opacityOnHover": 0.2 } });</script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 关系型数据库 </tag>
            
            <tag> MySQL优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM</title>
      <link href="/2019/12/26/shen-ru-li-jie-jvm/"/>
      <url>/2019/12/26/shen-ru-li-jie-jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解Java虚拟机"><a href="#深入理解Java虚拟机" class="headerlink" title="深入理解Java虚拟机"></a>深入理解Java虚拟机</h1><h2 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h2><h3 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h3><img src="/2019/12/26/shen-ru-li-jie-jvm/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" class="" title="JVM体系结构图"><h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><ul><li><p>线程私有的：</p><ul><li>程序计数器  不会抛OOM<ul><li>通过改变计数器的值执行分支、循环、跳转、线程恢复等基础功能</li></ul></li><li>虚拟机栈（局部变量表部分<ul><li>执行时创建栈帧储存局部变量表、操作栈、动态链接、方法出口等</li></ul></li><li>本地方法栈 主要是Native方法相关</li></ul></li><li><p>线程共享的</p><ul><li><p>Java堆 最大的一块，涉及各类GC算法</p><ul><li><p>新生代</p><p>Eden、From Survivor、To survivor</p></li><li><p>老年代</p></li></ul></li><li><p>方法区 储存虚拟机加载的类信息、常量、静态方法、字段描述、方法描述、即时编译器编译后的代码等</p><ul><li><p>JDK1.7后，字符串常量池从方法区移出</p></li><li><p>低版本HotSpot虚拟机未对此区域进行完全的回收导致过内存泄漏</p></li><li><p>运行时常量池属于方法区的一部分，编译期生成的字面量和符号引用将在类加载后放入方法区的运行时常量池中，同时运行时也可以向常量池中添加常量，如String类中的intern()方法</p></li></ul></li></ul></li></ul><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><ul><li>不属于JVM运行时数据区，也不属于JVM规定的JMM</li></ul><h4 id="Hotspot"><a href="#Hotspot" class="headerlink" title="Hotspot"></a>Hotspot</h4><ul><li><p>对象内存布局</p><ul><li><p>对象头</p><ol><li><p>储存对象自身的运行时数据</p><p>如HashCode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳</p></li><li><p>类型指针</p><p>指向对象对应的类型</p></li></ol></li><li><p>实例数据</p><p>储存程序代码中所定义的各种类型的字段内容</p></li><li><p>对齐填充</p></li></ul></li><li><p>对象的访问定位</p><ul><li><p>使用句柄</p><p>在堆中建立句柄池，存储对象实例数据地址和类型数据地址</p></li><li><p>直接指针</p><p>在堆中对象放置访问类型数据的指针</p></li></ul></li></ul><h3 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h3><h4 id="判断对象已“死”的方法"><a href="#判断对象已“死”的方法" class="headerlink" title="判断对象已“死”的方法"></a>判断对象已“死”的方法</h4><ul><li><p>引用计数法</p></li><li><p>可达性分析算法</p><blockquote><p>根搜索算法：（Java C#使用</p></blockquote><p>可作为GC Roots的对象：</p><ul><li>虚拟机栈中(栈帧中的本地变量表)引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>方法中的常量引用的对象</li><li>本地方法栈中JNI（即Native方法）引用的对象</li></ul></li><li><p>四种引用类型</p><ul><li><p>强引用</p><p>程序代码之中普遍存在的类似Object obj=new Object()，强引用还存在则不进行回收我们平常大部分使用的场景都是使用了强引用，比如new创建对象，反射获得一个对象等。</p></li><li><p>软引用</p><p>描述还有用但非必需的对象，在OOM之前将对其进行回收 SoftReference实现这种可用于那种有可能会在创建后使用的对象，不过为了内存消耗会选择使用软引用，比如缓存。</p></li><li><p>弱引用 </p><p>生存时间仅到下一次垃圾手机发生之前 WeakReference，弱引用用于生命周期更短的，对内存更敏感的场景中，比如占用内存很大的Map，java api中就提供了WeakHashMap使用，就会是的大Map被及时清理掉。</p></li><li><p>虚引用 </p><p>回收时得到一个系统通知PhantomReference，判断一个对象是否被垃圾回收了</p></li></ul></li><li><p>被回收的确认</p><ul><li>首先通过GC Roots进行可达性分析，如果没有可达的GC Roots，标记为可进行finalize()加入F-Queue，</li><li>稍后对F-Queue进行第二次分析，有可达的GC Roots则清除出队列，若没有，进行回收</li></ul></li><li><p>回收方法区（或回收HotSpot虚拟机中的永久代</p><ul><li><p>废弃常量</p></li><li><p>无用的类</p><ul><li>该类的所有实例被回收</li><li>加载该类的所有ClassLoader被回收</li><li>该类对应的Class对象没有被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>满足以上则<strong>可以但不一定</strong>被回收，而对象则是满足条件就一定会被回收</p></li></ul></li></ul><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul><li>标记清除法：效率不高，大量内存碎片</li><li>复制算法 eden区8，Suvivor1，to1，复制替换时哪个为空则为to，from区to区反转替换</li><li>标记整理算法 </li><li>分代收集算法：即新生代用复制算法，对象生存周期长的老年代用标记清除/整理法</li></ul><h4 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h4><ul><li>枚举根节点<ul><li>使用OopMap，HotSpot在类加载完成的时候就把对象内各个数据类型计算出来，JIT也会记录栈和寄存器标记引用</li></ul></li><li>安全点<ul><li>OopMap可能变化，则在方法调用、循环跳转、异常跳转等位置设置安全点，通过主动式中断</li></ul></li><li>安全区域<ul><li>保证区域内不会发生引用关系变化，任何位置进行GC都是安全的</li></ul></li></ul><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul><li><p>Serial收集器</p><ul><li>单线程，且需要暂停所有其他进程来进行收集，简单高效，Client模式的VM应用较好</li></ul></li><li><p>ParNew收集器</p><ul><li>多线程版本的Serial，二以上的多线程下将优于前者，Server模式的VM首选</li></ul></li><li><p>Parallel Scavenge收集器</p><ul><li>着重于吞吐量（即用户运行时间占比），高吞吐量则CPU</li><li>设置-Xmx最大堆，然后通过MaxGCPauseMillis参数或GCTimeRatio参数设置吞吐量优化目标，具体调节由VM完成</li></ul></li><li><p>Serial Old收集器</p><ul><li>用于配合PS收集器或CMS收集器的后备预案</li></ul></li><li><p>Parallel Old收集器</p><ul><li>使用多线程和标记整理算法 配合PS收集器，用于对吞吐量和CPU资源敏感的场合</li></ul></li><li><p>CMS收集器 以获取最短回收停顿时间为目标，应用于互联网站上或B/S系统的服务端上</p><ul><li>运行过程<ul><li>初始标记 STW 标记GC Roots直接关联的对象</li><li>并发标记 进行GC Roots Tracing</li><li>重新标记 STW 标记因继续运作变动的标记记录</li><li>并发清除</li></ul></li><li>并发收集低停顿</li><li>缺点：<ul><li>对CPU资源敏感</li><li>无法处理浮动垃圾，可能出现Concurrent Mode Failure导致另一次Full GC，可<strong>适当</strong>调高-XX CMSInitiatingOccupancyFraction进行启动碎片整理</li><li>大量空间碎片，可通过-XX CMSFullGCsBeforeCompaction设置多少次执行一次带压缩整理的Full GC</li></ul></li></ul></li><li><p>G1收集器 Garbage-First</p><ul><li><p>特点</p><ul><li><p>并行与并发</p><p>通过并发的方式缩短STW的时间</p></li><li><p>分代收集</p><p>不必搭配其他收集器，对新创建的和旧的对象采取不同方式，收集效果更好</p></li><li><p>空间整合</p><p>整体而言看起来采用标记整理法，而在局部两个Region之间采用复制算法，不会产生内存碎片</p></li><li><p>可预测的停顿</p><p>使用者明确指定时间内垃圾回收不得超过固定ms</p></li></ul></li><li><p>原理</p><ul><li><p>建立CardTable维护Region，表中每个Entry占512byte的空间，对应内存空间改变则标记对应的块为dirty</p></li><li><p>每个分区维护Remember Set(可理解为C实现的HashTable)记录相互之间的引用，存储指向CardTable对应Entry的变量，因此可以找到对应的内存区域</p></li><li><p>G1过程中的Write Barrier</p><p>非并发编程中的同名概念，此处为JVM在每次在对象映射赋值操作时记录指针变化的一段代码，每次引用变化都将DirtyCard加入到DirtyCardQueue中，queue标记为白绿黄红，白色未标记区域时不采取操作，绿色时启用优化线程开始更新到RememberSet，黄色启用全部优化线程更新到RememberSet，红色则加入应用线程参与更新任务（降低了应用线程修改的频率</p></li><li><p>Humongous区域</p><p>在G1中，还有一种特殊的区域，叫Humongous区域。如果一个对象占用的空间达到或者超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。</p></li></ul></li><li><p>执行流程</p><ol><li>初始标记 进行一次YoungGC</li><li>并发标记 类似CMS</li><li>最终标记 记录变动标记到Remember Set</li><li>筛选回收 根据用户配置进行回收</li></ol></li><li><p>深层执行原理</p><p>一. YoungGC</p><ol><li>STW整个堆</li><li>决定回收Eden和Survivor</li><li>扫描GC Roots</li><li>清空DirthCardQueue并更新Remember Set</li><li>扫描RememberSet找到哪些对象被老年代所引用</li><li>进行复制，Eden-&gt;Survivor</li><li>处理虚软弱引用</li></ol><p>二.OldGC</p><ol><li>STW进行YoungGC</li><li>恢复线程</li><li>进行并发初始标记</li><li>STW进行重新标记，并直接回收垃圾</li><li>最后处理虚软弱引用</li></ol><p>三.MixGC 同YoungGC</p></li></ul></li><li><p>ZGC</p><p>特性</p><ul><li><p>Colored pointer</p><p>在对象的引用中借用几个bit存储额外状态标记，Load Barrier会根据这些状态标记执行不同的逻辑</p></li><li><p>Load Barrier</p><p>加载屏障：在应用线程从堆中加载对象应用后，执行的一段逻辑，跟CPU中的内存屏障（Memory barrier）完全没有关联</p></li><li><p>Single generation</p><p>目前ZGC没有分代，每次GC都会标记整个堆</p></li><li><p>Page Allocation</p><p>将堆分为 2M（small）, 32M（medium）, n*2M（large）三种大小的页面（Page）来管理，根据对象的大小来判断在那种页面分配</p></li><li><p>Partial compaction</p><p>在relocation阶段将Page中活的对象转移到另一个Page，并整个回收原Page。会根据一定算法选择部分Page进行整理。</p></li><li><p>Mostly Concurrent</p><p>大部分对象标记和对象转移都是可以和应用线程并发。只会在以下阶段会发生stop-the-world</p><ol><li>GC开始时对root set的标记时</li><li>在标记结束的时候，由于并发的原因，需要确认所有对象已完成遍历，需要进行暂停</li><li>在relocate root-set 中的对象时</li></ol></li></ul></li><li><p>GC日志</p></li></ul><h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><ul><li>大多数情况，对象在Eden区分配，分配失败则MinorGC</li><li>大对象直接进入老年代</li><li>长期存活的对象进入老年代，经历一次MinorGC年龄增加1，通过-XX:MaxTenuringThreshold=15来设置进入老年代的年龄</li><li>动态年龄判断，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，则大于等于的部分直接进入老年代</li><li>空间分配担保，进入老年代的对象是否能够分配，能则MinorGC否则FullGC，其中担保是去平均估计</li></ul><h3 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h3><h4 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h4><blockquote><p>调用tool.jar执行</p></blockquote><ul><li>jps虚拟机进程状况工具<ul><li>列出正在运行的虚拟机进程并显示虚拟机执行主类名称、以及这些进程的本地虚拟机唯一ID</li><li>命令格式<ul><li>jps [options] [hostid]</li><li>-m 输出传递给main的参数</li><li>-l 输出主类全名，jar包则带路径</li><li>-v 输出对应的JVM参数</li></ul></li></ul></li><li>jstat虚拟机统计信息监视工具<ul><li>监视虚拟机各种运行状态信息，显示虚拟机进程中的类装载、内存、垃圾收集、JIT编译等</li><li>命令格式<ul><li>jstat [options] [hostid]</li><li>-class 查看类装载</li><li>-gc 查看堆状况包括 Eden、两个survivor、老年代、永久代的容量和已用空间等</li></ul></li></ul></li><li>jinfo配置信息工具<ul><li>实时查看和调整虚拟机各项参数，可以查看隐式</li><li>命令格式 <ul><li>jinfo [options] pid</li><li>-flag查看默认配置</li></ul></li></ul></li><li>jmap内存映像工具<ul><li>生成堆转储存快照</li><li>命令格式<ul><li>-dump转储快照</li><li>-finalizerinfo查看F-Queue对象</li><li>-heap查看堆详细信息</li></ul></li></ul></li><li>jhat堆快照分析工具</li><li>jstack堆栈跟踪工具<ul><li>可以进行死锁执行分析</li></ul></li><li>HSDIS JIT生成代码反汇编</li></ul><h4 id="JDK可视化工具"><a href="#JDK可视化工具" class="headerlink" title="JDK可视化工具"></a>JDK可视化工具</h4><ul><li>JConsole<ul><li>内存监控 相当于jstat</li><li>线程监控 相当于jstack</li></ul></li><li>VisualVM<ul><li>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）</li><li>监视应用程序的CPU、GC、堆、方法区以及线程的信息（jstat、jstack） </li><li>dump以及分析堆转储快照（jmap、jhat）</li><li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法</li><li>离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈</li></ul></li></ul><h3 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h3><p>…</p><h2 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h2><h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><h4 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h4><table><thead><tr><th><strong>类型</strong></th><th><strong>名称</strong></th><th><strong>数量</strong></th></tr></thead><tbody><tr><td>u4</td><td>magic</td><td>1</td></tr><tr><td>u2</td><td>minor_version</td><td>1</td></tr><tr><td>u2</td><td>major_version</td><td>1</td></tr><tr><td>u2</td><td>constant_pool_count</td><td>1</td></tr><tr><td>cp_info</td><td>constant_pool</td><td>constant_pool_count - 1</td></tr><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>this_class</td><td>1</td></tr><tr><td>u2</td><td>super_class</td><td>1</td></tr><tr><td>u2</td><td>interfaces_count</td><td>1</td></tr><tr><td>u2</td><td>interfaces</td><td>interfaces_count</td></tr><tr><td>u2</td><td>fields_count</td><td>1</td></tr><tr><td>field_info</td><td>fields</td><td>fields_count</td></tr><tr><td>u2</td><td>methods_count</td><td>1</td></tr><tr><td>method_info</td><td>methods</td><td>methods_count</td></tr><tr><td>u2</td><td>attribute_count</td><td>1</td></tr><tr><td>attribute_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><ul><li><p>魔数与版本号</p><ul><li>CAFE BABE标识为Java的Class文件，4字节，版本号 4字节</li></ul></li><li><p>常量池</p><p>u2类型数据标识常量池容量计数值</p><ul><li><p>字面量</p><ul><li>字面量较接近于 Java 语言层面的常量概念，如文本字符串、声明为 final 的常量值等</li></ul></li><li><p>符号引用</p><ul><li>类和接口的全限定名 </li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li><li><p>具体项目</p><img src="/2019/12/26/shen-ru-li-jie-jvm/%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%BB%93%E6%9E%84%E6%80%BB%E8%A1%A8.png" class="" title="常量池结构总表"></li></ul></li><li><p>访问标志</p><ul><li>用于识别类或者接口层次的访问信息</li></ul></li><li><p>类、父类、接口索引集合</p><ul><li>父类索引除Object均不为0</li><li>接口索引包含计数器和索引</li></ul></li><li><p>字段表集合：描述接口于类中声明的变量</p><p><a href="http://www.pianshen.com/article/3962206700/" target="_blank" rel="noopener">http://www.pianshen.com/article/3962206700/</a></p></li><li><p>方法表集合</p><p>类似字段表，但方法表的代码放置到“Code”属性表中</p></li><li><p>属性表集合</p><ul><li><p>虚拟机规范预定义的属性</p><ol><li><p>Code属性</p><p>Code 属性是 Class 文件中最重要的一个属性，如果把一个 Java 程序中的信息分为代码(Code ，方法体里面的 Java代码)和元数据(Metadata ，包括类、字段、方法定义及其他信息)两部分，那么在整个 class 文件中， Code 属性用于描述代码，所有的其它数据项目都用于描述元数据</p></li><li><p>Exceptions 属性</p></li><li><p>LineNumberTable 属性</p><p>用于描述 Java 源码行号与字节码行号（字节码的偏移 ）之间的对应关系</p></li><li><p>LocalVariableTable 属性</p><p>用于描述栈帧中局部变量表中的变量与 Java 源码中定义的变量之间的关系</p></li><li><p>SourceFile属性</p></li><li><p>ConstantValue属性</p><p>通过此属性标识static变量</p></li><li><p>InnerClasses属性</p><p>记录内部类与宿主类的关联</p></li><li><p>Deprecated与Synthetic属性</p></li><li><p>StackMapTable属性</p></li><li><p>Signature属性</p><p>协助运行期泛型，保证Java反射API能够获取泛型类型</p></li><li><p>BootstrapMethods属性</p></li></ol></li></ul></li></ul><h4 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h4><h3 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h3><ul><li><p>类加载的时机</p><p>加载-&gt;验证-&gt;准备-&gt;（解析）-&gt;初始化-&gt;（使用）-&gt;卸载</p><p>括号外的部分必须按顺序完成</p></li><li><p>VM未规定何时类加载，但规定了何时必须进行初始化</p><ul><li>使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候、以及调用一个静态方法的时候</li><li>使用reflect包的方法堆类进行反射调用的时候，若未初始化，则触发</li><li>初始化一个类的时候，若父类没有初始化，则触发父类的初始化</li><li>虚拟机启动时，会初始化主类（包含main方法的）</li></ul></li><li><p>类与接口的区别：</p><p>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量〉才会初始化</p></li></ul><h4 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h4><ul><li><p>加载</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态储存结构转化为方法去的运行时数据结构</li><li>在Java堆中生成一个代表这个类的Class对象，作为方法区这些数据的访问入口</li></ul></li><li><p>验证</p><p>主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求</p><ul><li><p>文件格式验证</p><p>魔数、版本号、常量池是否有不支持的常量等</p></li><li><p>元数据验证</p><p>是否有父类、是否继承了不允许被继承的类等Java语言规范检查</p></li><li><p>字节码验证</p><p>保证字节码指令不会危害虚拟机安全</p></li><li><p>符号引用验证</p><p>符号引用中通过字符串描述的全限定类是否能找到对应的类</p><p>类、方法、字段和方法的访问性</p></li></ul></li><li><p>准备</p><p>准备阶段将类变量（static变量）内存分配，此时初始值为0，初始化后值才为给定值，仅当ConstantValue属性（final修饰）时，才直接初始化为给定值</p></li><li><p>解析</p><p>解析动作主要针对类或接口、 字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行</p><ul><li><p>符号引用</p><p>以一组符号来描述所引用的目标，引用的目标不一定已加载至内存中</p></li><li><p>直接引用</p><p>可以是直接指向目标的指针、相对偏移量或是一个间接定位到目标的句柄，使用后引用的目标必定在内存中存在</p></li><li><p>类和接口的解析</p><ol><li><p>非数组类型则将符号引用的全限定名传递给所处类的加载器去加载该类，过程出现异常则加载失败</p></li><li><p>数组类型则为数组则对每个进行以上过程</p></li><li><p>若以上过程未出异常则检测访问权限，若无权限则IllegalAccessError</p></li></ol></li><li><p>字段解析</p><p>首先，如果字段所属的类或接口本身包含与目标匹配的字段，则返回直接引用；否则若实现接口，将自顶向下递归查找接口及父接口；否则按继承关系搜索其父类；最后若查找失败则抛出NoSuchFieldError异常，若权限验证失败则IllegalAccessError异常</p></li><li><p>类方法解析</p><p>首先查找索引对应的是否接口，是则返回异常；进行匹配，成功则正常引用；否则在父类查找并直接引用；否则在实现的接口与父接口中递归查找，找到则抛出AbstractMethodError异常；否则抛出NoSuchMethodError异常</p></li><li><p>接口方法解析</p><p>首先查找索引对应的是否是类，实则返回异常；进行匹配，成功则直接引用；否则父接口中递归查找；否则查找失败抛出NoSuchMethodError异常</p></li></ul></li><li><p>初始化</p><p>此阶段开开始真正执行Java字节码，初始化阶段是执行类构造器&lt;clinit＞()方法的过程</p><ul><li>&lt;clinit&gt;()方法收集类中所有的类变量和静态语句块中的语句</li><li>父类的&lt;clinit&gt;()方法先执行，子类的&lt;clinit&gt;()页不需要显式的调用父类的方法</li><li>&lt;clinit&gt;()方法仅用于静态变量或静态代码块</li><li>虚拟机负责管理&lt;clinit&gt;()方法的多线程同步问题</li></ul></li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li><p>类在由不同的类加载器加载出来后，是两个独立的类，做对象所属检查不会判定为同一个</p></li><li><p>站在Java虚拟机的角度讲，只存在两种不同的类加载器</p><ul><li>启动类加载器C++实现，是虚拟机自身的一部分</li><li>所有其他类的加载器</li></ul></li><li><p>而站在开发人员角度则分为：</p><ul><li>启动类加载器BootstrapClassLoader： 将JAVA_HOME\lib中的，或者-Xbootclasspath参数所指定的路径中的类库加载到虚拟机内存，无法被Java程序直接引用</li><li>扩展类加载器ExtClassLoader： 负责加载JAVA_HOME\lib\ext中的或者系统变量java.ext.dirs指定的路径中的所有类库，开发者可直接使用</li><li>应用程序类加载器AppClassLoader 又系统类加载器 程序默认的类加载器</li></ul></li><li><p>双亲委派模型</p><p>当一个类收到了类加载的请求，委派父类加载器去完成，仅当父类加载器无法完成加载时，子加载器才尝试进行加载</p></li><li><p>破坏双亲委派模型</p><ul><li>线程上下文加载器</li><li>SPI机制</li></ul></li></ul><h3 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h3><h4 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h4><ul><li><p>局部变量表</p><p>通过Slot存放数据，64位VM需要通过补齐和补白与32位VM保持对外一致</p></li><li><p>操作数栈</p></li><li><p>动态连接</p><p>将常量池中指向方法的符号引用为参数，一部分类加载阶段或第一次使用时转化为直接引用，为静态解析，另一部分在运行时转化为直接引用，为动态连接</p></li><li><p>方法返回地址</p></li></ul><p>一般把动态连接、方法返回地址、附加信息归为栈帧信息</p><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><ul><li><p>解析 运行前便确定的调用版本，编译时必须确定的方法调用</p><ul><li>invokestatic 调用静态</li><li>invokespecial 调用实例构造器方法、私有方法和父类方法</li><li>invokevirtual 调用所有的虚方法</li><li>invokeinterface 调用接口方法，运行时确定实现此接口的对象</li></ul><p>静态、私有、实例构造器、父类方法+final方法为非虚方法，其他均为虚方法</p></li><li><p>分派</p><ul><li><p>静态分派</p><p><strong>重载方法的分派规则</strong></p><p>解析与分派并不是互斥的，static方法重载时可能先解析再静态分派</p></li><li><p>动态分派</p><p><strong>继承与实现关系中的重写方法分派规则</strong></p><p>invokevirtual指令运行</p><ol><li>找到操作数栈顶的第一个元素所指向的对象那个的实际类型</li><li>如果找到的实际类型与常量池中描述符和简单名称都相符，则访问权限检验，成功则返回直接引用，否则返回IllegalAccessError</li><li>否则按照继承关系堆实际类型的各个父类进行搜索验证</li><li>上述失败则AbstractMethodError</li></ol></li><li><p>单分派和多分派</p><p>Java的静态分派为多分派机制，而动态分派为单分派类型</p></li></ul><p>动态分派的实现与C++类似，虚方法表存放着方法的入口地址，若子类没有重写，则入口与父类一致，若重写了，则替换为子类的入口地址</p></li></ul><h4 id="字节码执行引擎"><a href="#字节码执行引擎" class="headerlink" title="字节码执行引擎"></a>字节码执行引擎</h4><ul><li>解释执行</li><li>基于栈的指令集与基于寄存器的指令集</li><li>基于栈的解释器执行过程</li></ul><h2 id="程序编译与代码优化"><a href="#程序编译与代码优化" class="headerlink" title="程序编译与代码优化"></a>程序编译与代码优化</h2><h3 id="编译期优化"><a href="#编译期优化" class="headerlink" title="编译期优化"></a>编译期优化</h3><h3 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h3><h4 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h4><ul><li><p>泛型与类型擦除</p><p>重载需要方法的描述符不是完全一致，C#通过类型膨胀实现泛型而Java是类型擦除</p></li><li><p>自动装箱、拆箱与遍历循环</p></li><li><p>条件编译 </p><p>自动消除无法到达的语法分支，或直接编译不通过</p></li></ul><h3 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h3><ul><li>即时编译器</li><li>编译优化技术<ul><li>公共子表达式消除</li><li>数组边界检查消除</li><li>方法内联</li><li>逃逸分析</li></ul></li></ul><h2 id="高效并发"><a href="#高效并发" class="headerlink" title="高效并发"></a>高效并发</h2><h3 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h3><h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><ul><li><p>主内存和工作内存</p></li><li><p>内存间交互操作</p><ul><li>lock 作用于主内存的变量，把一个变量标识为一条线程独占的状态</li><li>unlock 作用于主内存的变量，把一个锁定的变量释放出来，释放后才可以被其他线程锁定</li><li>read 作用于主内存的变量，将一个变量的值传输至工作内存中</li><li>load 作用于工作内存的变量，将read操作从主内存中得到的变量值放入工作内存的变量副本</li><li>use 作用于工作内存的变量，将工作内存变量的值传递给执行引擎</li><li>assign 作用于工作内存的变量，将执行引擎收到的值赋给工作内存中对应的变量</li><li>store 作用于工作内存的变量，将值传送给主内存</li><li>write 作用于主内存的变量，将store的变量值赋给主内存变量</li></ul><p>Java内存模型规则</p><ul><li>不允许read与load、store与write单独出现；即不允许主内存读取工作内存不接受或工作内存写回主内存不接受</li><li>不允许assign操作被丢弃 即工作内存变量改变后必须同步改变主内存</li><li>不允许线程无原因地将线程的工作内存同步回主内存</li><li>use与store之前必须经过assign与load，即变量只能再主内存中诞生</li><li>一个变量同一时刻只允许一条线程进行lock</li><li>对一个变量执行lock，将清空工作内存中此变量的值，使用前，需要重新load或assign</li><li>若未被lock不可unlock，且无法unlock其他线程锁住的变量</li><li>unlock之前，必须先把变量同步回主内存</li></ul></li><li><p>volatile的特殊规则</p><ul><li>在工作内存使用V前都必须先从主内存刷新最新的值，use与load、read相关联</li><li>工作内存每次修改V后都必须立刻同步回主内存中，即assign与store、write相关联</li><li>V不会被指令重排序优化，保证代码执行顺序与程序的顺序相同</li></ul></li><li><p>原子性、可见性与有序性</p><ul><li>原子性 八种操作由JMM保证原子性</li><li>可见性 volatile sychronized final均可实现可见性</li></ul></li><li><p>先行发生原则</p><ul><li>程序次序规则</li><li>管程锁定规则</li><li>volatile变量规则</li><li>线程启动规则</li><li>线程终止规则</li><li>线程中断规则</li><li>对象终结规则</li><li>传递性</li></ul></li></ul><h4 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h4><ul><li>线程的实现<ul><li>内核级线程</li><li>用户级线程</li><li>混合实现</li></ul></li><li>线程调度<ul><li>协同式</li><li>抢占式（Java使用</li></ul></li><li>状态转换<ul><li>新建</li><li>运行</li><li>无限期等待</li><li>限期等待</li><li>阻塞</li><li>结束</li></ul></li></ul><h3 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><blockquote><p>线程安全：当多个线程访问一个对象时，如果不用考v了这些线程在运行时环境的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的</p></blockquote><ul><li><p>Java中的线程安全</p><ul><li>不可变</li><li>绝对线程安全</li><li>相对线程安全（大部分的线程安全类</li><li>线程兼容</li><li>线程对立（避免出现</li></ul></li><li><p>线程安全的实现方法</p><ul><li><p>互斥同步</p><ul><li>临界区</li><li>互斥量</li><li>信号量</li></ul><p>Java常用的互斥同步由synchronized和重入锁ReentrantLock</p><p>Reentrant高级特性</p><ul><li>等待可中断：当持有锁的进程长期不释放锁的时候，正在等待的进程可以选择放弃等待改为处理其他事情</li><li>公平锁</li><li>锁可以绑定多个条件</li></ul></li><li><p>非阻塞同步</p><p>依赖硬件指令集，例如</p><ul><li>Test-and-Set</li><li>Fetch-and-Increment</li><li>Swap</li><li>Compare-and-Swap</li><li>Load-Linked/Store-Conditional（加载链接/条件储存）</li></ul></li><li><p>无同步方案（对于天生同步的代码</p><ul><li>可重入代码</li><li>线程本地储存</li></ul></li></ul></li></ul><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><ul><li><p>自旋锁</p><ul><li>如果自旋超过了限定的次数仍然 没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是 10 次，用户 可以使用参数-XX:PreBlockSpin 来更改</li></ul></li><li><p>锁消除</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//此段代码将在javac编译后转换为StringBuffer操作，而后同步操作将被JVM优化</span><span class="token keyword">public</span> String <span class="token function">concatString</span><span class="token punctuation">(</span>String s1<span class="token punctuation">,</span>String s2<span class="token punctuation">,</span>String s3<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> s1<span class="token operator">+</span>s2<span class="token operator">+</span>s3<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>编译器运行时对代码加载的无必要同步措施进行消除</p></li><li><p>锁粗化</p><p>频繁加锁解锁则将锁范围扩展</p></li><li><p>轻量级锁</p><p>虚拟机对象头MarkWord</p><img src="/2019/12/26/shen-ru-li-jie-jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E5%A4%B4MarkWord.png" class="" title="虚拟机对象头MarkWord"><p>32bit空间中的 25bit 用于存储对象哈希码(HashCode), 4bit 用于存储对象分代年龄， 2bit 于存储锁标志位， 1bit 固定为0</p></li><li><p>偏向锁</p><p>消除数据在无竞争情况下的同步原语，提高运行性能</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java虚拟机 </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM&amp;JMM</title>
      <link href="/2019/12/20/jvm-jmm/"/>
      <url>/2019/12/20/jvm-jmm/</url>
      
        <content type="html"><![CDATA[<h2 id="类装载器"><a href="#类装载器" class="headerlink" title="类装载器"></a>类装载器</h2><p>负责加载class文件，将字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader只负责class文件的加载，至于它是否需要运行则由Execution Engine决定</p><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><ul><li>虚拟机自带的加载器</li><li>启动类加载器（Bootstrap）C++</li><li>扩展类加载器（Extension）Java</li><li>应用程序类加载器（AppClassLoader）Java<br>也叫系统类加载器，加载当前应用的classpath的所有类</li><li>用户自定义加载器<br>Java.lang.ClassLoader的子类，用户可以定制类的加载方式</li></ul><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><ul><li>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载</li><li>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象<img src="/2019/12/20/jvm-jmm/JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" class="" title="JVM体系结构图"></li></ul><h3 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h3><h2 id="本地接口"><a href="#本地接口" class="headerlink" title="本地接口"></a>本地接口</h2><ul><li>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序，Java 诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是 Native Method Stack中登记 native方法，在Execution Engine 执行时加载native libraies<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2></li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2></li><li>每个线程都有一个程序计数器，是线程私有的,就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。</li><li>这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>如果执行的是一个Native方法，那这个计数器是空的。</li><li>用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出(OutOfMemory=OOM)错误<br>##方法区</li><li>供各线程共享的运行时内存区域。它存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。以上指的是规范，在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)</li></ul><h2 id="Stack栈"><a href="#Stack栈" class="headerlink" title="Stack栈"></a>Stack栈</h2><ul><li><p>栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配</p></li><li><p>本地变量（Local Variables）<br>输入参数和输出参数以及方法内的变量</p></li><li><p>栈操作（Operand Stack）<br>记录出栈、入栈的操作</p></li><li><p>栈帧数据（Frame Data）<br>包括类文件、方法等等</p></li><li><p>HotSpot是使用指针的方式来访问对象，java堆中会存放访问类元数据的地址，reference储存的就是对象的地址</p><h2 id="Heap堆"><a href="#Heap堆" class="headerlink" title="Heap堆"></a>Heap堆</h2><blockquote><p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存逻辑上分为三部分</p></blockquote></li><li><p>Young Generatoni Space 新生区 Young/New</p></li><li><p>Tenure generation space 养老区 Old/Tenure</p></li><li><p>Permanent Space 永久区 Perm</p><h3 id="新生区"><a href="#新生区" class="headerlink" title="新生区"></a>新生区</h3></li><li><p>新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace） ，所有的类都是在伊甸区被new出来的。幸存区有两个： 0区（Survivor 0 space）/from区和1区（Survivor 1 space）/to区。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。若幸存 0区也满了，再对该区进行垃圾回收，然后移动到 1 区。那如果1 区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生MajorGC（FullGC），进行养老区的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”</p></li><li><p>如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二：<br>（1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。<br>（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p><h3 id="对象的声明周期"><a href="#对象的声明周期" class="headerlink" title="对象的声明周期"></a>对象的声明周期</h3></li><li><p>from区和to区的位置和名分不是固定的，每次GC后会有交换，谁空谁是to</p><img src="/2019/12/20/jvm-jmm/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84%E5%9B%BE.png" class="" title="内存空间结构图"></li><li><p>MinorGC的过程（复制-&gt;清空-&gt;互换）</p><ul><li>eden、SurvivorFrom 复制到 SurvivorTo，年龄+1<br>首先，当Eden区满的时候会触发第一次GC,把还活着的对象拷贝到SurvivorFrom区，当Eden区再次触发GC的时候会扫描Eden区和From区域,对这两个区域进行垃圾回收，经过这次回收后还存活的对象,则直接复制到To区域（如果有对象的年龄已经达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1</li><li>清空eden、SurvivorFrom<br>然后，清空Eden和SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to</li><li>SurvivorTo和SurvivorFrom互换<br>最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区。部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代</li></ul></li><li><p>实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开</p></li><li><p>对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代(Parmanent Gen)/元空间” ，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区(相当于是一个接口interface)的一个实现，jdk1.7的版本中，已经将原本放在永久代的字符串常量池移走</p><h3 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h3></li><li><p>永久存储区是一个常驻内存区域，用于存放JDK自身所携带的 Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存</p><h2 id="堆参数调优"><a href="#堆参数调优" class="headerlink" title="堆参数调优"></a>堆参数调优</h2></li></ul><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><ul><li>算法<ul><li>引用计数</li><li>复制算法<br>年轻代中的GC,主要是复制算法（Copying）<br>HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。<ul><li>优劣<br>吞吐量大，只需要遍历一次From空间Sweep需要遍历两次，而且只复制存活的对象；高速分配，不需要通过空闲链表直接在连续的内存上进行分配；没有碎片；与缓存兼容，复制存活对象时采用深度优先算法使相关联的对象都在附近<br>堆的使用效率低，必须分配一个To，其不能分配对象；不兼容保守式GC算法，需要移动对象；递归调用，复制对象的深度优先算法是通过递归调用实现的，递归将消耗栈等资源</li></ul></li><li>标记清除<ul><li>当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。主要进行两项工作，第一项则是标记，第二项则是清除。标记：从引用根节点开始标记遍历所有的GC Roots，先标记出要回收的对象。清除：遍历整个堆，把标记的对象清除。 </li><li>此算法需要暂停整个应用，两次扫描耗时长，会产生内存碎片 </li></ul></li><li>标记压缩（标记清除整理</li><li>总结<ul><li>年轻代特点是区域相对老年代较小，对像存活率低。<br>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li><li>老年代的特点是区域较大，对像存活率高。<br>这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。 </li><li>Mark阶段的开销与存活对像的数量成正比，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。Sweep阶段的开销与所管理区域的大小形正相关，但Sweep“就地处决”的特点，回收的过程没有对像的移动。使其相对其它有对像移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。Compact阶段的开销与存活对像的数据成开比，如上一条所描述，对于大量对像的移动是很大开销的，做为老年代的第一选择并不合适。<br>基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1></li></ul></li></ul></li><li>volatile 是Java虚拟机提供的轻量级的同步机制</li><li>JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（栈空间），工作内存是每个线程私有数据区域，而Java内存模型中规定所有变量都储存在主内存，主内存时共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等），不能直接操作主内存中的变量，各个线程中的工作内存中储存主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成</li></ul><script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({ "model": { jsonPath:"https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json","scale": 1 }, "display": { "position": "right","width": 100, "height": 200,"hOffset": 0, "vOffset": -20 }, "mobile": { "show": true, "scale": 0.5 },"react": { "opacityDefault": 0.7, "opacityOnHover": 0.2 } });</script>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发编程</title>
      <link href="/2019/12/12/java-gao-bing-fa/"/>
      <url>/2019/12/12/java-gao-bing-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程并发与线程安全"><a href="#多线程并发与线程安全" class="headerlink" title="多线程并发与线程安全"></a>多线程并发与线程安全</h1><p>笔记源课程：java并发编程与高并发解决方案</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>并发：多个线程操作相同的资源，保证线程安全，合理使用资源</li><li>高并发：服务能同时处理很多请求，提高程序性能</li></ul><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>CPU多级缓存：缓解CPU和内存之间速度的不匹配问题<ul><li>缓存一致性MESI 保证多个CPU cache之间缓存共享数据的一致<ul><li>M: 被修改（Modified)<br>该缓存行只被缓存在该CPU的缓存中，并且是被修改过的（dirty),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它CPU读取请主存中相应内存之前）写回（write back）主存。</li><li>E: 独享的（Exclusive)<br>该缓存行只被缓存在该CPU的缓存中，它是未被修改过的（clean)，与主存中数据一致。该状态可以在任何时刻当有其它CPU读取该内存时变成共享状态（shared)。同样地，当CPU修改该缓存行中内容时，该状态可以变成Modified状态，当被写回主存之后，该缓存行的状态会变成独享（exclusive)状态</li><li>S: 共享的（Shared)<br>该状态意味着该缓存行可能被多个CPU缓存，并且各个缓存中的数据与主存数据一致（clean)，当有一个CPU修改该缓存行中，其它CPU中该缓存行可以被作废（变成无效状态（Invalid））</li><li>I: 无效的（Invalid）<br>该缓存是无效的（可能有其它CPU修改了该缓存行）</li></ul></li><li>乱序执行优化：处理器为提高运行速度做出违背代码原有顺序的优化</li></ul></li></ul><img src="/2019/12/12/java-gao-bing-fa/MESI%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7.png" class="" title="MESI缓存一致性"><h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><ul><li>JMM规范：它规定了一个线程如何和何时能够看到由其他线程修改过后的共享变量值以及在必须时如何同步地访问共享变量</li></ul><img src="/2019/12/12/java-gao-bing-fa/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" class="" title="java内存模型"><ul><li>同步八种操作<ul><li>lock 作用于主内存的变量，把一个变量标识为一条线程独占状态</li><li>unlock 作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可已被其他线程锁定</li><li>read 作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>use 作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li><li>assign 作用于工作内存的变量，他把一个从执行引擎收到的值赋值给工作内存的变量</li><li>store 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write操作</li><li>write 作用于工作内存的变量，他把store操作从工作内存中一个变量的值传送到主内存的变量中</li></ul></li><li>同步规则<ul><li>不允许read和load、store和write单独出现。即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内从发起会写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步到主内存里。</li><li>不允许一个线程无原因地把数据从线程工作内存同步回主内存中，即没有发生过任何的assign操作就同步到主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个没有被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行assign和load操作。</li><li>一个变量在同一时刻，只允许一个线程对其进行lock操作，但lock操作可以被同一个线程重复执行多次，多次执行lock后，只有执行相同次数的unloack操作，变量才能被解锁。</li><li>如果对一个变量执行了lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，那就不允许对他执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）</li></ul></li></ul><img src="/2019/12/12/java-gao-bing-fa/%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C%E4%BA%8E%E8%A7%84%E5%88%99.jpg" class="" title="同步操作于规则"><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><ul><li><p>概念：<br>当多个线程访问某个类时，不管运行时环境采用何种调度方式，并且在主调代码中不需要额外的同步，这个类都能表现出正确的行为，那么这个类就是线程安全的</p></li><li><p>CAS底层原理</p></li></ul><blockquote><p>CAS是如何将比较和交换这两个操作，变成一个原子操作呢？这归功于硬件指令集的发展，实际上，我们可以使用同步将这两个操作变成原子的，但是这么做就没有意义了。所以我们只能靠硬件来完成，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成。这类指令常用的有：</p><ol><li>测试并设置（Tetst-and-Set）</li><li>获取并增加（Fetch-and-Increment）</li><li>交换（Swap）</li><li>比较并交换（Compare-and-Swap）</li><li>加载链接/条件存储（Load-Linked/Store-Conditional）</li></ol><p>其中，前三条原子指令在20世纪时，大部分处理器就已经有了，后面的两条指令是现代处理器新增的，而且这两条指令的目的和功能是类似的。在IA64，x86 指令集中有 <code>cmpxchg</code> 指令完成 CAS 功能，在 sparc-TSO 也有 <code>casa</code> 指令实现。<strong>需要注意的是：</strong>在 ARM 和 PowerPC 这种精简指令集的体系架构中，需要使用一对 <code>ldrex/strex</code> （“load and reserve”和“store conditional”）指令来完成 <code>LL/SC</code> 功能。</p><p>CPU 实现原子指令有2种方式：</p><ol><li>通过总线锁定来保证原子性：<ul><li>总线锁定其实就是处理器使用了总线锁，所谓总线锁就是使用处理器提供的一个 LOCK# 信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。但是该方法成本太大。因此有了下面的方式。</li></ul></li><li>通过缓存锁定来保证原子性：<ul><li>所谓 缓存锁定 是指内存区域如果被缓存在处理器的缓存行中，并且在Lock 操作期间被锁定，那么当他执行锁操作写回到内存时，处理器不在总线上声言 LOCK# 信号，而是修改内部的内存地址，并允许他的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域数据（这里和 volatile 的可见性原理相同），当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</li></ul></li></ol><p>注意：有两种情况下处理器不会使用缓存锁定：</p><ol><li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。</li><li>有些处理器不支持缓存锁定，对于 Intel 486 和 Pentium 处理器，就是锁定的内存区域在处理器的缓存行也会调用总线锁定。</li></ol></blockquote><ul><li><p>原子性<br>提供了互斥访问，同一时刻只能有一个线程来对它进行操作</p><ul><li>AtomicXXX：CAS U.weakCompareAndSetInt() 实现方式是通过循环判断底层值是否被其他线程进行了更改，若未更改则继续 由于更改失败情况下将循环判断，会浪费资源 适用于低并发下<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> v<span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token punctuation">{</span>v <span class="token operator">=</span> <span class="token function">getIntVolatile</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">weakCompareAndSetInt</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> v<span class="token punctuation">,</span> v <span class="token operator">+</span> delta<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> v<span class="token punctuation">;</span></code></pre></li><li>AtomicLong</li><li>LongAdder() <ul><li>核心是将热点数据分离，可以将AtomicLong的内部数据value分成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数，而最终计数结果为这个数组的求和累加。其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值，当前对象内value的实际值由所有的cell累积合成，从而使热点进行了有效的分离，提高了并行度。这样一来 LongAdder 相当于是在AtomicLong的基础上将单点的更新压力分散到各个节点上，在低并发的时候通过对base的直接更新，可以很好的保证和Atomic的性能基本一致，在高并发的场景，通过将热点分散来提高并行度。但在统计的时候如果有并发更新，可能会导致统计结果有些误差</li></ul></li><li>AtomicReference：CAS<pre><code>AtomicReference&lt;Integer&gt; count = new AtomicReference&lt;&gt;(0);count.compareAndSet(0, 2); // 2count.compareAndSet(0, 1); // nocount.compareAndSet(1, 3); // nocount.compareAndSet(2, 4); // 4</code></pre></li></ul></li></ul><ul><li><p>AtomicIntegerFieldUpdater</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicExample5</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span> AtomicIntegerFieldUpdater<span class="token operator">&lt;</span>AtomicExample5<span class="token operator">></span> updater <span class="token operator">=</span>AtomicIntegerFieldUpdater<span class="token punctuation">.</span><span class="token function">newUpdater</span><span class="token punctuation">(</span>AtomicExample5<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"count"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      AtomicExample5 example5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicExample5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>updater<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>example5<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"update success 1, {}"</span><span class="token punctuation">,</span> example5<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>updater<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>example5<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"update success 2, {}"</span><span class="token punctuation">,</span> example5<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"update failed, {}"</span><span class="token punctuation">,</span> example5<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><ul><li><p>AtomicStampReference </p><ul><li>CAS的ABA问题，解决思路是通过将版本号+1来计数判断，多了一个Stamp变量</li></ul></li><li><p>AtomicBoolean</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicExample6</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> AtomicBoolean isHappened <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicBoolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 请求总数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> clientTotal <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 同时并发执行的线程数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> threadTotal <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span>threadTotal<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>clientTotal<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> clientTotal <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"exception"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"isHappened:{}"</span><span class="token punctuation">,</span> isHappened<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isHappened<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"execute"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>Synchronize ：不可中断锁，适合竞争不激烈的情况，可读性好</p><ul><li>修饰代码块作用于调用的对象</li><li>修饰方法作用于调用的对象</li><li>修饰静态方法作用于所有对象</li><li>修饰类作用于所有对象</li></ul></li><li><p>Lock：可中断锁，多样化同步，竞争激烈时能维持常态</p></li><li><p>Atomic：竞争激烈时能维持常态，比Lock性能好，只能同步一个值</p></li></ul></li></ul><ul><li><p>可见性<br>一个线程对主内存的修改可以及时的被其他线程观察到</p><ul><li><p>导致共享变量在线程间不可见的原因</p><ul><li>线程交叉执行</li><li>重排序结合线程交叉执行</li><li>共享变量更新后的值没有在工作内存与主存间及时更新</li></ul></li><li><p>JMM关于synchronized规定</p><ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（加锁和解锁时同一把锁</li></ul></li><li><p>volatile </p><p>一般用于变量不依赖当前值，且变量没有包含在具有其他变量不必要的式子中，适合用于状态标记量</p><ul><li>对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存</li><li>对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量</li></ul></li></ul></li><li><p>有序性<br>一个线程观察其他线程中的指令执行顺序，由于指令重排的存在，该观察结果一般杂乱无序</p><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</p><ul><li><p>happens-before原则（先行发生原则）</p><p>如果两个操作的次序不能从这八种规则中推导出来，则不能保证有序性</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start() 方法先行发生于此线程的每一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束，可以通过Thread.isAlive()的返回值检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul></li></ul></li></ul><h2 id="安全发布对象"><a href="#安全发布对象" class="headerlink" title="安全发布对象"></a>安全发布对象</h2><ul><li><p>发布对象：使一个对象能够被当前范围之外的代码所使用，例如通过方法返回对象的引用，或者通过公有的静态变量发布对象</p></li><li><p>对象逸出：一种错误的发布，当一个对象还没有构造完成时，就使它被其他线程所见</p></li><li><p>不正确的发布可变对象导致的两种错误：</p><ul><li><p>发布线程意外的所有线程都可以看到被发布对象的过期的值</p></li><li><p>线程看到的被发布对象的引用是最新的，然而被发布对象的状态却是过期的</p></li></ul></li></ul><h3 id="四个线程安全策略"><a href="#四个线程安全策略" class="headerlink" title="四个线程安全策略"></a>四个线程安全策略</h3><ul><li>线程限制：一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改</li><li>共享只读：一个共享只读的对象，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它</li><li>线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保证线程安全，所以其他线程无需额外的同步就可以通过公共接口随意访问它</li><li>被守护对象：被守护对象只能通过获取特定的锁来访问</li></ul><h3 id="安全发布方法"><a href="#安全发布方法" class="headerlink" title="安全发布方法"></a>安全发布方法</h3><ul><li>在静态初始化函数中初始化一个对象的引用</li><li>将对象的引用保存到volatile类型域或者AtomicReference对象中</li><li>将对象的引用保存到某个正确构造对象的final类型域中</li><li>将对象的引用保存到一个由锁保护的域中</li></ul><h4 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h4><ul><li>final关键字<ul><li>修饰类：不能被继承（final类中的所有方法都会被隐式的声明为final方法）</li><li>修饰方法：<ul><li>锁定方法不被继承类修改；</li><li>可提升效率（private方法被隐式修饰为final方法）</li></ul></li><li>修饰变量：基本数据类型变量（初始化之后不能修改）、引用类型变量（初始化之后不能再修改其引用）</li><li>修饰方法参数：同修饰变量</li></ul></li><li>通常我们会使用一些工具类来完成不可变对象的创建：<ul><li>Collections.unmodifiableXXX：Collection、List、Set、Map…</li><li>Guava：ImmutableXXX：Collection、List、Set、Map…</li></ul></li></ul><h3 id="常见的线程不安全的类与写法"><a href="#常见的线程不安全的类与写法" class="headerlink" title="常见的线程不安全的类与写法"></a>常见的线程不安全的类与写法</h3><p>所谓线程不安全的类，是指该类的实例对象可以同时被多个线程共享访问，如果不做同步或线程安全的处理，就会表现出线程不安全的行为</p><ul><li><p>字符串拼接，在Java里提供了两个类可完成字符串拼接，就是StringBuilder和StringBuffer，其中StringBuilder是线程不安全的，而StringBuffer是线程安全的</p><ul><li>StringBuffer之所以是线程安全的原因是几乎所有的方法都加了synchronized关键字，所以是线程安全的。但是由于StringBuffer 是以加 synchronized 这种暴力的方式保证的线程安全，所以性能会相对较差，在堆栈封闭等线程安全的环境下应该首先选用StringBuilder</li></ul></li><li><p>SimpleDateFormat</p><ul><li>SimpleDateFormat 的实例对象在多线程共享使用的时候会抛出转换异常，正确的使用方法应该是采用堆栈封闭，将其作为方法内的局部变量而不是全局变量，在每次调用方法的时候才去创建一个SimpleDateFormat实例对象，这样利于堆栈封闭就不会出现并发问题。另一种方式是使用第三方库joda-time的DateTimeFormatter类(推荐使用)</li></ul></li><li><p>ArrayList, HashMap, HashSet 等 Collections 都是线程不安全的</p></li><li><p><strong>即便是线程安全的对象，在先检查后执行写法下也可能会出现线程不安全的行为</strong></p></li></ul><h3 id="单例模式与线程安全"><a href="#单例模式与线程安全" class="headerlink" title="单例模式与线程安全"></a>单例模式与线程安全</h3><h4 id="线程安全的懒汉式"><a href="#线程安全的懒汉式" class="headerlink" title="线程安全的懒汉式"></a>线程安全的懒汉式</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonExample5</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 私有构造函数</span>    <span class="token keyword">private</span> <span class="token function">SingletonExample5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 1、memory = allocate() 分配对象的内存空间</span>    <span class="token comment" spellcheck="true">// 2、ctorInstance() 初始化对象</span>    <span class="token comment" spellcheck="true">// 3、instance = memory 设置instance指向刚分配的内存</span>    <span class="token comment" spellcheck="true">// 单例对象 volatile + 双重检测机制 -> 禁止指令重排</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> SingletonExample5 instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 静态的工厂方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonExample5 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 双重检测机制        // B</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonExample5<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 同步锁</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonExample5</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// A - 3</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="线程安全的静态内部类"><a href="#线程安全的静态内部类" class="headerlink" title="线程安全的静态内部类"></a>线程安全的静态内部类</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonExample8</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">SingletonExample8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonExample8 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> LazyHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LazyHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> SingletonExample8 INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonExample8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="线程安全的枚举类"><a href="#线程安全的枚举类" class="headerlink" title="线程安全的枚举类"></a>线程安全的枚举类</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonExample7</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">SingletonExample7</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonExample7 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>        INSTANCE<span class="token punctuation">;</span>        <span class="token keyword">private</span> SingletonExample7 singleton<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// JVM保证这个方法绝对只调用一次</span>        <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonExample7</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> SingletonExample7 <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="线程安全手段"><a href="#线程安全手段" class="headerlink" title="线程安全手段"></a>线程安全手段</h2><h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><p>线程封闭最常见的应用就是用在数据库连接对象上，数据库连接对象本身并不是线程安全的，但由于线程封闭的作用，一个线程只会持有一个连接对象，并且持有的连接对象不会被其他线程所获取，这样就不会有线程安全的问题了</p><ul><li>概念：把对象封装到一个线程里，只有这个线程能看到这个对象。那么即便这个对象本身不是线程安全的，但由于线程封闭的关系让其只能在一个线程里访问，所以也就不会出现线程安全的问题了</li><li>实现方式：<ul><li>Ad-hoc 线程封闭：完全由程序控制实现，最糟糕的方式，忽略</li><li>堆栈封闭：局部变量，当多个线程访问同一个方法的时候，方法内的局部变量都会被拷贝一份副本到线程的栈中，所以局部变量是不会被多个线程所共享的，因此无并发问题。所以我们在开发时应尽量使用局部变量而不是全局变量</li><li>ThreadLocal 线程封闭：每个Thread线程内部都有个map，这个map是以线程本地对象作为key，以线程的变量副本作为value。而这个map是由ThreadLocal来维护的，由ThreadLocal负责向map里设置线程的变量值，以及获取值。所以对于不同的线程，每次获取副本值的时候，其他线程都不能获取当前线程的副本值，于是就形成了副本的隔离，多个线程互不干扰。所以这是特别好的实现线程封闭的方式</li></ul></li></ul><h3 id="同步容器简介"><a href="#同步容器简介" class="headerlink" title="同步容器简介"></a>同步容器简介</h3><ul><li><p>在Java中同步容器主要分为两类，一类是集合接口下的同步容器实现类</p><ul><li><p>List -&gt; Vector-&gt;Stack</p></li><li><p>Map -&gt; HashTable（key、value不能为null）</p></li><li><p>vector的所有方法都是有synchronized关键字保护的，stack继承了vector，并且提供了栈操作（先进后出），而hashtable也是由synchronized关键字保护</p><p>但是需要注意的是同步容器也并不一定是绝对线程安全的，例如有两个线程，线程A根据size的值循环执行remove操作，而线程B根据size的值循环执行执行get操作。它们都需要调用size获取容器大小，当循环到最后一个元素时，若线程A先remove了线程B需要get的元素，那么就会报越界错误</p></li></ul></li><li><p>第二类是Collections.synchronizedXXX (list,set,map)方法所创建的同步容器</p></li></ul><h3 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h3><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><ul><li><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。而在CopyOnWriteArrayList写的过程是会加锁的，即调用add的时候，否则多线程写的时候会Copy出N个副本出来</p><p>读的时候不需要加锁，但是如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList</p></li><li><p>CopyOnWriteArrayList容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题</p><ul><li><p>内存占用问题</p><p>因为CopyOnWriteArrayList的写操作时的复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</p><p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap</p></li><li><p>数据一致性问题</p><p>CopyOnWriteArrayList容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，即实时读取场景，那么请不要使用CopyOnWriteArrayList容器</p></li></ul></li><li><p>CopyOnWrite的应用场景</p><p>CopyOnWriteArrayList并发容器用于读多写少的并发场景。在数据较多的情况下，每次add/set都要重新复制数组，这个代价过于高昂。在高性能的互联网应用中，这种操作极易引起故障</p></li></ul><h5 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h5><p>CopyOnWriteArraySet是线程安全的，它底层的实现使用了CopyOnWriteArrayList，因此和CopyOnWriteArrayList概念是类似的。使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不可变的数组快照，所以迭代器不支持可变的 remove 操作</p><ul><li><p>CopyOnWriteArraySet适合于具有以下特征的场景</p><p>set 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突</p></li><li><p>CopyOnWriteArraySet缺点</p><p>因为通常需要复制整个基础数组，所以可变操作（add、set 和 remove 等等）的开销很大</p></li></ul><ul><li><p>TreeSet对应的ConcurrentSkipListSet</p><ul><li><p>ConcurrentSkipListSet是jdk6新增的类，它和TreeSet一样是支持自然排序的，并且可以在构造的时候定义<code>Comparator&lt;E&gt;</code> 的比较器，该类的方法基本和TreeSet中方法一样（方法签名一样）。和其他的Set集合一样，ConcurrentSkipListSet是基于Map集合的，ConcurrentSkipListMap便是它的底层实现</p><p>在多线程的环境下，ConcurrentSkipListSet中的contains、add、remove操作是安全的，多个线程可以安全地并发执行插入、移除和访问操作。但是对于批量操作 addAll、removeAll、retainAll 和 containsAll并不能保证以原子方式执行。理由很简单，因为addAll、removeAll、retainAll底层调用的还是contains、add、remove的方法，在批量操作时，只能保证每一次的contains、add、remove的操作是原子性的（即在进行contains、add、remove三个操作时，不会被其他线程打断），而不能保证每一次批量的操作都不会被其他线程打断。所以在进行批量操作时，需自行额外手动做一些同步、加锁措施，以此保证线程安全。另外，ConcurrentSkipListSet类不允许使用 null 元素，因为无法可靠地将 null 参数及返回值与不存在的元素区分开来。</p></li></ul></li></ul><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><ul><li>HashMap的并发安全版本是ConcurrentHashMap，但ConcurrentHashMap不允许 null 值。在大多数情况下，我们使用map都是读取操作，写操作比较少。因此ConcurrentHashMap针对读取操作做了大量的优化，所以ConcurrentHashMap具有很高的并发性，在高并发场景下表现良好</li></ul><h5 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h5><ul><li><p>ConcurrentSkipListMap的底层是通过跳表来实现的。跳表是一个链表，但是通过使用“跳跃式”查找的方式使得插入、读取数据时复杂度变成了O(logn)。Tips：有人曾比较过ConcurrentHashMap和ConcurrentSkipListMap的性能，在4线程1.6万数据的条件下，ConcurrentHashMap 存取速度是ConcurrentSkipListMap 的4倍左右。</p></li><li><p>ConcurrentSkipListMap有几个ConcurrentHashMap不能比拟的优点</p><ul><li>ConcurrentSkipListMap 的key是有序的</li></ul></li></ul><ul><li>ConcurrentSkipListMap 支持更高的并发。ConcurrentSkipListMap的存取时间是O(logn)，和线程数几乎无关。也就是说在数据量一定的情况下，并发的线程越多，ConcurrentSkipListMap越能体现出其优势<ul><li>在非多线程的情况下，应当尽量使用TreeMap。此外对于并发性相对较低的并行程序可以使用Collections.synchronizedSortedMap将TreeMap进行包装，也可以提供较好的效率。对于高并发程序，应当使用ConcurrentSkipListMap，能够提供更高的并发度。</li></ul></li><li>所以在多线程程序中，如果需要对Map的键值进行排序时，请尽量使用ConcurrentSkipListMap，可能得到更好的并发度。<ul><li>注意，调用ConcurrentSkipListMap的size时，由于多个线程可以同时对映射表进行操作，所以映射表需要遍历整个链表才能返回元素个数，这个操作是个O(log(n))的操作</li></ul></li></ul><h2 id="AQS容器"><a href="#AQS容器" class="headerlink" title="AQS容器"></a>AQS容器</h2><h3 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h3><blockquote><p>Java并发包（JUC）中提供了很多并发工具，如ReentrantLock、Semaphore，它们的实现都用到了一个共同的基类–AbstractQueuedSynchronizer（抽象队列同步器），简称AQS</p></blockquote><p>AQS是JDK提供的一套用于实现基于FIFO等待队列的阻塞锁和相关的同步器的一个同步框架，它使用一个int类型的volatile变量（命名为state）来维护同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p><p>AbstractQueuedSynchronizer中对state的操作是原子的，且不能被继承。所有的同步机制的实现均依赖于对改变量的原子操作。为了实现不同的同步机制，我们需要创建一个非共有的（non-public internal）扩展了AQS类的内部辅助类来实现相应的同步逻辑。</p><p>AbstractQueuedSynchronizer并不实现任何同步接口，它提供了一些可以被具体实现类直接调用的一些原子操作方法来重写相应的同步逻辑。AQS同时提供了独占模式（exclusive）和共享模式（shared）两种不同的同步逻辑。一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如ReadWriteLock。</p><p>使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。</p><p>同时，我们也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器，由此可知AQS是Java并发包中最为核心的一个基类。</p><ul><li><p>AbstractQueuedSynchronizer底层数据结构是一个双向链表，属于队列的一种实现</p><ul><li><p>sync queue：同步队列，其中head节点主要负责后面的调度</p></li><li><p>Condition queue：单向链表，不是必须的，只有程序中使用到Condition的时候才会存在，可能会有多个Condition queue</p></li></ul></li></ul><img src="/2019/12/12/java-gao-bing-fa/AbstractQueuedSynchronizer.jpg" class="" title="AbstractQueuedSynchronizer"><ul><li><p>关于AQS里的state状态</p><ul><li><p>AbstractQueuedSynchronizer维护了一个volatile int类型的变量，命名为state，用于表示当前同步状态。volatile虽然不能保证操作的原子性，但是保证了当前变量state的可见性</p></li><li><p>state的访问方式有三种：getState() setState() compareAndSetState()</p><p>这三种操作均是原子操作，其中compareAndSetState的实现依赖于Unsafe的compareAndSwapInt()方法</p></li></ul></li><li><p>资源自定义共享方式</p><ul><li>AQS支持两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。这样方便使用者实现不同类型的同步组件，独占式如ReentrantLock，共享式如Semaphore，CountDownLatch，组合式的如ReentrantReadWriteLock。总之，AQS为使用提供了底层支撑，如何组装实现，使用者可以自由发挥</li></ul></li><li><p>同步器设计 </p><p>同步器的设计是基于模板方法模式的，一般的使用方式是这样：</p><ul><li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li><li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。这其实是模板方法模式的一个很经典的应用。</li></ul><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在底层实现好了。自定义同步器实现时主要实现以下几种方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 该线程是否正在独占资源。只有用到condition才需要去实现它。</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</span></code></pre></li><li><p>使用</p><p>首先，我们需要去继承AbstractQueuedSynchronizer这个类，然后我们根据我们的需求去重写相应的方法，比如要实现一个独占锁，那就去重写tryAcquire，tryRelease方法，要实现共享锁，就去重写tryAcquireShared，tryReleaseShared；最后，在我们的组件中调用AQS中的模板方法就可以了，而这些模板方法是会调用到我们之前重写的那些方法的。也就是说，我们只需要很小的工作量就可以实现自己的同步组件，重写的那些方法，仅仅是一些简单的对于共享资源state的获取和释放操作，至于像是获取资源失败，线程需要阻塞之类的操作，自然是AQS帮我们完成了</p></li><li><p>具体实现</p><ul><li>首先AQS内部维护了一个CLH队列，来管理锁</li><li>线程尝试获取锁，如果获取失败，则将等待信息等包装成一个Node结点，加入到同步队列Sync queue里</li><li>不断重新尝试获取锁（当前结点为head的直接后继才会尝试），如果获取失败，则会阻塞自己，直到被唤醒</li><li>当持有锁的线程释放锁的时候，会唤醒队列中的后继线程</li></ul></li><li><p>设计思想</p><p>对于使用者来讲，我们无需关心获取资源失败，线程排队，线程阻塞/唤醒等一系列复杂的实现，这些都在AQS中为我们处理好了。我们只需要负责好自己的那个环节就好，也就是获取/释放共享资源state的姿势。很经典的模板方法设计模式的应用，AQS为我们定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现即可</p></li><li><p>基于AQS的同步组件</p><ul><li>CountDownLatch</li><li>Semaphore</li><li>CyclicBarrier</li><li>ReentrantLock</li><li>Condition</li><li>FutureTask</li></ul></li><li><p>总结</p><ul><li>使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架</li><li>利用了一个int类型表示状态，有一个state的成员变量，表示获取锁的线程数（0没有线程获取锁，1有线程获取锁，大于1表示重入锁的数量），和一个同步组件ReentrantLock。状态信息通过procted级别的getState，setState，compareAndSetState进行操作</li><li>使用方法是继承，然后复写AQS中的方法，基于模板方法模式</li><li>子类通过继承并通过实现它的方法管理其状态{acquire和release}的方法操作状态</li><li>可以同时实现排它锁和共享锁的模式（独占、共享）</li></ul></li></ul><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><ul><li><p>概念 CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有框架服务之后执行。</p></li><li><p>实现方式 CountDownLatch是通过一个计数器来实现的，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得减1。当计数器到达0时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务</p></li></ul><ul><li>CountDownLatch的构造函数源码</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">CountDownLatch</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"count &lt; 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>计数器count是闭锁需要等待的线程数量，只能被设置一次，且CountDownLatch没有提供任何机制去重新设置计数器count。</p><p>与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await()方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p><p>其他N个线程必须引用CountDownLatch闭锁对象，因为它们需要通知CountDownLatch对象，它们各自完成了任务；这种通知机制是通过CountDownLatch.countDown()方法来完成的；每调用一次，count的值就减1，因此当N个线程都调用这个方法，count的值就等于0，然后主线程就可以通过await()方法，恢复执行自己的任务</p><ul><li><p>CountDownLatch使用场景</p><ul><li>实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数器为1的CountDownLatch，并让其他所有线程都在这个锁上等待，只需要调用一次countDown()方法就可以让其他所有等待的线程同时恢复执行</li><li>开始执行前等待N个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统都已经启动和运行了</li><li>死锁检测：一个非常方便的使用场景是你用N个线程去访问共享资源，在每个测试阶段线程数量不同，并尝试产生死锁</li></ul></li><li><p>用例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchExample1</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> THREAD_COUNT <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        ExecutorService exec <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>THREAD_COUNT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> THREAD_COUNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> threadNum <span class="token operator">=</span> i<span class="token punctuation">;</span>            exec<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">test</span><span class="token punctuation">(</span>threadNum<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 为防止出现异常，放在finally更保险一些</span>                    countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"finish"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        exec<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadNum<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> threadNum<span class="token punctuation">)</span><span class="token punctuation">;</span>        TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><ul><li><p>主要作用</p><p>可以控制同一时间并发执行的线程数。Semaphore有两个构造函数，参数permits表示许可数，它最后传递给了AQS的state值。线程在运行时首先获取许可，如果成功，许可数就减1，线程运行，当线程运行结束就释放许可，许可数就加1。如果许可数为0，则获取失败，线程位于AQS的等待队列中，它会被其它释放许可的线程唤醒。在创建Semaphore对象的时候还可以指定它的公平性。一般常用非公平的信号量，非公平信号量是指在获取许可时先尝试获取许可，而不必关心是否已有需要获取许可的线程位于等待队列中，如果获取失败，才会入列。而公平的信号量在获取许可时首先要查看等待队列中是否已有线程，如果有则入列</p></li><li><p>使用场景</p><p>Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用Semaphore来做流控。</p></li></ul><img src="/2019/12/12/java-gao-bing-fa/Semaphore%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" class="" title="Semaphore继承关系"><ul><li><p>常用方法</p><pre class=" language-java"><code class="language-java">semaphore<span class="token punctuation">.</span><span class="token function">Acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>semaphore<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li></ul><img src="/2019/12/12/java-gao-bing-fa/tryAcquire%E6%96%B9%E6%B3%95.png" class="" title="tryAcquire方法"><ul><li><p>其他常用方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">availablePermits</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true">// 返回此信号量中当前可用的许可证数。</span><span class="token keyword">int</span> <span class="token function">getQueueLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token comment" spellcheck="true">// 返回正在等待获取许可证的线程数。</span><span class="token keyword">boolean</span> <span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">// 是否有线程正在等待获取许可证。</span><span class="token keyword">void</span> <span class="token function">reducePermits</span><span class="token punctuation">(</span><span class="token keyword">int</span> reduction<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 减少reduction个许可证。是个protected方法。</span>Collection <span class="token function">getQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 返回所有等待获取许可证的线程集合。是个protected方法。</span></code></pre></li><li><p>用例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreExample1</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> THREAD_COUNT <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService exec <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> THREAD_COUNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> threadNum <span class="token operator">=</span> i<span class="token punctuation">;</span>            exec<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 获取一个许可</span>                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>threadNum<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 释放一个许可</span>                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        exec<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><ul><li><p>概念</p><p>字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。当某个线程调用了await方法之后，就会进入等待状态，并将计数器-1，直到所有线程调用await方法使计数器为0，才可以继续执行，由于计数器可以重复使用，所以我们又叫他循环屏障</p><p>CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞</p></li></ul><img src="/2019/12/12/java-gao-bing-fa/CyclicBarrier.png" class="" title="CyclicBarrier"><ul><li><p>CyclicBarrier的应用场景</p><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个Excel保存了用户所有银行流水，每个Sheet保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水</p></li><li><p>CyclicBarrier和CountDownLatch的区别</p><ul><li>CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</li><li>CountDownLatch主要用于实现一个或n个线程需要等待其他线程完成某项操作之后，才能继续往下执行，描述的是一个或n个线程等待其他线程的关系，而CyclicBarrier是多个线程相互等待，知道满足条件以后再一起往下执行。描述的是多个线程相互等待的场景</li><li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断</li></ul></li><li><p>CyclicBarrier方法列表</p></li></ul><img src="/2019/12/12/java-gao-bing-fa/CyclicBarrier%E6%96%B9%E6%B3%95%E5%88%97%E8%A1%A8.png" class="" title="CyclicBarrier方法列表"><ul><li>基本使用</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierExample1</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 给定一个值，说明有多少个线程同步等待</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> CyclicBarrier barrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        ExecutorService exec <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">int</span> num <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 延迟1秒，方便观察</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            exec<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    CyclicBarrierExample1<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        exec<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">race</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} is ready"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 阻塞线程</span>        barrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} continue"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以防await无限阻塞进程，我们可以设置await的超时时间，修改race方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">race</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} is ready"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 由于设置了超时时间后阻塞的线程可能会被中断，抛出BarrierException异常，如果想继续往下执行，需要加上try-catch</span>        barrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> TimeoutException <span class="token operator">|</span> BrokenBarrierException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// isBroken方法用来知道阻塞的线程是否被中断</span>        log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"exception occurred {} {}. isBroken : {}"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> barrier<span class="token punctuation">.</span><span class="token function">isBroken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} continue"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果希望当所有线程到达屏障后就执行一个runnable的话，可以使用<code>CyclicBarrier(int parties, Runnable barrierAction)</code>构造函数传递一个runnable实例</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 当线程全部到达屏障时，优先执行这里传入的runnable */</span><span class="token keyword">private</span> <span class="token keyword">static</span> CyclicBarrier barrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"callback is running"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>在Java里一共有两类锁，一类是synchornized同步锁，还有一种是JUC里提供的锁Lock，Lock是个接口，其核心实现类就是ReentrantLock</p><ul><li>synchornized与ReentrantLock的区别</li></ul><table><thead><tr><th align="left">对比维度</th><th align="left">synchornized</th><th align="left">ReentrantLock</th></tr></thead><tbody><tr><td align="left">可重入性（线程进入锁的时候计数器就自增1，计数器下降为0则会释放锁）</td><td align="left">可重入</td><td align="left">可重入</td></tr><tr><td align="left">锁的实现</td><td align="left">JVM实现，很难操作源码</td><td align="left">JDK实现，可以观察其源码</td></tr><tr><td align="left">性能</td><td align="left">在引入偏向锁、轻量级锁/自旋锁后性能大大提升，官方建议无特殊要求时尽量使用synchornized，并且新版本的一些jdk源码都由之前的ReentrantLock改成了synchornized</td><td align="left">与优化后的synchornized相差不大</td></tr><tr><td align="left">功能区别</td><td align="left">方便简洁，由编译器负责加锁和释放锁</td><td align="left">需手工操作锁的加锁和释放</td></tr><tr><td align="left">锁粒度</td><td align="left">粗粒度，不灵活</td><td align="left">细粒度，可灵活控制</td></tr><tr><td align="left">可否指定公平锁</td><td align="left">不可以</td><td align="left">可以</td></tr><tr><td align="left">可否放弃锁</td><td align="left">不可以</td><td align="left">可以</td></tr></tbody></table><ul><li>ReentrantLock实现：<ul><li>采用自旋锁，循环调用CAS操作来实现加锁，避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核态的阻塞状态，是我们分析和理解锁设计的关键钥匙</li></ul></li><li>ReentrantLock独有的功能：<ul><li>可指定是公平锁还是非公平锁，所谓公平锁就是先等待的线程先获得锁</li><li>提供了一个Condition类，可以分组唤醒需要唤醒的线程</li><li>提供能够中断等待锁的线程的机制，<code>lock.lockInterruptibly()</code></li></ul></li></ul><p>在ReentrantLock中，对于公平和非公平的定义是通过对同步器AQS的扩展加以实现的，也就是在tryAcquire的实现上做了语义的控制。</p><p>这里提到一个锁获取的公平性问题，如果在绝对时间上，先对锁进行获取的请求一定被先满足，那么这个锁是公平的，反之，是不公平的，也就是说等待时间最长的线程最有机会获取锁，也可以说锁的获取是有序的。ReentrantLock这个锁提供了一个构造函数，能够控制这个锁是否是公平的。</p><p>而锁的名字也是说明了这个锁具备了重复进入的可能，也就是说能够让当前线程多次的进行对锁的获取操作，这样的最大次数限制是<code>Integer.MAX_VALUE</code>，约21亿次左右。</p><p>事实上公平的锁机制往往没有非公平的效率高，因为公平的获取锁没有考虑到操作系统对线程的调度因素，这样造成JVM对于等待中的线程调度次序和操作系统对线程的调度之间的不匹配。对于锁的快速且重复的获取过程中，连续获取的概率是非常高的，而公平锁会压制这种情况，虽然公平性得以保障，但是响应比却下降了，但是并不是任何场景都是以TPS作为唯一指标的，因为公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足</p><p>在ReentrantLock 中，<code>lock()</code>方法是一个无条件的锁，与synchronize意思差不多，但是另一个方法 <code>tryLock()</code>方法只有在成功获取了锁的情况下才会返回true，如果别的线程当前正持有锁，则会立即返回false。如果为这个方法加上timeout参数，则会在等待timeout的时间才会返回false或者在获取到锁的时候返回true</p><ul><li><p>用例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockExample2</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 请求总数     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> clientTotal <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 同时并发执行的线程数量     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> threadTotal <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 计数     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 锁对象，默认是使用非公平锁，可以传入true和false来决定使用公平所还是非公平锁     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Lock LOCK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span>threadTotal<span class="token punctuation">)</span><span class="token punctuation">;</span>        CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span>clientTotal<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> clientTotal<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 从信号量获取执行许可，若并发达到设定的数量，那么就不会获取到许可，将会阻塞当前线程，直到能够获取到执行许可为止</span>                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    LockExample2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 释放当前线程</span>                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"count: {}"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 加锁</span>        LOCK<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 解锁</span>            LOCK<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>其他常用方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">isHeldByCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 当前线程是否保持锁定</span><span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 是否存在任意线程持有锁资源</span><span class="token keyword">void</span> <span class="token function">lockInterruptbly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 如果当前线程未被中断，则获取锁定；如果已中断，则抛出异常(InterruptedException)</span><span class="token keyword">int</span> <span class="token function">getHoldCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 查询当前线程保持此锁定的个数，即调用lock()方法的次数</span><span class="token keyword">int</span> <span class="token function">getQueueLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 返回正等待获取此锁定的预估线程数</span><span class="token keyword">int</span> <span class="token function">getWaitQueueLength</span><span class="token punctuation">(</span>Condition condition<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 返回与此锁定相关的约定condition的线程预估数</span><span class="token keyword">boolean</span> <span class="token function">hasQueuedThread</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 当前线程是否在等待获取锁资源</span><span class="token keyword">boolean</span> <span class="token function">hasQueuedThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 是否有线程在等待获取锁资源</span><span class="token keyword">boolean</span> <span class="token function">hasWaiters</span><span class="token punctuation">(</span>Condition condition<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 是否存在指定Condition的线程正在等待锁资源</span><span class="token keyword">boolean</span> <span class="token function">isFair</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 是否使用的是公平锁</span></code></pre></li></ul><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>Condition是一个多线程间协调通信的工具类，使得某个，或者某些线程一起等待某个条件（Condition），只有当该条件具备( signal 或者 signalAll方法被调用)时 ，这些等待线程才会被唤醒，从而重新争夺锁</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockExample6</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 构建ReentrantLock实例</span>        ReentrantLock reentrantLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从reentrantLock实例里获取condition实例</span>        Condition condition <span class="token operator">=</span> reentrantLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 线程1</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 线程1调用了lock方法，这时线程1就会加入到了AQS的等待队里面去</span>                reentrantLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"wait signal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 等待信号</span>                <span class="token comment" spellcheck="true">// 调用await方法后，线程1就会从AQS队列里移除，这里其实就已经释放了锁，然后线程1会马上进入到condition队列里面去，等待一个信号</span>                condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"get signal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 4 得到信号</span>            <span class="token comment" spellcheck="true">// 线程1释放锁，整个过程执行完毕</span>            reentrantLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 线程2</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 由于线程1中调用了await释放了锁的关系，所以线程2就会被唤醒获取到锁，加入到AQS等待队列中</span>            reentrantLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"get lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 2 获取锁</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 睡眠3秒</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 调用signalAll发送信号的方法，此时condition等待队列里线程1所在的节点元素就会被取出，然后重新放到AQS等待队列里（注意此时线程1还没有被唤醒）</span>            condition<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"send signal ~ "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 3 发送信号</span>            <span class="token comment" spellcheck="true">// 线程2释放锁，这时候AQS队列中只剩下线程1，然后AQS会按照从头到尾的顺序唤醒线程，于是线程1开始执行</span>            reentrantLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>ReentrantReadWriteLock是Lock的另一种实现方式，我们已经知道了ReentrantLock是一个排他锁，同一时间只允许一个线程访问，而ReentrantReadWriteLock允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。在没有任何读写锁的时候才能取得写入的锁，可用于实现悲观读取。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时ReentrantReadWriteLock能够提供比排他锁更好的并发性和吞吐量，所以读写锁适用于读多写少的情况。但读多写少的场景下可能会令写入线程遭遇饥饿，即写入线程迟迟无法获取到锁资源而处于等待状态。</p><p>与互斥锁相比，使用读写锁能否提升性能则取决于读写操作期间读取数据相对于修改数据的频率，以及数据的争用——即在同一时间试图对该数据执行读取或写入操作的线程数。</p><p>读写锁内部维护了两个锁，一个用于读操作，一个用于写操作。所有 ReadWriteLock实现都必须保证 writeLock操作的内存同步效果也要保持与相关 readLock的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。</p><ul><li><p>ReentrantReadWriteLock支持功能</p><ul><li>非公平模式（默认）：连续竞争的非公平锁可能无限期地推迟一个或多个reader或writer线程，但吞吐量通常要高于公平锁</li><li>公平模式：线程利用一个近似到达顺序的策略来争夺进入。当释放当前保持的锁时，可以为等待时间最长的单个writer线程分配写入锁，如果有一组等待时间大于所有正在等待的writer线程的reader，将为该组分配读者锁。试图获得公平写入锁的非重入的线程将会阻塞，除非读取锁和写入锁都自由（这意味着没有等待线程）</li><li>支持可重入。读线程在获取了读锁后还可以获取读锁；写线程在获取了写锁之后既可以再次获取写锁又可以获取读锁</li><li>还允许从写入锁降级为读取锁，其实现方式是：先获取写入锁，然后获取读取锁，最后释放写入锁。但是，从读取锁升级到写入锁是不允许的</li><li>读取锁和写入锁都支持锁获取期间的中断</li><li>Condition支持。仅写入锁提供了一个 Conditon 实现；读取锁不支持 Conditon ，readLock().newCondition() 会抛出 UnsupportedOperationException</li><li>监测：此类支持一些确定是读取锁还是写入锁的方法。这些方法设计用于监视系统状态，而不是同步控制</li></ul></li><li><p>用例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockExample3</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Data<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantReadWriteLock readWriteLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Lock readLock <span class="token operator">=</span> readWriteLock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Lock writeLock <span class="token operator">=</span> readWriteLock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Data <span class="token function">get</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 读锁</span>        readLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            readLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">getAllKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 读锁</span>        readLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            readLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Data <span class="token function">put</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Data value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 在没有任何读写锁的时候才会进行写入操作</span>        writeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            writeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Data</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>StampedLock是Java8引入的一种新的锁机制，简单的理解，可以认为它是读写锁的一个改进版本，读写锁虽然分离了读和写的功能，使得读与读之间可以完全并发，但是读和写之间依然是冲突的，读锁会完全阻塞写锁，它使用的依然是悲观的锁策略。如果有大量的读线程，它也有可能引起写线程的饥饿。而StampedLock则提供了一种乐观的读策略，这种乐观策略的锁非常类似于无锁的操作，使得乐观锁完全不会阻塞写线程。</p><p>StampedLock控制锁有三种形式，分别是写，读，和乐观读，重点在乐观锁。一个StampedLock，状态是由版本和模式两个部分组成。锁获取的方法返回的是一个数字作为票据（Stamp），他用相应的锁状态来表示并控制相关的访问，数字0表示没有写锁被授权访问，在读锁上分为悲观读和乐观读。</p><p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量</p><ul><li><p>适用场景</p><p>乐观读取模式仅用于短时间读取操作时经常能够降低竞争和提高吞吐量。当然，它的使用在本质上是脆弱的。乐观读取的区域应该只包括字段，并且在validation之后用局部变量持有它们从而在后续使用。乐观模式下读取的字段值很可能是非常不一致的，所以它应该只用于那些你熟悉如何展示数据，从而你可以不断检查一致性和调用方法validate</p></li><li><p>优化点</p><ul><li>乐观读不阻塞悲观读和写操作，有利于获得写锁</li><li>队列头结点采用有限次数SPINS次自旋（增加开销），增加获得锁几率（因为闯入的线程会竞争锁），有效够降低上下文切换</li><li>读模式的集合通过一个公共节点被聚集在一起（cowait链），当队列尾节点为RMODE,通过CAS方法将该节点node添加至尾节点的cowait链中，node成为cowait中的顶元素，cowait构成了一个LIFO队列。</li><li>不支持锁重入，如果只悲观读锁和写锁，效率没有ReentrantReadWriteLock高。</li></ul></li><li><p>案例</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> StampedLock sl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StampedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">double</span> deltaX<span class="token punctuation">,</span> <span class="token keyword">double</span> deltaY<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// an exclusively locked method</span>        <span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            x <span class="token operator">+=</span> deltaX<span class="token punctuation">;</span>            y <span class="token operator">+=</span> deltaY<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            sl<span class="token punctuation">.</span><span class="token function">unlockWrite</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 乐观读锁案例</span>    <span class="token keyword">double</span> <span class="token function">distanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// A read-only method</span>        <span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">tryOptimisticRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//获得一个乐观读锁</span>        <span class="token keyword">double</span> currentX <span class="token operator">=</span> x<span class="token punctuation">,</span> currentY <span class="token operator">=</span> y<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将两个字段读入本地局部变量</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sl<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//检查发出乐观读锁后同时是否有其他写锁发生？</span>            stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//如果没有，我们再次获得一个读悲观锁</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                currentX <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将两个字段读入本地局部变量</span>                currentY <span class="token operator">=</span> y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将两个字段读入本地局部变量</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                sl<span class="token punctuation">.</span><span class="token function">unlockRead</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>currentX <span class="token operator">*</span> currentX <span class="token operator">+</span> currentY <span class="token operator">*</span> currentY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 悲观读锁案例</span>    <span class="token keyword">void</span> <span class="token function">moveIfAtOrigin</span><span class="token punctuation">(</span><span class="token keyword">double</span> newX<span class="token punctuation">,</span> <span class="token keyword">double</span> newY<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// upgrade</span>        <span class="token comment" spellcheck="true">// Could instead start with optimistic, not read mode</span>        <span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0.0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">==</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//循环，检查当前状态是否符合</span>                <span class="token keyword">long</span> ws <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">tryConvertToWriteLock</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将读锁转为写锁</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">!=</span> 0L<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//这是确认转为写锁是否成功</span>                    stamp <span class="token operator">=</span> ws<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如果成功 替换票据</span>                    x <span class="token operator">=</span> newX<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//进行状态改变</span>                    y <span class="token operator">=</span> newY<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//进行状态改变</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//如果不能成功转换为写锁</span>                    sl<span class="token punctuation">.</span><span class="token function">unlockRead</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//我们显式释放读锁</span>                    stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//显式直接进行写锁 然后再通过循环再试</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            sl<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//释放读锁或写锁</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>StampedLock 对吞吐量有巨大的改进，特别是在读线程越来越多的场景下。但StampedLock有一个复杂的API，对于加锁操作，很容易误用其他方法。StampedLock 可以说是Lock的一个很好的补充，吞吐量以及性能上的提升足以打动很多人了，但并不是说要替代之前Lock的东西，毕竟它还是有些应用场景的，起码API比StampedLock容易入手</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>synchronized：JVM实现，不但可以通过一些监控工具监控，而且在出现未知异常的时候JVM也会自动帮我们释放锁</li><li>ReentrantLock、ReentrantRead/WriteLock、StempedLock 他们都是对象层面的锁定，要想保证锁一定被释放，要放到finally里面，才会更安全一些。StempedLock对性能有很大的改进，特别是在读线程越来越多的情况下</li><li>使用<ul><li>在只有少量竞争者的时候，synchronized是一个很好的锁的实现</li><li>竞争者不少，但是增长量是可以预估的，ReentrantLock是一个很好的锁的通用实现（适合使用场景的才是最好的，不是越高级越好）</li></ul></li></ul><h3 id="JUC组件拓展"><a href="#JUC组件拓展" class="headerlink" title="JUC组件拓展"></a>JUC组件拓展</h3><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><ul><li><p>概述</p><p>在Java中一般通过继承Thread类或者实现Runnable接口这两种方式来创建线程，但是这两种方式都有个缺陷，就是不能在执行完成后获取执行的结果，因此Java 1.5之后提供了Callable和Future接口，通过它们就可以在任务执行完毕之后得到任务的执行结果。</p><p>而FutureTask则是J.U.C中的类，但不是AQS的子类，FutureTask是一个可删除的异步计算类。这个类提供了Future接口的的基本实现，使用相关方法启动和取消计算，查询计算是否完成，并检索计算结果。只有在计算完成时才能使用get方法检索结果;如果计算尚未完成，get方法将会阻塞。一旦计算完成，计算就不能重新启动或取消(除非使用runAndReset方法调用计算)</p></li><li><p>Runnable与Callable以及Future接口对比</p><ul><li>Runnable是一个接口，在它里面只声明了一个run()方法。由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果</li><li>Callable接口也只声明了一个方法，这个方法叫做<code>call()</code>。可以看到Callable是个泛型接口，泛型V就是要<code>call()</code>方法返回的类型。Callable接口和Runnable接口很像，都可以被另外一个线程执行，但是正如前面所说的，Runnable不会返回数据也不能抛出异常。</li><li>Future也是一个接口，Future接口代表异步计算的结果，通过Future接口提供的方法可以查看异步计算是否执行完成，或者等待执行结果并获取执行结果，同时还可以取消执行。说白了Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成以及获取执行结果。其中执行结果通过get方法获取，该方法会阻塞直到任务返回结果</li></ul></li><li><p>Future接口的定义</p><ul><li>cancel()方法用来取消异步任务的执行。如果异步任务已经完成或者已经被取消，或者由于某些原因不能取消，则会返回false。如果任务还没有被执行，则会返回true并且异步任务不会被执行。如果任务已经开始执行了但是还没有执行完成，若mayInterruptIfRunning为true，则会立即中断执行任务的线程并返回true，若mayInterruptIfRunning为false，则会返回true且不会中断任务执行线程。</li><li>isCanceled()方法用于判断任务是否被取消，如果任务在结束(正常执行结束或者执行异常结束)前被取消则返回true，否则返回false。</li><li>isDone()方法用于判断任务是否已经完成，如果完成则返回true，否则返回false。需要注意的是：任务执行过程中发生异常、任务被取消也属于任务已完成，也会返回true。</li><li>get()方法用于获取任务执行结果，如果任务还没完成则会阻塞等待直到任务执行完成。如果任务被取消则会抛出CancellationException异常，如果任务执行过程发生异常则会抛出ExecutionException异常，如果阻塞等待过程中被中断则会抛出InterruptedException异常。</li><li>get(long timeout,Timeunit unit)是带超时时间的get()版本，如果阻塞等待过程中超时则会抛出TimeoutException异常。</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Future</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    V <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">;</span>    V <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">,</span> TimeoutException<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p>Future主要提供了三种功能</p><ul><li>判断任务是否完成</li></ul></li><li><p>能够中断任务</p><ul><li>能够获取任务执行结果</li></ul></li></ul><p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。FutureTask的父类是RunnableFuture，而RunnableFuture则继承了Runnable和Future这两个接口。所以由此可知，FutureTask最终也属于是Callable类型的任务。如果往FutureTask的构造函数传入Runnable的话，也会被转换成Callable类型</p><ul><li>FutureTask继承图</li></ul><img src="/2019/12/12/java-gao-bing-fa/FutureTask%E7%BB%A7%E6%89%BF%E5%9B%BE.png" class="" title="FutureTask继承图"><p>可以看到，FutureTask实现了RunnableFuture接口，则RunnableFuture接口继承了Runnable接口和Future接口，所以FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果</p><ul><li>使用场景</li></ul><p>假设有一个很费时的逻辑需要计算，并且需要返回计算的结果，但这个结果又不是马上需要的。那么这时就可以使用FutureTask，用另外一个线程去进行计算，而当前线程在得到这个计算结果之前，就可以去执行其他的操作，等到需要这个结果时再通过Future得到即可。</p><p>FutureTask有两个构造器，支持传入Callable和Runnable类型，在使用 Runnable 时，需要多指定一个返回结果类型</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">FutureTask</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>callable <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> callable<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// ensure visibility of callable</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">FutureTask</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">,</span> V result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">callable</span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// ensure visibility of callable</span><span class="token punctuation">}</span></code></pre><h4 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h4><p>Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架，其思想和map-reduce非常类似。</p><p>我们再通过Fork和Join这两个单词来理解下Fork/Join框架，Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2+。。＋10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果</p><ul><li>Fork/Join的运行流程图</li></ul><img src="/2019/12/12/java-gao-bing-fa/ForkJoin%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" title="ForkJoin的运行流程图"><ul><li><p>工作窃取算法</p><p>Fork/Join框架主要采用的是工作窃取（work-stealing）算法，该算法是指某个线程从其他队列里窃取任务来执行。</p><p>那么为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p><p>所以对于Fork/Join框架而言，当一个任务正在等待它使用join操作创建的子任务的结束时，执行这个任务的线程（工作线程）查找其他未被执行的任务并开始它的执行。通过这种方式，线程充分利用它们的运行时间，从而提高了应用程序的性能。</p><ul><li>运行流程图</li></ul></li></ul><img src="/2019/12/12/java-gao-bing-fa/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="" title="工作窃取运行流程图"><ul><li>Fork/Join框架执行的任务有以下局限性<ul><li>任务只能使用<code>fork()</code>和<code>join()</code>操作，作为同步机制。如果使用其他同步机制，工作线程不能执行其他任务，当它们在同步操作时。比如，在Fork/Join框架中，你使任务进入睡眠，那么在这睡眠期间内，正在执行这个任务的工作线程将不会执行其他任务。</li><li>任务不应该执行I/O操作，如读或写数据文件。</li><li>任务不能抛出检查异常，它必须包括必要的代码来处理它们。</li></ul></li><li>Fork/Join框架的核心主要是以下两个类<ul><li>ForkJoinPool：它实现ExecutorService接口和work-stealing算法。它管理工作线程和提供关于任务的状态和它们执行的信息。</li><li>ForkJoinTask： 它是将在ForkJoinPool中执行的任务的基类。它提供在任务中执行<code>fork()</code>和<code>join()</code>操作的机制，并且这两个方法控制任务的状态。通常， 为了实现你的Fork/Join任务，你将实现两个子类的子类的类：RecursiveAction对于没有返回结果的任务和RecursiveTask 对于返回结果的任务。</li></ul></li><li>使用示例</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>zero<span class="token punctuation">.</span>concurrency<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>example<span class="token punctuation">.</span>aqs<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ForkJoinPool<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Future<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>RecursiveTask<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @program: concurrency-demo * @description: ForkJoin 使用示例 * @author: 01 * @create: 2018-10-19 20:12 **/</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForkJoinTaskExample</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THRESHOLD <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> start<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">ForkJoinTaskExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Integer <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果任务足够小就直接计算任务</span>        <span class="token keyword">boolean</span> canCompute <span class="token operator">=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> THRESHOLD<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>canCompute<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果任务大于阈值，就分裂成两个子任务计算</span>            <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            ForkJoinTaskExample leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinTaskExample</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>            ForkJoinTaskExample rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinTaskExample</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 执行子任务</span>            leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 等待任务执行结束合并其结果</span>            <span class="token keyword">int</span> leftResult <span class="token operator">=</span> leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> rightResult <span class="token operator">=</span> rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 合并子任务</span>            sum <span class="token operator">=</span> leftResult <span class="token operator">+</span> rightResult<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ForkJoinPool forkjoinPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//生成一个计算任务，计算1+2+3+4...+100</span>        ForkJoinTaskExample task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinTaskExample</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//执行一个任务</span>        Future<span class="token operator">&lt;</span>Integer<span class="token operator">></span> result <span class="token operator">=</span> forkjoinPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"result:{}"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"exception"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><ul><li>在新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题，从名字也可以知道它是线程安全的。通过这些高效并且线程安全的队列类，为快速搭建高质量的多线程程序带来极大的便利。BlockingQueue 当获取队列元素但是队列为空时，会阻塞等待队列中有元素再返回；也支持添加元素时，如果队列已满，那么等到队列可以放入新元素时再放入。所以 BlockingQueue 主要应用于生产者消费者场景</li><li>BlockingQueue 是一个接口，继承自 Queue，所以其实现类也可以作为 Queue 的实现来使用，而 Queue 又继承自 Collection 接口</li></ul><table><thead><tr><th align="left">-</th><th align="left">Throws exception</th><th align="left">Special value</th><th align="left">Blocks</th><th align="left">Times out</th></tr></thead><tbody><tr><td align="left">Insert</td><td align="left">add(e)</td><td align="left">offer(e)</td><td align="left">put(e)</td><td align="left">offer(e, time, unit)</td></tr><tr><td align="left">Insert</td><td align="left">remove()</td><td align="left">poll()</td><td align="left">take()</td><td align="left">poll(time, unit)</td></tr><tr><td align="left">Examine</td><td align="left">element()</td><td align="left">peek()</td><td align="left">not applicable</td><td align="left">not applicable</td></tr></tbody></table><ul><li><p>说明</p><ul><li>Throws Exceptions ：如果不能立即执行就抛出异常</li><li>Special Value：如果不能立即执行就返回一个特殊的值（null 或 true/false，取决于具体的操作</li><li>Blocks：如果不能立即执行就阻塞等待此操作，直到这个操作成功</li><li>Times Out：如果不能立即执行就阻塞一段时间，直到成功或者超时指定时间</li></ul></li><li><p>BlockingQueue 的实现类</p><ul><li><p>BlockingQueue 的实现类：</p></li><li><p>ArrayBlockingQueue：它是一个有界的阻塞队列，内部实现是数组，需在初始化时指定容量大小，一旦指定大小就不能再变。采用FIFO方式存储元素：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span>        <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** The queued items */</span>    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>            </code></pre></li><li><p>DelayQueue：阻塞内部元素，DelayQueue内部元素必须实现Delayed接口，Delayed接口又继承了Comparable接口，原因在于DelayQueue内部元素需要排序，一般情况下按元素过期时间优先级排序：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Delayed</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Delayed<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> <span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>DalayQueue内部采用PriorityQueue与ReentrantLock实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelayQueue</span><span class="token operator">&lt;</span>E <span class="token keyword">extends</span> <span class="token class-name">Delayed</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span>    <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">transient</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> PriorityQueue<span class="token operator">&lt;</span>E<span class="token operator">></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre></li><li><p>LinkedBlockingQueue：使用独占锁实现的阻塞队列，大小配置可选，如果初始化时指定了大小，那么它就是有边界的。不指定就无边界（最大整型值）。内部实现是链表，采用FIFO形式保存数据。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 不指定大小，无边界采用默认值，最大整型值</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>PriorityBlockingQueue：带优先级的×××阻塞队列，无边界队列，允许插入null。插入的对象必须实现Comparator接口，队列优先级的排序规则就是按照我们对Comparable接口的实现来指定的。我们可以从PriorityBlockingQueue中获取一个迭代器，但这个迭代器并不保证能按照优先级的顺序进行迭代：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PriorityBlockingQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span>    <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n<span class="token punctuation">,</span> cap<span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> es<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> size<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token punctuation">(</span>cap <span class="token operator">=</span> <span class="token punctuation">(</span>es <span class="token operator">=</span> queue<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">tryGrow</span><span class="token punctuation">(</span>es<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//必须实现Comparator接口</span>            <span class="token keyword">final</span> Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> cmp<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cmp <span class="token operator">=</span> comparator<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token function">siftUpComparable</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> e<span class="token punctuation">,</span> es<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                <span class="token function">siftUpUsingComparator</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> e<span class="token punctuation">,</span> es<span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>            size <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>        </code></pre></li><li><p>SynchronousQueue：同步阻塞队列，只能插入一个元素，×××非缓存队列，不存储元素。其内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，当然遍历这个队列的操作也是不允许的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span>    <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>    </code></pre></li></ul></li></ul><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="使用线程池的目的"><a href="#使用线程池的目的" class="headerlink" title="使用线程池的目的"></a>使用线程池的目的</h4><ul><li>线程是稀缺资源，不能频繁的创建。应当将其放入一个池子中，可以给其他任务进行复用，减少对象创建、消亡的开销，性能好</li><li>解耦作用；线程的创建于执行完全分开，方便维护</li><li>线程池可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞</li><li>线程池可提供定时执行、定期执行、单线程以及并发数控制等功能</li></ul><h4 id="直接new-Thread的弊端"><a href="#直接new-Thread的弊端" class="headerlink" title="直接new Thread的弊端"></a>直接new Thread的弊端</h4><ul><li>每次new Thread 新建对象，性能差</li><li>线程缺乏统一管理，可能无限制的新建线程，相互竞争，常常会出现占用过多的系统资源导致死机或者发生OOM（out of memory 内存溢出），这种问题的原因不是因为单纯的new一个Thread，而是可能因为程序的bug或者设计上的缺陷导致不断new Thread造成的。</li><li>缺少更多功能，如更多执行、定期执行、线程中断等</li></ul><h4 id="threadPool类图"><a href="#threadPool类图" class="headerlink" title="threadPool类图"></a>threadPool类图</h4><img src="/2019/12/12/java-gao-bing-fa/threadPool%E7%B1%BB%E5%9B%BE.png" class="" title="threadPool类图"><p>在类图中，我们最常使用的是ThreadPoolExecutor和Executors，这两个类都可以创建线程池，其中ThreadPoolExecutor是可定制化的去创建线程池，而Executors则属于是工具类，该类中已经封装好了一些创建线程池的方法，直接调用相应的方法即可创建线程</p><img src="/2019/12/12/java-gao-bing-fa/%E9%98%BF%E9%87%8C%E5%85%B3%E4%BA%8EExecutor%E7%9A%84%E8%A7%84%E8%8C%83.png" class="" title="阿里关于Executor的规范"><p>线程池体系里最为核心的类是ThreadPoolExecutor，也是功能最强的，ThreadPoolExecutor共有四个构造函数</p><img src="/2019/12/12/java-gao-bing-fa/ThreadPoolExecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png" class="" title="ThreadPoolExecutor构造函数"><h4 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h4><ul><li>corePoolSize：核心线程数量</li><li>maximumPoolSize：线程最大线程数</li><li>workQueue：阻塞队列，存储等待执行的任务，很重要，会对线程池运行过程产生重大影响</li><li>keepAliveTime：线程没有任务执行时最多保持多久时间终止（当线程中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交核心线程外的线程不会立即销毁，而是等待，直到等待的时间超过keepAliveTime）</li><li>unit：keepAliveTime的时间单位</li><li>threadFactory：线程工厂，用来创建线程，若不设置则使用默认的工厂来创建线程，这样新创建出来的线程会具有相同的优先级，并且是非守护的线程，同时也会设置好名称</li><li>rejectHandler：当拒绝处理任务时(阻塞队列满)的策略（AbortPolicy默认策略直接抛出异常、CallerRunsPolicy用调用者所在的线程执行任务、DiscardOldestPolicy丢弃队列中最靠前的任务并执行</li></ul><p>corePoolSize、maximumPoolSize、workQueue 这三个参数的关系</p><ul><li><p>如果运行的线程数量小于corePoolSize的时候，直接创建新线程来处理任务。即使线程池中的其他线程是空闲的。如果线程池中的线程数量大于corePoolSize且小于maximumPoolSize时，那么只有当workQueue满的时候才创建新的线程去处理任务。如果corePoolSize与maximumPoolSize是相同的，那么创建的线程池大小是固定的。这时如果有新任务提交，且workQueue未满时，就把请求放入workQueue中，等待空闲线程从workQueue取出任务进行处理。如果需要运行的线程数量大于maximumPoolSize时，并且此时workQueue也满了，那么就使用rejectHandler参数所指定的拒绝策略去进行处理</p><p>workQueue是保存待执行任务的一个阻塞队列，当我们提交一个新的任务到线程池后，线程池会根据当前池中正在运行的线程数量来决定该任务的处理方式。处理方式总共有三种：</p></li></ul><ol><li><p>直接切换（SynchronusQueue）</p></li><li><p>队列（LinkedBlockingQueue），若使用该队列，那么线程池中能够创建的最大线程数为corePoolSize，这时maximumPoolSize就不会起作用了。当线程池中所有的核心线程都是运行状态的时候，新的任务提交就会放入等待队列中。</p></li><li><p>有界队列（ArrayBlockingQueue），使用该队列可以将线程池中的最大线程数量限制为maximumPoolSize参数所指定的值，这种方式能够降低资源消耗，但是这种方式使得线程池对线程调度变的更困难。因为此时线程池与队列容量都是有限的了，所以想让线程池处理任务的吞吐率达到一个合理的范围，又想使我们的线程调度相对简单，并且还尽可能降低线程池对资源的消耗，那么我们就需要合理的设置corePoolSize和maximumPoolSize这两个参数的值</p></li></ol><p>分配技巧： 如果想降低资源的消耗包括降低cpu使用率、操作系统资源的消耗、上下文切换的开销等等，可以设置一个较大的队列容量和较小的线程池容量，这样会降低线程池处理任务的吞吐量。如果我们提交的任务经常发生阻塞，我们可以考虑调用相关方法调整maximumPoolSize参数的值。如果我们的队列容量较小，通常需要把线程池的容量设置得大一些，这样cpu的使用率相对来说会高一些。但是如果线程池的容量设置的过大，提高任务的数量过多的时候，并发量会增加，那么线程之间的调度就是一个需要考虑的问题，这样反而可能会降低处理任务的吞吐量。</p><p>拒绝策略的实现类都在ThreadPoolExecutor中</p><img src="/2019/12/12/java-gao-bing-fa/ThreadPoolExecutor%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E7%B1%BB.png" class="" title="ThreadPoolExecutor拒绝策略类"><p>workQueue是保存待执行任务的一个阻塞队列，当我们提交一个新的任务到线程池后，线程池会根据当前池中正在运行的线程数量来决定该任务的处理方式，有三种处理方式</p><ul><li>SynchronusQueue</li><li>LinkedBlockingQueue，若使用该队列，那么线程池中能够创建的最大线程数为corePoolSize，这时maximumPoolSize就不会起作用了。当线程池中所有的核心线程都是运行状态的时候，新的任务提交就会放入等待队列中。</li><li>ArrayBlockingQueue，使用该队列可以将线程池中的最大线程数量限制为maximumPoolSize参数所指定的值，这种方式能够降低资源消耗，但是这种方式使得线程池对线程调度变的更困难。因为此时线程池与队列容量都是有限的了，所以想让线程池处理任务的吞吐率达到一个合理的范围，又想使我们的线程调度相对简单，并且还尽可能降低线程池对资源的消耗，那么我们就需要合理的设置corePoolSize和maximumPoolSize这两个参数的值</li></ul><p>分配技巧： 如果想降低资源的消耗包括降低cpu使用率、操作系统资源的消耗、上下文切换的开销等等，可以设置一个较大的队列容量和较小的线程池容量，这样会降低线程池处理任务的吞吐量。如果我们提交的任务经常发生阻塞，我们可以考虑调用相关方法调整maximumPoolSize参数的值。如果我们的队列容量较小，通常需要把线程池的容量设置得大一些，这样cpu的使用率相对来说会高一些。但是如果线程池的容量设置的过大，提高任务的数量过多的时候，并发量会增加，那么线程之间的调度就是一个需要考虑的问题，这样反而可能会降低处理任务的吞吐量</p><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><p>线程池有五种状态</p><img src="/2019/12/12/java-gao-bing-fa/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.png" class="" title="线程池状态"><ul><li>running：运行状态，能接受新提交的任务，也能处理阻塞队列中的任务</li><li>shutdown：关闭状态，不能处理新的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；</li><li>stop：停止状态，不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；</li><li>tidying：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。</li><li>terminated：最终状态，在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。</li></ul><p>线程池常用方法</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">execute()</td><td align="left">提交任务，交给线程池执行</td></tr><tr><td align="left">submit()</td><td align="left">提交任务，能够返回执行结果 execute+Future</td></tr><tr><td align="left">shutdown()</td><td align="left">关闭线程池，等待任务都执行完</td></tr><tr><td align="left">shutdownNow()</td><td align="left">立刻关闭线程池，不等待任务执行完</td></tr><tr><td align="left">getTaskCount()</td><td align="left">线程池已执行和未执行的任务总数</td></tr><tr><td align="left">getCompleteTaskCount()</td><td align="left">已完成的任务数量</td></tr><tr><td align="left">getPoolSize()</td><td align="left">线程池当前的线程数量</td></tr><tr><td align="left">getActiveCount()</td><td align="left">当前线程池中正在执行任务的线程数量</td></tr></tbody></table><p>使用Executors创建线程池</p><table><thead><tr><th align="left">方法名</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">newCachedThreadPool</td><td align="left">创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</td></tr><tr><td align="left">newFixedThreadPool</td><td align="left">创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</td></tr><tr><td align="left">newScheduledThreadPool</td><td align="left">创建一个定长线程池，支持定时及周期性任务执行</td></tr><tr><td align="left">newSingleThreadExecutor</td><td align="left">创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</td></tr></tbody></table><h4 id="使用ThreadPoolExecutor创建线程池"><a href="#使用ThreadPoolExecutor创建线程池" class="headerlink" title="使用ThreadPoolExecutor创建线程池"></a>使用ThreadPoolExecutor创建线程池</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>zero<span class="token punctuation">.</span>concurrency<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>example<span class="token punctuation">.</span>threadpool<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>NonNull<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger<span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExample6</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用ArrayBlockingQueue作为其等待队列</span>        BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> blockingQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用自定义的ThreadFactory，目的是设置有意义的的线程名字，方便出错时回溯</span>        ThreadFactory namedThreadFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThreadFactory</span><span class="token punctuation">(</span><span class="token string">"test-thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建线程池</span>        ThreadPoolExecutor poolExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">,</span> blockingQueue<span class="token punctuation">,</span> namedThreadFactory<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行任务</span>        poolExecutor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"thread run"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 关闭线程池</span>        poolExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger threadNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> String namePrefix<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token function">MyThreadFactory</span><span class="token punctuation">(</span>String namePrefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>namePrefix <span class="token operator">=</span> namePrefix <span class="token operator">+</span> <span class="token string">"-"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Thread <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> namePrefix <span class="token operator">+</span> threadNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Thread<span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> t<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="线程池的合理配置"><a href="#线程池的合理配置" class="headerlink" title="线程池的合理配置"></a>线程池的合理配置</h4><ul><li>CPU密集型任务，就需要尽量压榨CPU，参考值可以设置为NCPU+1，即CPU核心数量+1</li><li>IO密集型任务，参考值可以设置为2*NCPU，即CPU核心数量的2倍</li><li>当线程池内需要执行的任务很小，小到执行任务的时间和任务调度的时间很接近，这时若使用线程池反而会更慢</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>概念 当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁</li><li>死锁的四个条件 当同时满足时发生<ul><li>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li><li>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li><li>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li><li>环路等待条件：是指进程发生死锁后，必然存在一个进程–资源之间的环形链</li></ul></li><li>解决死锁的四种方式<ul><li>预防死锁：通过设置一些限制条件，去破坏产生死锁的必要条件</li><li>避免死锁：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁</li><li>检测死锁：允许死锁的发生，但是通过系统的检测之后，采取一些措施，将死锁清除掉</li><li>解除死锁：该方法与检测死锁配合使用</li></ul></li></ul><h3 id="Spring与线程安全"><a href="#Spring与线程安全" class="headerlink" title="Spring与线程安全"></a>Spring与线程安全</h3><p>Spring作为一个IOC/DI容器，帮助我们管理了许许多多的“bean”。但其实，Spring并没有保证这些对象的线程安全，需要由开发者自己编写解决线程安全问题的代码。</p><ul><li><p>Spring bean</p><p>Spring对每个bean提供了一个scope属性来表示该bean的作用域。它是bean的生命周期。例如，一个scope为singleton的bean，在第一次被注入时，会创建为一个单例对象，该对象会一直被复用到应用结束。* * </p><ul><li>singleton：默认的scope，每个scope为singleton的bean都会被定义为一个单例对象，该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建）。在整个Spring IoC容器里，只有一个bean实例，所有线程共享该实例。</li><li>prototype：bean被定义为在每次注入时都会创建一个新的对象。每次请求都会创建并返回一个新的实例，所有线程都有单独的实例使用，这种方式是比较安全的，但会消耗大量内存和计算资源。</li><li>request（请求范围实例）：bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。每当接受到一个HTTP请求时，就分配一个唯一实例，这个实例在整个请求周期都是唯一的。</li><li>session（会话范围实例）：bean被定义为在一个session的生命周期内创建一个单例对象。在每个用户会话周期内，分配一个实例，这个实例在整个会话周期都是唯一的，所有同一会话范围的请求都会共享该实例。</li><li>application：bean被定义为在ServletContext的生命周期中复用一个单例对象。</li><li>websocket：bean被定义为在websocket的生命周期中复用一个单例对象。</li><li>globalsession（全局会话范围实例）：这与会话范围实例大部分情况是一样的，只是在使用到portlet时，由于每个portlet都有自己的会话，如果一个页面中有多个portlet而需要共享一个bean时，才会用到</li></ul></li><li><p>无状态的对象</p><p>即是自身没有状态的对象，自然也就不会因为多个线程的交替调度而破坏自身状态导致线程安全问题。无状态对象包括我们经常使用的DO、DTO、VO这些只作为数据的实体模型的贫血对象，还有Service、DAO和Controller，这些对象并没有自己的状态，它们只是用来执行某些操作的。例如，每个DAO提供的函数都只是对数据库的CRUD，而且每个数据库Connection都作为函数的局部变量（局部变量是在用户栈中的，而且用户栈本身就是线程私有的内存区域，所以不存在线程安全问题），用完即关（或交还给连接池）。</p></li><li><p>线程安全的几种情况</p><ul><li>常量始终是线程安全的，因为只存在读操作。</li><li>每次调用方法前都新建一个实例是线程安全的，因为不会访问共享的资源。</li><li>局部变量是线程安全的。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量</li></ul></li></ul><p>Spring没有对bean的多线程安全问题做出任何保证与措施。对于每个bean的线程安全问题，根本原因是每个bean自身的设计没有在bean中声明任何有状态的实例变量或类变量，如果必须如此，那么就使用ThreadLocal把变量变为线程私有的，如果bean的实例变量或类变量需要在多个线程之间共享，那么就只能使用synchronized、lock、CAS等这些实现线程同步的方法</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2019/12/07/mysql-ji-chu/"/>
      <url>/2019/12/07/mysql-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul><li><p>概念：</p><ul><li>数据是数据库中储存的基本对象，数据的含义为数据的语义</li><li>数据库DB：长期储存、有组织、可共享、大量数据：长期储存、有组织、可共享、大量数据<ul><li>按一定的数据模型组织、描述和储存；可共享；冗余度较小；数据独立性较高；易扩展</li></ul></li></ul></li><li><p>数据库管理系统DBMS</p><ul><li>数据定义，数据组织、储存和管理，数据操纵</li><li>主要功能：运行管理、建立和维护</li></ul></li><li><p>DBMS特点</p><ul><li>数据放到表中，表再放在库中</li><li>一个数据库中可以有多个表，每个表都有一个名字标识，具有唯一性</li><li>表具有一些特性，定义了数据再表中如何储存，类似java中“类”</li><li>表由列组成，也称字段，所有表都是由一个或多个列组成的，每一列类似java中的”属性“</li><li>表中的数据是按行储存的，每一行类似java中的“对象”</li></ul></li><li><p>Mysql启动： mysql -h 主机名 -P端口号 -u 用户名 -p 密码</p></li></ul><pre><code>show databases;use 库名;show tables;show tables from 库名;create table 表名(    列名 列类型,    列名 列类型,    ...);</code></pre><ul><li>查看表结构： desc 表名</li><li>mysql不区分大小写，但关键字大写，表明列名小写</li></ul><h2 id="1-DQL语言"><a href="#1-DQL语言" class="headerlink" title="1.DQL语言"></a>1.DQL语言</h2><p>做查询时前面添加命令 USE 库名;</p><p>查询时，先确认是否所需数据都在一张表里，决定是否连接表，再进行筛选，注意GROUP BY前后筛选</p><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h3><ul><li><p>select 查询列表 from 表名</p></li><li><p>查询列表可以是：表中的字段、常量值、表达式、函数</p></li><li><p>查询的结果是一个虚拟的表格</p><pre class=" language-mysql"><code class="language-mysql">-- 查询表中的单个字段SELECT last_name FROM employees;-- 查询表中的多个字段SELECT last_name,salary,email FROM employees;-- 查询表中的所有字段SELECT * FROM employees;-- 星号不可以自定义顺序-- 查询常量值SELECT 100; SELECT 'john';-- 查询表达式SELECT 100%98；-- 查询函数SELECT version();-- 可以起别名 别名可加双引号避免歧义报错SELECT 100%98 AS 结果;SELECT last_name AS 姓,first_name AS 名 FROM employees;SELECT last_name 姓,first_name 名 FROM employees;-- 去重SELECT DISTINCT department_id FROM employees;-- 加号-- mysql中对字符型进行转换，转换成功则继续运算，否则字符型转化为0，如果有一方为null，则结果输出nullSELECT CONCAT('a','b','c') AS 结果; 则输出 abcIFNULL(字段,数值)</code></pre></li></ul><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><pre><code>SELECT 查询列表FROM 表名WHERE 筛选条件</code></pre><ul><li><p>支持条件运算符（包括模糊查询）、逻辑表达式AND NOT OR</p><ul><li><p>模糊查询：like、between and、in、is null</p><ul><li><p>like</p><p>通配符：%-&gt;0-n个任意字符、一个任意字符用\转义，</p><p>或 <code>last_name LIKE &#39;_$_%&#39; ESCAPE &#39;$&#39;;($可换成任意字符充当转义)</code></p></li><li><p>between and 包含为闭区间 </p></li><li><p>in job_id(‘’,’’,’’);</p></li><li><p>is null/is not null -&gt;由于= &lt;&gt; 不可判断null值</p></li><li><p>&lt;=&gt;安全等于（可以判断null</p></li></ul></li></ul></li></ul><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><pre class=" language-mysql"><code class="language-mysql">SELECT 查询列表 FROM 表 where 筛选条件 ORDER BY 排序列表(ASC|DESC);</code></pre><ul><li><p>特点：默认升序；</p><p>order by 支持单个多个字段、表达式、函数、别名；一般放在查询语句最后（只有Limit 子句在其后</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM employees ORDER BY salary DESC;SELECT * FROM employees ORDER BY salary ASC;-- 按年薪高低显示员工的信息和 年薪按表达式顺序SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪 FROM employees ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;-- 按年薪高低显示员工的信息和 年薪按别名顺序SELECT *,salary*12*(1+IFNULL(commission_pct,0)) 年薪FROM employees ORDER BY 年薪 DESC;-- 按函数排序SELECT LENGTH(last_name) 字节长度，last_name,salary FROM employees ORDER BY LENGTH(last_name) DESC;-- 按多个字段排序SELECT * FROM employees ORDER BY salary ASC,employees_id DESC;</code></pre></li></ul><h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h3><p>类似于方法</p><ul><li><p>单行函数：concat、length、ifnull等</p><ul><li><p>字符函数</p><ul><li>SELECT LENGTH 注意这里是字节长度</li><li>CONCAT( , , )</li><li>UPPER,LOWER</li><li>SUBSTR、SUBSTRING sql中索引从1开始，substr的第三个参数为长度类似C++substr</li><li>INSTR 返回子串中出现的第一次起始位置，否则返回0</li><li>TRIM （’a’ FROM ‘aaaaneawwwaaaa’）则仅去掉前后两端的a</li><li>LPAD (‘test’,10,’*’) output 则左边用星号填充至10个字符（如果输出长度小于原字符则截断</li><li>RPAD同理</li><li>REPLACE(‘test’,’e’,’s’)</li></ul></li><li><p>数学函数</p><ul><li>ROUND四舍五入 </li><li>SELECT ROUND(1.45);</li><li>CEIL向上取整</li><li>FLOOR返回&lt;=该参数的最大整数</li><li>TRUNCATE截断 SELECT TRUNCATE(1.555，1)保留一位小数</li><li>MOD取余</li></ul></li><li><p>日期函数</p><ul><li>SELECT NOW();返回当前系统日期+时间</li><li>SELECT CURDATE();返回当前系统日期</li><li>SELECT CURTIME();返回当前时间</li><li>SELECT year(),month(),day(),hour(),minute(),second() 获取年月日时分秒</li><li>SELECT MONTHNAME(NOW());</li><li>str_to_date将日期格式的字符串转汉城指定格式的日期  STR_TO_DATE(‘9-13-1999’,’%m-%d=%Y’);</li><li>date_format:将日期转换成字符</li><li>SELECT DATE_FORMAT(NOW(),’%y年%m月%d日’) AS out_put;</li></ul></li><li><p>其他函数</p><ul><li>SELECT VERSION();                    </li><li>SELECT DATABASE();                </li><li>SELECT USER();</li><li>SELECT PASSWORD(‘’);//字符加密</li></ul></li><li><p>流程控制函数</p><ul><li><p>IF类似三目运算符?:</p></li><li><p>SELECT IF(10&gt;5,’大’，’小’);</p></li><li><p>CASE</p><pre class=" language-mysql"><code class="language-mysql">-- 类似switchCASE department_idWHEN 30 THEN salary*1.1WHEN 40 THEN salary*1.2ELSE salaryEND AS 新工资FROM employees;-- 类似多重if-elseCASEWHEN salary>20000 THEN 'A'WHEN salary>15000 THEN 'B'ELSE 'D'END AS 工资级别FROM employees;</code></pre></li></ul></li><li><p>分组函数：</p><p>用于统计又称聚合、统计函数，SUM、AVG、MAX、MIN、COUNT</p><ul><li><p>SUM、AVG对数值型处理</p></li><li><p>MAX、MIN、COUNT对任何类型可处理</p></li><li><p>所有的分组函数都忽略NULL值；都可以和DISTINCT搭配实现去重</p></li><li><p>COUNT详解</p><pre class=" language-mysql"><code class="language-mysql">-- 统计行数SELECT COUNT(*) FROM employees;SELECT COUNT(1) FROM employees;</code></pre><p>MYISAM引擎COUNT(*)效率高INNODB两者差不多，比COUNT(字段)效率高<br>和分组函数一同查询的字段要求是group by后的字段<br>DATEDIFF 计算两参数差值</p></li></ul></li></ul></li></ul><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><pre><code>SELECT 分组函数，列FROM 表WHERE 删选条件GROUP BY 分组的列表ORDER BY 子句</code></pre><ul><li><p>案例</p><pre class=" language-mysql"><code class="language-mysql">SELECT AVG(salary)，department_idFROM employeesWHERE email LIKE '%a%'GROUP BY department_id;SELECT COUNT(*),department_idFROM employeesGROUP BY department_idHAVING COUNT(*)>2;SELECT MAX(salary),job_idFROM employeesWHERE commission_pct IS NOT NULLGROUP BY job_idHAVING MAX(salary)>12000SELECT MIN(salary),manager_idFROM employeesWHERE department_id>102GROUP BY manager_idHAVING MIN(salary)>5000;</code></pre></li><li><p>特点</p><p>筛选条件 两者筛选数据源不同 </p><p>分组前筛选 筛选的是原始表</p><p>分组后筛选 筛选的是分组后的结果集</p><p>能分组前筛选的尽量分组前筛选（性能考虑</p></li><li><p>GROUP BY</p><p>支持多分组 支持按表达式或函数分组</p><pre class=" language-mysql"><code class="language-mysql">-- 按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数>5的有哪些SELECT COUNT(*),LENGTH(last_name) len_nameFROM employeesGROUP BY LENGTH(last_name)HAVING COUNT(*)>5;</code></pre></li></ul><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>又称多表查询</p><pre class=" language-mysql"><code class="language-mysql">SELECT 查询列表FROM 表1 别名 连接类型JOIN 表2 别名ON 连接条件</code></pre><ul><li><p>内连接 INNER JOIN</p><ul><li><p>等值连接</p><pre class=" language-mysql"><code class="language-mysql">SELECT NAME,boyName FROM boys,beautyWHERE beauty.boyfriend_id=boys.id;</code></pre><ul><li><p>查询员工名、工种号、工种名 可以为表起别名</p><pre class=" language-mysql"><code class="language-mysql">SELECT last_name,employees.job_id,job_titleFROM employees,jobsWHERE employees.`job_id`=jobs.`job_id`;</code></pre></li><li><p>可以加筛选</p><pre class=" language-mysql"><code class="language-mysql">SELECT last_name,department_name                        FROM employees,departmentsWHERE employees.`department_id`=departments.department_idAND employees.`commission_pct` IS NOT NULL;</code></pre></li><li><p>可以加分组</p><pre class=" language-mysql"><code class="language-mysql">-- 查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资SELECT department_name,d.manager_id,MIN(e.salary)FROM employees e,departments dWHERE e.department_id =d.department_idand e.commission_pct is not nullGROUP BY department_name,d.manager_id;</code></pre></li><li><p>可以加排序</p><pre class=" language-mysql"><code class="language-mysql">-- 查询每个工种的工种名和员工的个数,并按员工个数降序SELECT    job_title,    count(*)FROM    employees e,    jobs jWHERE    e.job_id = j.job_idGROUP BY    job_titleORDER BY    count(*) DESC</code></pre></li><li><p>可以进行三表连接</p><pre class=" language-mysql"><code class="language-mysql">SELECT last_name,department_name,cityFROM employees e,departments d,locations lWHERE e.`department_id`=d.`department_id`AND d.`location_id`=l.`location_id`AND city LIKE 's%'ORDER BY department_name DESC;</code></pre></li><li><p>也可以加分组后筛选</p></li></ul></li><li><p>非等值连接</p><pre class=" language-mysql"><code class="language-mysql">-- 查询员工的工资和工资级别SELECT salary,grade_levelFROM employees e,job_grades gWHERE salary BETWEEN g.`lowest_sal` AND g.`highest_sal`;</code></pre></li><li><p>自连接</p><pre class=" language-mysql"><code class="language-mysql">-- 查询员工名和上级的名称SELECT e.employee_id,e.last_name,m.employee_id,m.last_nameFROM employees e,employees mWHERE e.`manager_id`=m.`employee_id`;</code></pre></li><li><p>注意</p><ul><li>多表连接的结果为多表的交集部分</li><li>n表连接至少需要n-1个连接条件</li><li>多表的顺序无要求，一般需起别名</li><li>可搭配其他子句使用</li></ul></li><li><p>总结</p><pre class=" language-mysql"><code class="language-mysql">SELECT 查询列表FROM 表1 别名1，表2 别名2（等值连接、非等值连接 / FROM 表 别名1，表 别名2（自连接WHERE （非）等值的连接条件AND 筛选条件GROUP BY 分组字段HAVING 分组后的筛选ORDER BY 排序字段</code></pre></li></ul></li><li><p>外连接：连接类型outer</p><p>用与查询一个表有，另一个表没有的记录</p><ul><li><p>左外连接</p><pre class=" language-mysql"><code class="language-mysql">SELECT <select_list>FROM ALEFT OUTER JOIN BON A.key=B.keyWHERE B.key IS NULL;</code></pre><p>左外连接还返回左表中不符合连接条件单符合查询条件的数据行</p></li><li><p>右外连接</p><pre class=" language-mysql"><code class="language-mysql">SELECT <select_list>FROM BRIGHT OUTER JOIN AON A.key=B.keyWHERE A.key IS NULL;</code></pre><p>右外连接还返回右表中不符合连接条件单符合查询条件的数据行</p></li><li><p>交叉连接</p><pre class=" language-mysql"><code class="language-mysql">SELECT b.* ,bo.*FROM beauty bCROSS JOIN boys bo;-- 结果为笛卡尔乘积结果</code></pre></li></ul></li></ul><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><blockquote><p>出现在其他语句中的select语句，成为子查询或内查询</p></blockquote><table><thead><tr><th>位置</th><th>子查询类型</th></tr></thead><tbody><tr><td>select后</td><td>标量子查询</td></tr><tr><td>FROM后</td><td>表子查询</td></tr><tr><td>WHERE或HAVING后</td><td>标量子查询、列子查询、行子查询</td></tr><tr><td>EXISTS后</td><td>表子查询</td></tr></tbody></table><table><thead><tr><th>类型</th><th>特征</th></tr></thead><tbody><tr><td>标量子查询</td><td>结果集只有一行一列</td></tr><tr><td>列子查询</td><td>结果集只有一行多列</td></tr><tr><td>行子查询</td><td>结果集有一行多列</td></tr><tr><td>表子查询</td><td>结果集一般为多行多列</td></tr></tbody></table><ul><li><p>SELECT后面</p><pre class=" language-mysql"><code class="language-mysql">-- 查询每个部门的员工个数SELECT d.*,(SELECT COUNT(*) FROM employees WHERE employees.`department_id`=d.`department_id`)FROM departments d</code></pre></li><li><p>FROM后面</p><pre class=" language-mysql"><code class="language-mysql">-- 查询每个部门的平均工资的工资等级SELECT t1.*,t2.`grade_level`FROM(    SELECT department_id,AVG(salary) avg_salary     FROM employees    GROUP BY department_id) t1 INNER JOIN job_grades t2ON t1.avg_salary BETWEEN t2.`lowest_sal` AND t2.`highest_sal`</code></pre></li><li><p>WHERE和HAVING后</p><ul><li><p>标量子查询    单行</p><pre class=" language-mysql"><code class="language-mysql">-- 谁的工资比abel高SELECT e.`last_name` FROM employees e WHERE e.`salary`>(    SELECT salary     FROM employees     WHERE last_name = 'Abel')；</code></pre></li><li><p>列子查询        多行</p><pre class=" language-mysql"><code class="language-mysql">-- 返回location_id是1400或1700的部门中的所有员工姓名SELECT last_nameFROM employeesWHERE department_id IN(    SELECT DISTINCT department_id    FROM departments    WHERE location_id IN(1400,1700));-- 返回其他工种中比job_id为`IT_PROG`工种任一工资低的员工的员工号、姓名、job_id、salarySELECT last_name,employee_id,job_id,salary FROM employees WHERE salary<ALL(     SELECT DISTINCT salary     FROM employees     WHERE job_id = 'IT_PROG' ) AND job_id<>'IT_PROG';</code></pre></li><li><p>行子查询         多列多行</p><ul><li><p>特点</p><p>子查询放在小括号内、子查询一帮放在条件的右侧、标量子查询一般搭配着单行操作符使用<br>列子查询，一般搭配着多行操作符使用</p></li></ul><pre class=" language-mysql"><code class="language-mysql">-- 员工编号最小并且工资最高的员工信息SELECT *FROM employeesWHERE (employee_id,salary)=(    SELECT MIN(employee_id),MAX(salary)    FROM employees);-- 或用以下形式SELECT *FROM employeesWHERE employee_id=(    SELECT MIN(employee_id)    FROM employees) AND salary=(    SELECT MAX(salary)    FROM employees);</code></pre></li></ul></li><li><p>EXISTS后面：相关子查询</p><pre class=" language-mysql"><code class="language-mysql">SELECT EXISTS(    SELECT employee_id     FROM employees      WHERE salary=30000);</code></pre></li></ul><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>当显示的数据，一页显示不全，需要分页提交sql请求</p><pre class=" language-mysql"><code class="language-mysql">SELECT 查询列表FROM 表连接类型 JOIN 表2ON 连接条件WHERE 筛选条件GROUP BY 分组字段HAVING 分组后的筛选ORDER BY 排序的字段LIMIT offset,size;-- 每页公式为 SELECT 查询列表 FROM 表 LIMIT (page-1)*size,size;</code></pre><h3 id="union联合查询"><a href="#union联合查询" class="headerlink" title="union联合查询"></a>union联合查询</h3><p>将多条查询语句合并成一个结果</p><ul><li>应用场景     多个表没有连接关系，但是列数相同的表</li><li>特点   多条查询语句列数一致、字段名和类型顺序要一致、自动去重（取消去重则UNION ALL）</li></ul><h2 id="2-DML语言"><a href="#2-DML语言" class="headerlink" title="2.DML语言"></a>2.DML语言</h2><h3 id="插入语句insert"><a href="#插入语句insert" class="headerlink" title="插入语句insert"></a>插入语句insert</h3><pre class=" language-mysql"><code class="language-mysql">-- 前者支持插入多行VALUES(),(),();后者不支持-- 前者支持子查询 SELECT ,后者不支持insert into 表名（列名，...）values(值，...)或insert into 表名set 列名=值,列名=值;</code></pre><ul><li><p>插入的类型要与列的类型一致或兼容</p><pre class=" language-mysql"><code class="language-mysql">INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)VALUES(13,'唐艺昕','女','1990-4-23','18988888888',NULL,2);</code></pre></li><li><p>注意</p><ul><li>不可为NULL的值可以写NULL或省略</li><li>可以省略列名，但是此时NULL值不能省略写</li></ul></li></ul><h3 id="修改语句update"><a href="#修改语句update" class="headerlink" title="修改语句update"></a>修改语句update</h3><pre class=" language-mysql"><code class="language-mysql">-- 修改单表的记录update 表名set 列=新值,列=新值,...where 筛选条件;-- 修改多表的记录update 表1inner|left|right join 表2set 列=值,列=值where 筛选条件;-- ExampleUPDATE boys boINNER JOIN beauty b ON bo.`id`=b.`boyfriend_id`SET b.`phone`=`114`WHERE bo.`boyName`=`张无忌`;UPDATE boys boRIGHT JOIN beauty b ON bo.`id`=b.`boyfriend_id`SET b.`boyfriend_id`=2WHERE bo.`id` IS NULL;</code></pre><h3 id="删除语句delete"><a href="#删除语句delete" class="headerlink" title="删除语句delete"></a>删除语句delete</h3><pre class=" language-mysql"><code class="language-mysql">-- 单表删除delete from 表1,表2inner|left|right join 表2on 连接条件where 筛选条件;            -- 多表删除truncate table 表名;</code></pre><ul><li>注意<ul><li>如果删除的表中有自增长列，delete后再插入数据，值从断点开始，ertruncate从1开始</li><li>truncate 没有返回值，delete有返回值</li><li>truncate不能回滚，delete可以回滚</li></ul></li></ul><h2 id="3-DDL语言"><a href="#3-DDL语言" class="headerlink" title="3.DDL语言"></a>3.DDL语言</h2><h3 id="库的管理"><a href="#库的管理" class="headerlink" title="库的管理"></a>库的管理</h3><ul><li>创建</li></ul><pre class=" language-mysql"><code class="language-mysql">create database IF NOT EXISTS 库名;</code></pre><ul><li>修改 (一般不做修改 </li></ul><pre class=" language-mysql"><code class="language-mysql">-- 可改字符集：ALTER DATABASE books CHARACTER SET gbk;</code></pre><ul><li>删除</li></ul><pre class=" language-mysql"><code class="language-mysql">DROP DATABASE IF EXISTS books;</code></pre><h3 id="表的管理"><a href="#表的管理" class="headerlink" title="表的管理"></a>表的管理</h3><ul><li><p>创建</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE 表名(    列名 列的类型(长度)约束,    列名 列的类型(长度)约束,    列名 列的类型(长度)约束,);CREATE TABLE book(    id INT,#编号    bName VARCHAR(20),    authorId INT,    publishDate DATETIME);</code></pre></li><li><p>修改</p><pre class=" language-mysql"><code class="language-mysql">-- 修改列名ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;-- 修改列的类型或约束ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;-- 添加新列ALTER TABLE author ADD COLUMN annual DOUBLE;-- 删除列ALTER TABLE author DROP COLUMN annual;-- 修改表名ALTER TABLE author RENAME TO book_author;</code></pre></li><li><p>删除</p><pre class=" language-mysql"><code class="language-mysql">DROP TABLE IF EXISTS book_author;-- 通用写法DROP DATABASE IF EXISTS 旧库名;CREATE DATABASE 新库名;DROP TABLE IF EXISTS 旧表名;CREATE TABLE 表名();</code></pre></li><li><p>表的复制</p><pre class=" language-mysql"><code class="language-mysql">-- 仅仅复制表的结构CREATE TABLE LIKE author;复制表的结构+数据CREATE TABLE copy2SELECT * FROM author;-- 仅复制某些字段CREATE TABLE copy4SELECT id，au_nameFROM authorWHERE 0;</code></pre></li></ul><h3 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h3><blockquote><p>选择类型越简单越好，能保存数值的类型越小越好</p></blockquote><ul><li><p>整形</p><ul><li>用UNSIGNED标识有无符号，超范围则为临界值，如果不设置长度，会有默认的长度</li><li>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配ZEROFILL</li></ul></li><li><p>小数</p><ul><li>浮点数  float(M,D) double(M,D)</li><li>定点数  DEC(M,D) DECIMAL(M,D)</li><li>特点：M为总位数，D为小数位数，默认float、double符合范围即可，decimal默认10,0    </li></ul></li><li><p>字符型</p><ul><li><p>较短文本char、varchar</p><p>char固定长度字符M默认为1，varchar可变长度字符M无默认必须指定，char性能高</p></li><li><p>较长文本test、blob</p></li></ul></li><li><p>枚举</p></li><li><p>集合</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE tab_set(    s1 SET/ENUM('a','b','c','d'));        </code></pre><p>集合插入多个，枚举插入一个</p></li><li><p>日期型</p><p>date、datetime、timestamp、time、year<br>datetime从1000-1-1到9999-12-31<br>timestamp则和实际时区有关，反应实际时间，且受mysql版本和sqlmode的影响，范围1970某时到2038某时</p></li></ul><h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><p>限制表中的数据，为了保证表中的数据的准确性和可靠性</p><ul><li><p>六大约束</p><ul><li>NOT NULL</li><li>DEFAULT：保证该字段有默认值</li><li>PRIMARY KEY：主键，用于保证该字段的值的唯一性，并且非空</li><li>UNIQUE:唯一，用于保证该字段的值具有唯一性，可以为空</li><li>CHECK:（mysql中不支持）</li><li>FOREIGN KEY:外键，用于限制两个表的关系，用于保证该字段的值必须来自主表的关联列的值，在从表添加外键约束，用于引用主表中的某列的值，比如各种编号</li></ul></li><li><p>添加约束时机</p><ul><li><p>创建表时</p><ul><li><p>列级约束<br>直接在字段名和类型后面追加约束类型，六种语法都支持，但外键无效果</p></li><li><p>表级约束<br>六种中除了非空和默认都支持</p><pre class=" language-mysql"><code class="language-mysql">[constraint 约束名] 约束类型(字段名) [FOREIGN KEY() REFERENCE 表名(字段名)];CREATE TABLE IF NOT EXISTS stuinfo(    id INT PRIMARY KEY,    stuname VARCHAR(20) NOT NULL,    age INT DEFAULT 18,    seat INT UNIQUE,    majorid INT,    CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCE major(id));</code></pre></li><li><p>主键和UNIQUE：<br>主键只能在一个表里有一个，但可以有联合主键（不推荐），UNIQUE可以有多个，也可以组合        </p></li><li><p>外键<br>要求在从表设置外键关系、从外的外键列的类型和朱标的关联列的类型要求一致或兼容，名称无要求<br>主表的关联列必须是一个key（一般时主键或UNIQUE）<br>删除数据时先删从表才能再删除主表</p></li></ul></li></ul></li><li><p>修改表时</p><ul><li><p>列级约束</p><pre class=" language-mysql"><code class="language-mysql">  ALTER TABLE stuinfo   MODIFY COLUMN stuname VARCHAR(20) 约束;</code></pre></li><li><p>表级约束</p><pre class=" language-mysql"><code class="language-mysql">  ALTER TABLE stuinfo   ADD UNIQUE(seat);  ALTER TABLE stuinfo   ADD FOREIGN KEY(majorid) REFERENCE major(id);</code></pre></li></ul></li><li><p>修改表时删除约束</p><pre class=" language-mysql"><code class="language-mysql">  NOT NULL 改为NULL 默认改为不写   -- 删除主键  ALTER TABLE stuinfo   DROP PRIMARY KEY;  -- 删除UNIQUE   ALTER TABLE 表名   DROP INDEX 字段名;  -- 删除外键   ALTER TABLE 表名   DROP FOREIGN KEY 字段名;</code></pre></li></ul><h3 id="标识列：自增长列"><a href="#标识列：自增长列" class="headerlink" title="标识列：自增长列"></a>标识列：自增长列</h3><ul><li>类型后+AUTO_INCREMENT</li><li>要求仅给主键、外键或UNIQUE类型添加</li><li>一个表至多一个标识列</li><li>修改为非标识列时直接后面不写</li></ul><h2 id="TCL语言"><a href="#TCL语言" class="headerlink" title="TCL语言"></a>TCL语言</h2><h3 id="事务和事务处理"><a href="#事务和事务处理" class="headerlink" title="事务和事务处理"></a>事务和事务处理</h3><blockquote><p>事务：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行</p></blockquote><ul><li><p>ACID属性</p><ul><li>原子性：事务是一个不可分割的工作单位，操作要么都发生要么都不发生</li><li>一致性：事务必须是一个数据库从一个一致性状态变换到另一个一致性状态</li><li>隔离性：一个事务的执行不能被其他事务干扰，事务内部操作对其他并发事务隔离，不可相互干扰</li><li>持久性：一个事务一旦被提交，他对数据库中的改变就是永久性的，后续操作不会有任何影响</li></ul></li><li><p>隐式事务没有明显的开始和结束如：insert、update、delete</p><p>一般的显式事务都是insert、update、delete，显示事务必须先设置自动提交功能为禁用set autocommit=0;</p><pre class=" language-mysql"><code class="language-mysql">开启事务：set autocommit=0;start transaction;编写sql结束事务-- 结束时才决定提交事务或回滚事务</code></pre></li><li><p>并发</p><ul><li><p>脏读：2读取了1没提交的数据（例如1回滚 read uncommitted</p></li><li><p>不可重复读：2读了数据后1更新 read committed</p></li><li><p>幻读：2读取了后1插入数据 repeatable read</p><pre class=" language-mysql"><code class="language-mysql">-- 设置当前连接的隔离级别set transaction isolation level read committed;-- 设置数据库系统的全局的隔离级别set global transaction isolation level read committed;savepoint 节点名;rollback to 节点名;</code></pre></li></ul></li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul><li><p>视图：虚拟表，和普通表一样使用 重用语句，简化操作，保护数据，提高安全性</p></li><li><p>查看视图</p><pre class=" language-mysql"><code class="language-mysql">desc 视图名；show create view 视图名；</code></pre></li><li><p>视图的更新</p><pre><code>CREATE OR REPLACE VIEW my_vl ASSELECT .....或 ALTER VIEW +后续一样</code></pre><p>视图的增删会影响原表<br>tips：包含以下关键字的sql语句：分组函数、distinct、GROUP BY、HAVING 、UNION或者UNION ALL、SELECT、JOIN、FROM、WHERE子句的子查询引用了FROM子句中的视图不允许更新</p></li><li><p>视图的删除</p><pre class=" language-mysql"><code class="language-mysql">DROP VIEW 视图名、视图名;</code></pre></li><li><p>视图和表的区别</p><p>视图创建用create view，基本不占用实际物理空间，只是保存sql逻辑，一般不能增删改，表创建用create table，占用实际物理空间，保存了具体数据</p></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>系统变量</p><ul><li><p>查看所有的系统|会话变量</p><pre class=" language-mysql"><code class="language-mysql">SHOW GLOBAL|SESSION VARIABLES [LIKE '%char%'];</code></pre></li><li><p>查看某个指定的系统|会话变量</p><pre class=" language-mysql"><code class="language-mysql">SELECT @@GLOBAL|SESSION.系统变量名</code></pre></li><li><p>为某个系统变量赋值 若显式声明则默认为 SESSION            </p><pre class=" language-mysql"><code class="language-mysql">SET GLOBAL|SESSION 名=值;SET @@GLOBAL|SESSION.系统变量名=值;</code></pre></li><li><p>全局变量：作用域：每次启动全局变量赋初值，对全局会话有效，重启无效                        </p></li><li><p>会话变量：针对于单独的会话（连接）有效</p></li></ul></li><li><p>自定义变量</p></li></ul><h3 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h3><h4 id="储存过程"><a href="#储存过程" class="headerlink" title="储存过程"></a>储存过程</h4><blockquote><p>存储过程是一组预先编译好的sql语句的集合，提高重用性、简化操作，减少编译和连接次数，提高效率</p></blockquote><ul><li><p>创建</p><pre><code>CREATE PROCEDURE 储存过程名(参数列表)BEGIN    储存过程体END</code></pre><ul><li>参数模式：IN作为输入 OUT作为返回值 INOUT作为输入且返回值</li><li>如果存储过程体中仅有一句话则可省略BEGIN END</li><li>储存过程中每句sql结尾必须加分号，结尾可以用DELIMITER重新设置：DELIMITER 结束标记</li></ul></li><li><p>调用</p><pre class=" language-mysql"><code class="language-mysql">CALL 储存过程名(实参列表);DELIMITER $CREATE PROCEDURE myp1()BEGIN    INSERT INTO admin(user,`password`)    VALUES(),(),(),()END $CALL myp1()$CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))BEGIN    SELECT bo.*    FROM boys bo    RIGHT JOIN beauty b ON bo.id= b.boyfriend_id    WHERE b.name=beautyName;END $-- 创建储存过程实现传入用户名和密码，插入到admin表中CREATE PROCEDURE test_pro1(IN username VARCHAR(20)),IN loginPwd VARCHAR(20)BEGIN    INSERT INTO admin(admin.username,PASSWORD)    VALUES(username,loginpwd);END $-- 传入女神名称返回 女神and男神格式的字符串CREATE PROCEDURE test_pro5(IN beautyName VARCHAR(20),OUT str VARCHAR(50))BEGIN    SELECT CONCAT(beautyName,' and ',IFNULL(boyName,'null')) INTO str    FROM boys bo                                RIGHT JOIN beauty b ON b.boyfriend_id=bo.id    WHERE b.name=beautyName;END $CALL test_pro5('小昭',@str)$SELECT @str $</code></pre></li><li><p>删除</p><pre class=" language-mysql"><code class="language-mysql">DROP PROCEDURE 储存过程名</code></pre></li><li><p>查看</p><pre class=" language-mysql"><code class="language-mysql">SHOW CREATE PROCEDURE 存储过程名;</code></pre></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><blockquote><p>有且只能有一个返回值，多用于处理数据</p></blockquote><pre class=" language-mysql"><code class="language-mysql">CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型BEGIN    函数体ENDCREATE FUNCTION myf1() RETURNS INTBEGIN    DECLARE c INT DEFAULT 0;    SELECT COUNT(*) INTO c    FROM employees    RETURNS c;END $</code></pre><h3 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h3><ul><li><p>顺序结构</p></li><li><p>分支结构</p><ul><li><p>IF函数</p><pre class=" language-mysql"><code class="language-mysql">SELECT IF(表达式1,表达式2，表达式3) ->同三目运算符算法</code></pre></li><li><p>CASE</p><pre class=" language-mysql"><code class="language-mysql">-- 简单函数：枚举这个字段所有可能的值CASE 变量|表达式|字段WHEN 要判断的值 THEN 返回的值或语句1;WHEN 要判断的值 THEN 返回的值或语句2;...ELSE 返回的值或语句3;END    CASE;-- 搜索函数：可以写判断，并且搜索函数只会返回第一个符合条件的值，其他case被忽略CASE     WHEN 要判断的表达式 THEN 返回的值或语句1;    WHEN 要判断的表达式 THEN 返回的值或语句2;    ...    ELSE 返回的值或语句3;END CASE;</code></pre></li></ul></li><li><p>循环结构</p><pre><code>WHILE LOOP REPEATWHILE 循环条件 DO    循环体;END WHILE[标签];-- 例：CREATE PROCEDURE pro_while1(IN insertCount INT)BEGIN    DECLAR i INT DEFAULT 1;    a: WHILE i&lt;=insertCount DO    INSERT INT amin(username,`passsword`) VALUES(CONCAT(&#39;Rose&#39;+i),&#39;666&#39;);    IF i&gt;=20 THEN LEAVE a;    SET i=i+1;END WHILE a;END;[标签:]LOOP     循环体;END LOOP [标签];[标签:]REPEAT                循环体;                UNTIL 结束循环的条件;            END REPEAT {标签};            循环控制                 iterate继续，结束本次循环，继续下一次                leave 跳出，结束当前所在的循环</code></pre><script src="https://eqcn.ajz.miesnfu.com/wp-content/plugins/wp-3d-pony/live2dw/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({ "model": { jsonPath:"https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json","scale": 1 }, "display": { "position": "right","width": 100, "height": 200,"hOffset": 0, "vOffset": -20 }, "mobile": { "show": true, "scale": 0.5 },"react": { "opacityDefault": 0.7, "opacityOnHover": 0.2 } });</script></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 关系型数据库 </tag>
            
            <tag> MySQL基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程之美笔记</title>
      <link href="/2019/10/18/bing-fa-bian-cheng-zhi-mei/"/>
      <url>/2019/10/18/bing-fa-bian-cheng-zhi-mei/</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程之美"><a href="#并发编程之美" class="headerlink" title="并发编程之美"></a>并发编程之美</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="1-线程基础"><a href="#1-线程基础" class="headerlink" title="1.线程基础"></a>1.线程基础</h3><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>概念  CPU分配的基本单位</li></ul><h4 id="线程启动的三种方式"><a href="#线程启动的三种方式" class="headerlink" title="线程启动的三种方式"></a>线程启动的三种方式</h4><ul><li>继承Thread</li><li>实现runnable</li><li>使用FutureTask<ul><li>自定义CallerTask类实现Callable接口，放入FutureTask队列中new Thread（）</li></ul></li></ul><h4 id="线程通知与等待"><a href="#线程通知与等待" class="headerlink" title="线程通知与等待"></a>线程通知与等待</h4><ol><li><p>wait()</p><p>当一个线程共享变量调用wait，则该进程挂起，直到其他线程调用notify or notifyall or 该线程的interrupt</p></li><li><p>notify()</p><p>唤醒在该共享变量调用wait()挂起的线程，多个挂起则随机唤醒一个</p></li><li><p>notifyall()</p></li></ol><h4 id="等待线程执行结束"><a href="#等待线程执行结束" class="headerlink" title="等待线程执行结束"></a>等待线程执行结束</h4><ul><li><p>join()</p><p>调用后阻塞主进程，线程执行完毕后才返回</p></li></ul><h4 id="线程睡眠"><a href="#线程睡眠" class="headerlink" title="线程睡眠"></a>线程睡眠</h4><ul><li><p>sleep()</p><p>暂停执行权，退出CPU资源调度，但依然持有锁</p></li></ul><h4 id="让出CPU资源"><a href="#让出CPU资源" class="headerlink" title="让出CPU资源"></a>让出CPU资源</h4><ul><li><p>yield()</p><p>调用时让出已有的时间片，非阻塞</p></li></ul><h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><ul><li><p>interrupt()</p><p>设置调用方法的线程的中断标志</p></li><li><p>isInterrupted()</p><p>获取调用该方法对象的线程的中断标志</p></li><li><p>Interrupted()</p><p>获取当前执行线程（而不是调用该方法的线程）的中断标志并清除</p></li></ul><h4 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h4><ul><li>保存执行现场，转为就绪，等待</li><li>时机<ul><li>被其他线程中断</li><li>CPU时间片用完处于就绪状态</li></ul></li></ul><h4 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h4><ul><li><p>死锁四条件</p><ul><li><p>互斥条件</p><p>单个资源要求独有</p></li><li><p>请求并持有</p></li><li><p>不可剥夺条件</p></li><li><p>环路等待条件</p></li></ul></li><li><p>如何避免</p><ul><li>只能通过破坏请求并持有和环路等待条件</li></ul></li></ul><h4 id="守护线程与用户线程"><a href="#守护线程与用户线程" class="headerlink" title="守护线程与用户线程"></a>守护线程与用户线程</h4><ul><li>JVM在只有守护进程运行时退出</li><li>setDaemon()</li></ul><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><ul><li><p>内部实现了一个ThreadLocalMap类型的threadLocals变量，存取对应线程的变量</p></li><li><p>不支持继承的变量</p></li><li><p>InheritableThreadLocal</p><ul><li>可访问父类进程中设置的本地变量</li><li>子进程在构造InheritableThreadLocal时复制一份写入自身的Map</li></ul></li></ul><h3 id="2-其他基础"><a href="#2-其他基础" class="headerlink" title="2.其他基础"></a>2.其他基础</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li><p>并行与并发</p></li><li><p>线程安全问题</p></li><li><p>内存内存可见性问题</p></li></ul><h4 id="sychronized"><a href="#sychronized" class="headerlink" title="sychronized"></a>sychronized</h4><ul><li>语义 <ul><li>将sychronized块内的变量从工作内存清除，线程从主内存中读取数据</li></ul></li><li>实现原理<ul><li>Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用</li><li>Monitor结构<ul><li>Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li><li>EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。</li><li>RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。</li><li>Nest:用来实现重入锁的计数。</li><li>HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li><li>Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁</li></ul></li><li>当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权</li><li>锁住方法则方法会标识ACC_SYNCHRONIZED</li></ul></li><li>sychronized是重量级锁，会导致上下文切换</li><li><strong>如果一个对象中有两个方法同时被synchronized，则同一个对象，调用这两个方法时，只能同时执行一个</strong></li></ul><h4 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h4><ul><li>保证可见性，但不保证原子性</li><li>原理<ul><li>对volatile变量写操作时，会在write操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存</li><li>对volatile变量读操作时，会在read操作前加入一条load屏障指令，从主内存中读取共享变量</li></ul></li><li>使用场景<ul><li>写入变量时不依赖变量的当前值</li><li>读写变量时没有加锁</li></ul></li></ul><h4 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h4><ul><li>由处理器提供boolean compareAndSwapLong(Object obj,long valueOffset,long expect, long update)方法</li><li>ABA问题由JDK的AtomicStampedReference提供给每个类的时间戳解决</li></ul><h4 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h4><ul><li><p>long objectFieldOffset(Field field)</p><blockquote><p>返回指定变量所属类中的内存偏移地址</p></blockquote></li><li><p>int arrayBaseOffset(Class arrayClass)</p><blockquote><p>获取数组中第一个元素的地址</p></blockquote></li><li><p>int arrayIndexScale(Class arrayClass)</p><blockquote><p>获取数组中第一个元素占用的字节</p></blockquote></li><li><p>boolean compareAndSwapLong(Object obj,long offset,long expect,long update)</p><blockquote><p>比较对象obj中偏移量为offset的变量是否与expect相等</p></blockquote></li></ul><p>JDK1.8增加的</p><ul><li>long getAndSetLong(Object obj,long offste,long update)</li><li>long getAndAddLong(Object obj,long offset long addValue)</li></ul><h4 id="Java指令重排"><a href="#Java指令重排" class="headerlink" title="Java指令重排"></a>Java指令重排</h4><ul><li>为保证有序性 happens-before原则<ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start() 方法先行发生于此线程的每一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束，可以通过Thread.isAlive()的返回值检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul></li></ul><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><ul><li>多个变量放入了同一个缓存行则，单线程只能操作单个缓存行，则会出现伪共享</li></ul><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ul><li>乐观锁与悲观锁</li><li>公平锁与非公平锁<ul><li>公平ReentrantLock pairLock=new ReentrantLock(true)</li><li>非公平ReentrantLock pairLock=new ReentrantLock(false)</li></ul></li><li>独占锁与共享锁<ul><li>独占锁是一种悲观锁，任何时候只有一个线程可以获得，如ReentrantLock</li><li>共享锁是一种乐观锁，可以由多个进程持有，可以多个进程读取</li></ul></li><li>自旋锁<ul><li>为了解决线程获取锁失败后从用户态切换为内核态传递变量参数被挂起，获得锁时再次切换为内核态唤醒进程，切换开销大</li><li>自旋锁未申请到锁时可能多次尝试，参数设置-XX:PreBlockSpinsh设置尝试次数，默认10</li></ul></li></ul><h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h2><h3 id="3-ThreadLocalRandom类原理剖析"><a href="#3-ThreadLocalRandom类原理剖析" class="headerlink" title="3.ThreadLocalRandom类原理剖析"></a>3.ThreadLocalRandom类原理剖析</h3><h4 id="Random类的并发"><a href="#Random类的并发" class="headerlink" title="Random类的并发"></a>Random类的并发</h4><ul><li>单个Random实例在多线程下生成随机数时，多个线程同时计算随机数来计算新的种子时，多个线程会竞争同一个原子变量的更新，由于CAS操作，只有一个线程会成功，其他线程自旋重试，降低了并发性能</li></ul><h4 id="ThreadLocalRandom"><a href="#ThreadLocalRandom" class="headerlink" title="ThreadLocalRandom"></a>ThreadLocalRandom</h4><ul><li>每个线程生成随机数时根据自己老的种子计算新的种子，在根据自己新的种子计算随机数，提高了并发性能</li></ul><h4 id="ThreadLocalRandom源码"><a href="#ThreadLocalRandom源码" class="headerlink" title="ThreadLocalRandom源码"></a>ThreadLocalRandom源码</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Random类nextInt()中调用的next()</span><span class="token keyword">do</span> <span class="token punctuation">{</span>    oldseed <span class="token operator">=</span> seed<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nextseed <span class="token operator">=</span> <span class="token punctuation">(</span>oldseed <span class="token operator">*</span> multiplier <span class="token operator">+</span> addend<span class="token punctuation">)</span> <span class="token operator">&amp;</span> mask<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>seed<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>oldseed<span class="token punctuation">,</span> nextseed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ThreadLocalRandom类nextInt()中调用的nextSeed()</span>Thread t<span class="token punctuation">;</span> <span class="token keyword">long</span> r<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// read and update per-thread seed</span>UNSAFE<span class="token punctuation">.</span><span class="token function">putLong</span><span class="token punctuation">(</span>t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SEED<span class="token punctuation">,</span>               r <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> SEED<span class="token punctuation">)</span> <span class="token operator">+</span> GAMMA<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> r<span class="token punctuation">;</span></code></pre><p>其中ThreadLocalRandom的current()初始化自己的种子，避免了并发请求种子</p><h3 id="4-并发包中原子操作类"><a href="#4-并发包中原子操作类" class="headerlink" title="4.并发包中原子操作类"></a>4.并发包中原子操作类</h3><h4 id="原子变量操作类"><a href="#原子变量操作类" class="headerlink" title="原子变量操作类"></a>原子变量操作类</h4><ul><li>AtomicLong<ul><li>提供自增自减的原子操作<ul><li>通过调用Unsafe类的CompareAndSwapLong</li></ul></li></ul></li><li>AtomicReference</li><li>LongAdder<ul><li>使用cell数组，对每个数组元素进行操作再计算统计结果</li><li>使用了Contended注解避免伪共享</li><li>cell数组操作时通过线程随机数计算访问的Cell元素下标，没有竞争则base基值，为null则扩容，通过cas操作volatile修饰的cellbusy变量确定是否可以操作</li></ul></li><li>LongAccumulator<ul><li>LongAdder的功能增强版。LongAdder的API只有对数值的加减，而LongAccumulator提供了自定义的函数操作</li></ul></li></ul><h3 id="5-并发List"><a href="#5-并发List" class="headerlink" title="5.并发List"></a>5.并发List</h3><p>写时复制策略，Reetrantlock独占锁来保证同时只有一个线程对快照进行修改，内部的array为volatile</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><ul><li>初始化</li><li>添加元素<ul><li>写时复制原则，添加时加锁，写完释放锁</li></ul></li><li>获取元素<ul><li>写时复制策略带来的弱一致性</li></ul></li><li>修改元素</li><li>删除元素</li><li>弱一致性的迭代器</li></ul><h3 id="6-锁原理剖析"><a href="#6-锁原理剖析" class="headerlink" title="6.锁原理剖析"></a>6.锁原理剖析</h3><h4 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h4><ul><li>park()<ul><li>默认线程不持有许可，调用此方法则将线程挂起，调用此方法的线程被中断后将直接返回</li></ul></li><li>unpark()<ul><li>线程调用此方法，若被park()阻塞，则被唤醒继续执行</li><li>若未被park()阻塞，则调用了unpark()后持有了许可，park()方法将不能阻塞</li></ul></li><li>parkNanos(long nanos)<ul><li>相比park设定了挂起最长时间，超时则返回</li></ul></li><li>park(Object blocker)<ul><li>Thread类中包含volatile Object parkBlocker变量，存取park方法传递的变量</li></ul></li></ul><h4 id="AQS容器"><a href="#AQS容器" class="headerlink" title="AQS容器"></a>AQS容器</h4><ul><li>锁的底层支持<ul><li>FIFO的双向队列，节点head、tail记录队首队尾，元素节点为Node</li><li>Node节点中<ul><li>thread变量存放线程</li><li>SHARED 标记获取共享资源是被阻塞挂起放入队列</li><li>EXCLUSIVE 标记获取独占资源被阻塞放入队列</li></ul></li><li>队列中的成员变量<ul><li>waitStatus记录当前线程等待状态<ol><li>CANCELLED 线程被取消</li><li>SIGNAL 线程需要被唤醒</li><li>CONDITION 在条件队列里等待</li><li>PROPAGATE 释放共享资源需要通知其他节点</li></ol></li><li>prev、next</li></ul></li><li>state状态信息<ul><li>ReetrantLock中state表示可重入次数</li><li>ReetrantReadWriteLock中，高16位表示获取读锁的次数，低16位表示获取写锁可重入次数</li><li>Semaphone中，表示可用信号的个数</li><li>CountDownLatch中，表示计数器当前的值</li></ul></li><li>内部类ConditionObject<ul><li>本身为条件变量，对应一个单链表条件队列储存阻塞线程，结合锁实现线程同步</li></ul></li><li>state操作<ul><li>acquire() release()等对独占方式操作</li><li>acquireShared() releaseShared()等对共享方式操作</li></ul></li><li>独占方式流程<ol><li>tryAcquire() CAS尝试state，成功则返回，失败则将Node.EXCLUSIVE尾插AQS，并park()挂起自己</li><li>tryRelease() CAS尝试state，unpark()AQS中的一个线程，线程tryAcquire()重复上述过程</li></ol></li><li>共享方式流程<ol><li>tryAcquireShared() CAS尝试state，成功则返回，失败则将Node.EXCLUSIVE尾插AQS，并park()挂起自己</li><li>tryReleaseShared() CAS尝试state，unpark()AQS中的一个线程，线程tryAcquireShared()重复上述过程</li></ol></li><li>AQS队列维护流程<ul><li>创建时头尾节点均为null，CAS创建哨兵节点</li><li>再CAS插入Node</li></ul></li></ul></li><li>条件变量的支持<ul><li>newCondition()可以创建一个条件变量，当该条件变量await()后，通过addConditionWaiter()将线程放入每个条件变量对应的条件队列</li></ul></li><li>自定义同步器<ul><li>自定义AQS</li></ul></li></ul><h4 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h4><ul><li><p>获取锁</p><ul><li><p>lock()</p><p>调用时state值+1，</p><p>lock 优先考虑获取锁，待获取锁成功后，才响应中断。</p></li><li><p>lockInterruptibly()<br>lockInterruptibly 优先考虑响应中断，而不是响应锁的普通获取或重入获取</p></li><li><p>tryLock()</p><p>尝试获取锁，成功则true否则false，不会引起当前线程阻塞</p></li><li><p>tryLock(long timeout,TimeUnit unit)</p><p>设置超时时间</p></li></ul></li><li><p>释放锁</p><ul><li>unlock()</li></ul></li></ul><h4 id="ReetrantReadWriteLock"><a href="#ReetrantReadWriteLock" class="headerlink" title="ReetrantReadWriteLock"></a>ReetrantReadWriteLock</h4><ul><li>内部维护了一个ReadLock和WriteLock</li><li>分别实现了lock(),lockInterruptibly(),tryLock(),tryLock(Long timeout,TimeUnit unit),unlock()方法</li><li>state变量高16位为读锁的获取个数，低16位为写锁可重入次数</li></ul><h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><ul><li><p>为不可重入锁，提供了三种类型锁</p><ul><li>writeLock写锁</li><li>readLock悲观读锁</li><li>tryOptimisticRead乐观读锁，通过判断validate的返回值来获知其他线程是否持有写锁</li></ul></li><li><p>实例</p><p>Point类的move(),distanceFromOrigin(),moveIfAtOrigin()方法，分别使用写锁、乐观读锁以及悲观读锁转写锁</p></li></ul><h3 id="7-并发队列"><a href="#7-并发队列" class="headerlink" title="7.并发队列"></a>7.并发队列</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>单链表实现，维护头尾节点，头为null值</p><ul><li><p>offer()</p><p>通过CAS向尾部插入节点，失败则自旋尝试</p></li><li><p>poll()</p><p>CAS从头部删除节点，失败则goto到外层重试循环</p></li></ul><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><ul><li><p>包含takeLock、putLock、notEmpty、notFull两把锁以及两个条件变量，以及一个AtomicInteger类型的count</p></li><li><p>offer</p><p>获取putLock，节点入队，notFull条件变量调用signal，调用signalNotEmpty()方法</p></li><li><p>poll</p><p>获取takeLock，节点出队，notEmpty.signal()，调用signalNotFull()方法</p></li><li><p>remove</p><p>fullyLock()方法双重加锁,takeLockputLock</p></li></ul><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>通过独占锁实现</p><ul><li><p>offer</p><p>ReetrantLock加锁，enqueue()中完成入队及notEmpty.signal()，解锁</p></li><li><p>put</p><p>ReetrantLock使用lockInterruptibly()加锁，队列满则while循环await，出循环则enqueue，解锁</p></li><li><p>poll</p><p>ReetrantLock加锁，dequeue()完成出队及notFulls</p></li><li><p>take</p><p>阻塞方法，ReetrantLock使用lockInterruptibly()加锁，队列空则while循环await，出循环则dequeue，解锁</p></li></ul><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>使用自旋锁allocationSpinLock，通过CAS保证只有一个线程进行扩容队列</p><ul><li><p>offer</p><p>插入元素ReetrantLock加锁，while判断tryGrow，然后堆上用Comparator上滤，notEmpty.signal()，解锁</p></li><li><p>put</p><p>同offer</p></li><li><p>poll</p><p>取內部建堆根节点，为空则返回null，ReetrantLock加锁，dequeue中用Comparator上滤，解锁</p></li><li><p>take</p><p>取堆根节点，为空则阻塞，lock.lockInterruptibly()，优先响应中断，while队列空则notEmpty.await()</p></li></ul><h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>插入元素实现Delayed接口，每个元素包含过期时间，包含ReetrantLock和available条件变量</p><ul><li><p>offer</p><p>插入元素，不可插入null</p></li><li><p>take</p><p>获取并移除过期元素，若没有过期元素则等待</p></li><li><p>poll</p><p>获取并移除过期元素，若没有过期元素则返回null</p></li></ul><h3 id="8-ThreadPoolExecutor"><a href="#8-ThreadPoolExecutor" class="headerlink" title="8.ThreadPoolExecutor"></a>8.ThreadPoolExecutor</h3><p>线程池在执行大量异步任务时能够提供较好的性能，减少了执行任务的创建销毁线程的开销，提供了资源限制和管理的手段</p><h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><ul><li><p>底层调用ThreadPoolExecutor</p></li><li><p>ctl为AtomicInteger的变量，记录线程池状态和线程个数</p><p>其中高3位表示线程池状态，低29位表示线程数量</p><ul><li><p>RUNNING</p><p>接受新任务并且处理阻塞队列里的任务</p></li><li><p>SHUTDOWN</p><p>拒绝新任务但是处理阻塞队列里的任务</p></li><li><p>STOP</p><p>拒绝新任务并且抛弃阻塞队列里的任务 ，同时会中断正在处理的任务 </p></li><li><p>TIDYING</p><p>所有任务都执行完（包含阻塞队列里面的任务）后当前线程池活动线程数为0将要调用 terminated 方法 </p></li><li><p>TERMINATED</p><p> 终止状态 terminated 方法调用完成以后的状态</p></li></ul></li><li><p>线程池参数</p><ul><li>corePoolSize：核心线程数量</li><li>maximumPoolSize：线程最大线程数</li><li>workQueue：阻塞队列，存储等待执行的任务，很重要，会对线程池运行过程产生重大影响</li><li>keepAliveTime：线程没有任务执行时最多保持多久时间终止（当线程中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交核心线程外的线程不会立即销毁，而是等待，直到等待的时间超过keepAliveTime）</li><li>unit：keepAliveTime的时间单位</li><li>threadFactory：线程工厂，用来创建线程，若不设置则使用默认的工厂来创建线程，这样新创建出来的线程会具有相同的优先级，并且是非守护的线程，同时也会设置好名称</li><li>rejectHandler：当拒绝处理任务时(阻塞队列满)的策略（AbortPolicy默认策略直接抛出异常、CallerRunsPolicy用调用者所在的线程执行任务、DiscardOldestPolicy丢弃队列中最靠前的任务并执行、DiscardPolicy直接抛弃</li></ul></li><li><p>线程池类型</p><ul><li><p>newCachedThreadPool</p><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程  ，队列为同步队列</p></li><li><p>newFixedThreadPool</p><p>创建一个定长线程池，核心线程和最大线程数均为nThreads，超出的线程会在队列中等待</p></li><li><p>newScheduledThreadPool</p><p>创建一个定长线程池，指定一定延迟时间或定时进行任务调度</p></li><li><p>newSingleThreadExecutor</p><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p></li></ul></li><li><p>ThreadPoolExecutor其他成员</p><ul><li>mainLock独占锁，控制新增worker线程的操作的原子性</li><li>Worker继承AQS和Runnable接口，具体承载任务</li><li>DefaultThreadFactory</li></ul></li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ul><li><p>execute()</p><ol><li>若线程池线程个数小于corePoolSize则addWorkers()</li><li>若大于等于corePoolSize则判断线程池状态，running则放入阻塞队列，否则抛弃</li><li>添加成功后进行状态校验，非running则移除并执行拒绝策略，并判断线程池是否为空</li></ol></li><li><p>addWorker()</p><ol><li>双重循环通过CAS增加线程数，外层判断线程池状态，内层设置线程个数</li><li>使用全局独占锁将任务添加至workers(HashSet类型)工作集</li></ol></li><li><p>runWorker</p><p>获取独占锁，task.run()</p><p>其中留了protected方法beforeExecute、afterExecute</p><p>任务执行结束后调用processWorkerExit清理</p></li><li><p>shutdown</p><p>不接受新任务，仅完成阻塞队列内任务</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>    mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">advanceRunState</span><span class="token punctuation">(</span>SHUTDOWN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">onShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hook for ScheduledThreadPoolExecutor</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>shutdownNow</p><p>不接受新任务，且丢弃阻塞队列内任务，返回List&lt;Runnable&gt;</p></li><li><p>awaitTermination</p><ul><li>阻塞当前线程，仅当线程池为Terminated或等待时间超时才返回，Terminated返回true，超时返回false</li></ul></li></ul><h3 id="9-ScheduledThreadPoolExecutor"><a href="#9-ScheduledThreadPoolExecutor" class="headerlink" title="9.ScheduledThreadPoolExecutor"></a>9.ScheduledThreadPoolExecutor</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>阻塞队列为DelayedWorkQueue</p><ul><li>7种状态<ul><li>NEW</li><li>COMPLETING</li><li>NORMAL</li><li>EXCEPTIONAL</li><li>CANCELLED</li><li>INTERRUPTING</li><li>INTERRUPTED</li></ul></li><li>转换路径<ul><li>NEW-&gt;COMPLETING-&gt;NORMAL</li><li>NEW-&gt;COMPLETING-&gt;EXCEPTIONAL</li><li>NEW-&gt;CANCELLED</li><li>NEW-&gt;INTERRUPTING-&gt;INTERRUPTED</li></ul></li><li>ScheduledFutureTask内部变量period<ul><li>为0则任务一次性，执行后即退出</li><li>负数则为固定延迟的定时可重复执行的任务</li><li>正数则为固定频率定时可重复执行任务</li></ul></li></ul><h4 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h4><ul><li><p>schedule(Runnable command,long delay,TimeUnit unit)</p><p>提交一个延迟执行的任务</p><ol><li>参数校验后command任务转换为ScheduledFutureTask，完成Runnable与Callable的适配</li><li>delayedExecute将任务添加至延迟队列<ul><li>判断是否关闭</li><li>入队</li><li>并再次检查状态</li><li>确保至少有一个线程在处理任务</li></ul></li><li>队列执行任务</li></ol></li><li><p>scheduleWithFixedDelay(Runnable command,long initialDelay,long delay, TimeUnit unit)</p><p>任务执行完毕后，使其延迟固定时间再次运行</p><p>流程与前者大致相同，执行FutureTask的runAndReset方法</p></li><li><p>scheduleAtFixedRate(Runnable command,long initialDelay,long period, TimeUnit unit)</p><p>相对起始时间点以固定频率调用指定的任务</p></li></ul><h3 id="10-线程同步器"><a href="#10-线程同步器" class="headerlink" title="10.线程同步器"></a>10.线程同步器</h3><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>单个线程任务执行完成后等待全部线程任务完成，即countDown为0时，返回</p><ul><li><p>void await()</p><p>调用后，阻塞当前线程，直到state为0或当前线程被中断抛出异常时才会返回</p></li><li><p>boolean await(long timeout, TimeUnit unit)</p><p>可以设置超时时长</p></li><li><p>countDown()</p><p>sync.releaseShared()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Decrement count; signal when transition to zero</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>getCount()</p></li></ul><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>可多次设置同步任务的节点，所有每到一个节点需同步完成任务，通过parties记录线程总数，count记录当前剩余任务进行中的线程数</p><ul><li><p>int await()</p><p>调用后，当parties个线程都调用了await（即全部到达屏障点）或其他线程调用当前线程的interrupt方法中断当前线程或与当前平站点关联的Generation对象的broken标志被设置为true时，返回</p></li><li><p>boolean await(long timeout,TimeUnit unit)</p><p>比前者增加超时返回</p></li><li><p>int dowait(boolean timed,long nanos)</p><ol><li>获取独占锁</li><li>计数器循环递减，此时index不为0则则放入条件队列并释放锁资源</li><li>index为0，则执行CyclicBarrier构造函数传入的任务，完毕后唤醒其他线程，重置后开始下一轮</li></ol></li></ul><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>限制执行任务的线程数量</p><ul><li><p>void acquire()</p><p>获取当前state值，减去acquires，若小于0则返回负数，挂起线程，若正数则CAS设置</p><p>公平性通过hasQueuedPredecessors()实现</p></li><li><p>acquireUninterruptibly()</p><p>对中断不响应</p></li><li><p>release()</p><p>将当前Semaphore对象的信号量+1</p></li></ul><h2 id="实践篇"><a href="#实践篇" class="headerlink" title="实践篇"></a>实践篇</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2019/06/20/java-ji-chu/"/>
      <url>/2019/06/20/java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><ul><li>基本数据类型<ul><li>byte/8</li><li>char/16</li><li>short/16</li><li>int/32</li><li>float/32</li><li>long/64</li><li>double/64</li><li>boolean/？</li></ul></li><li>缓存池<ul><li>new Integer(123)与 Integer.valueOf(123)的区别</li></ul></li></ul><h3 id="2-String"><a href="#2-String" class="headerlink" title="2.String"></a>2.String</h3><ul><li>不可变<ul><li>可以缓存hash值，不可变所以计算一次</li></ul></li><li>StringPool<ul><li>已建立的字符串将在StringPool引用</li><li>Java7以后，StringPool’被从永久代移动至堆，防止OOM</li></ul></li></ul><h3 id="3-关键字"><a href="#3-关键字" class="headerlink" title="3.关键字"></a>3.关键字</h3><ul><li>final<ul><li>修饰类则表示类不可以被继承</li><li>修饰方法表示方法不可被重写</li><li>修饰基本类型表示不可变</li><li>修饰对象表示引用不可变</li></ul></li><li>static<ul><li>修饰变量时静态变量通过类名访问，随类加载时加载</li><li>修饰方法表示其随类加载而加载，不能是抽象方法</li><li>修饰语句块表示随类加载运行一次</li><li>静态内部类表示外部类被实例才可访问</li><li>继承时的初始化顺序<ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul></li></ul></li></ul><h3 id="4-Object方法"><a href="#4-Object方法" class="headerlink" title="4.Object方法"></a>4.Object方法</h3><ul><li>hashCode()</li><li>equals()</li><li>toString()</li><li>clone()</li><li>wait()</li><li>notify()</li><li>notifyAll()</li><li>finalize()</li><li>getClass()</li></ul><h3 id="5-继承"><a href="#5-继承" class="headerlink" title="5.继承"></a>5.继承</h3><ul><li><p>抽象类不可被实例化，只能被继承</p><ul><li>使用抽象类的情况<ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的成员的访问权限，而不是都为 public。</li><li>需要继承非静态和非常量字段</li></ul></li></ul></li><li><p>Java8之前接口不可以有实现，默认字段都是static final</p><ul><li>使用接口的情况<ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li><li>需要使用多重继承</li></ul></li></ul></li><li><p>重写与重载</p><ul><li>重写<ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li></ul></li><li>重载<ul><li>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同</li></ul></li></ul></li></ul><h3 id="6-反射、异常、泛型"><a href="#6-反射、异常、泛型" class="headerlink" title="6.反射、异常、泛型"></a>6.反射、异常、泛型</h3><ul><li>反射<ul><li>通过获取字节码得到Class对象，可以控制类加载的时机</li><li>可以通过Field，Method，Constructor分别获得成员变量，方法和创建新实例</li></ul></li><li>异常<ul><li>继承Throwable的Error和Exception</li></ul></li></ul><h3 id="7-代理"><a href="#7-代理" class="headerlink" title="7.代理"></a>7.代理</h3><ul><li><p>静态代理</p><ul><li>定义接口和接口的实现类, 然后定义接口的代理对象, 将接口的实例注入到代理对象中, 然后通过代理对象去调用真正的实现类，实现过程非常简单也比较容易理解, 静态代理的代理关系在编译期间就已经确定了的</li></ul></li><li><p>动态代理</p><p>代理类在程序运行时创建的代理方式被成为动态代理。在了解动态代理之前, 我们先简回顾一下 JVM 的类加载机制中的加载阶段要做的三件事情 ( 附 Java 中的类加载器 )</p><ol><li>通过一个类的全名或其它途径来获取这个类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的 Class 对象, 作为方法区中对这个类访问的入口</li></ol><p>而我们要说的动态代理，主要就发生在第一个阶段, 这个阶段类的二进制字节流的来源可以有很多, 比如 zip 包、网络、运行时计算生成、其它文件生成 (JSP)、数据库获取。其中运行时计算生成就是我们所说的动态代理技术，在 Proxy 类中, 就是运用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 $Proxy 的代理类的二进制字节流。所谓的动态代理就是想办法根据接口或者目标对象计算出代理类的字节码然后加载进 JVM 中。</p><ul><li><p>JDK动态代理</p><p>java 动态代理最大的特点就是动态生成的代理类和委托类实现同一个接口。java 动态代理其实内部是通过反射机制实现的，也就是已知的一个对象，在运行的时候动态调用它的方法，并且调用的时候还可以加一些自己的逻辑在里面</p></li><li><p>CGLIB动态代理</p><p>CGLIB 创建动态代理类的模式是:</p><ol><li>查找目标类上的所有非 final 的 public 类型的方法 (final 的不能被重写)</li><li>将这些方法的定义转成字节码</li><li>将组成的字节码转换成相应的代理的 Class 对象然后通过反射获得代理类的实例对象</li><li>实现 MethodInterceptor 接口, 用来处理对代理类上所有方法的请求</li></ol></li><li><p>区别</p><ul><li>JDK 动态代理基于 Java 反射机制实现, 必须要实现了接口的业务类才能用这种方法生成代理对象。</li><li>CGLIB 动态代理基于 ASM 框架通过生成业务类的子类来实现。</li><li>JDK 动态代理的优势是最小化依赖关系，减少依赖意味着简化开发和维护并且有 JDK 自身支持。还可以平滑进行 JDK 版本升级，代码实现简单。基于 CGLIB 框架的优势是无须实现接口，达到代理类无侵入，我们只需操作我们关系的类，不必为其它相关类增加工作量，性能比较高</li></ul></li></ul></li></ul><h3 id="8-新特性"><a href="#8-新特性" class="headerlink" title="8.新特性"></a>8.新特性</h3><ul><li><p>Lambda</p></li><li><p>Stream</p></li></ul><h2 id="Java容器"><a href="#Java容器" class="headerlink" title="Java容器"></a>Java容器</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><ul><li>各类集合容器通过模板编程实体类-&gt;抽象类-&gt;接口来设计，于此同时，为了实现基于反射的代理功能，实体类在继承抽象的同时也会实现接口，如果没有实现接口，在代理时就会类转换异常</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li>TreeSet：基于红黑树实现底层使用TreeMap储存，不允许放入null值，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li><li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。<ul><li>不能保证元素的排列顺序，顺序有可能发生变化</li><li>不是同步的</li><li>集合元素可以是null,但只能放入一个null</li><li>要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的 String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例</li></ul></li><li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</li></ul><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul><li>ArrayList：基于动态数组实现，支持随机访问。<ul><li>继承AbstractList，实现RandomAccess、Cloneable、Serializable等接口</li><li>1.5倍扩容</li><li>transient关键字修饰elementData，保证未填满的数据不参与序列化，序列化通过readObject和writeObject实现</li><li>sort方法使用TimSort，是一个经过大量优化的归并+插入排序</li></ul></li><li>Vector：和 ArrayList 类似，但它是线程安全的。通过方法加synchronized</li><li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul><li>LinkedList：可以用它来实现双向队列。</li><li>PriorityQueue：基于数组表示的小顶堆结构实现，可以用它来实现优先队列</li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li><p>TreeMap：基于红黑树实现。支持值null不支持键null</p></li><li><p>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p></li><li><p>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p></li><li><p>HashMap：基于哈希表实现。支持键值双null</p><ul><li>成员变量<ul><li>初始化桶大小，因为底层是数组，所以这是数组默认的大小。</li><li>桶最大值。</li><li>默认的负载因子（0.75）</li><li>TREEIFY_THRESHOLD 用于判断是否需要将链表转换为红黑树的阈值。</li><li>HashEntry 修改为 Node。</li><li>Map 存放数量的大小。</li><li>桶大小，可在初始化时显式指定。</li><li>负载因子，可在初始化时显式指定。</li></ul></li><li>put方法<ol><li>判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化）。</li><li>根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。</li><li>如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 key、key 的 hashcode 与写入的 key 是否相等，相等就赋值给 e,在第 8 步的时候会统一进行赋值及返回。</li><li>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。</li><li>如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。</li><li>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</li><li>如果在遍历过程中找到 key 相同时直接退出遍历。</li><li>如果 e != null 就相当于存在相同的 key,那就需要将值覆盖。</li><li>最后判断是否需要进行扩容。</li></ol></li><li>get方法<ol><li>首先将 key hash 之后取得所定位的桶。</li><li>如果桶为空则直接返回 null 。</li><li>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。</li><li>如果第一个不匹配，则判断它的下一个是红黑树还是链表。</li><li>红黑树就按照树的查找方式返回值。</li><li>不然就按照链表的方式遍历匹配返回值。</li></ol></li></ul></li><li><p>ConcurrentHashMap</p><ul><li>源码阅读参考 <a href="https://www.cnblogs.com/cjsblog/p/10017911.html" target="_blank" rel="noopener">来源</a></li><li>原理<ul><li>1.7ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</li><li>1.8抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性，HashEntry 改为 Node,因为不再使用 Segment，初始化操作大大简化，修改为 lazy-load 形式，这样可以有效避免初始开销,数据存储利用 volatile 来保证可见性</li></ul></li><li>1.7put方法<ol><li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li><li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li><li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li><li>最后会解除在 1 中所获取当前 Segment 的锁</li></ol></li><li>1.8put方法<ol><li>根据 key 计算出 hashcode 。</li><li>判断是否需要进行初始化。</li><li>f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li><li>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</li><li>如果都不满足，则利用 synchronized 锁写入数据。</li><li>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树</li></ol></li><li>1.7get方法<ol><li>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</li><li>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</li><li>ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁</li></ol></li><li>1.8get方法<ol><li>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</li><li>如果是红黑树那就按照树的方式获取值。</li><li>就不满足那就按照链表的方式遍历获取值</li></ol></li></ul></li><li><p>LinkedHashMap</p><ul><li><p>存储结构</p><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用* </p></li><li><p>afterNodeAccess()</p><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p></li><li><p>afterNodeInsertion()</p><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。evict 只有在构建 Map 的时候才为 false，在这里为 true。removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p></li><li><p>LRU 缓存</p><ul><li>设定最大缓存空间 MAX_ENTRIES  为 3；</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li></ul></li></ul></li><li><p>WeakHashMap</p><ul><li><p>存储结构</p><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p><p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p></li><li><p>ConcurrentCache</p><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。ConcurrentCache 采取的是分代缓存：</p><ul><li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li></ul></li></ul><ul><li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。<ul><li>当调用  get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li><li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li></ul></li></ul></li></ul><h2 id="JavaIO"><a href="#JavaIO" class="headerlink" title="JavaIO"></a>JavaIO</h2><h3 id="分类概述"><a href="#分类概述" class="headerlink" title="分类概述"></a>分类概述</h3><ul><li>磁盘操作：File</li><li>字节操作：InputStream 和 OutputStream</li><li>字符操作：Reader 和 Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>新的输入/输出：NIO</li></ul><h3 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h3><ul><li>使用File类<ul><li>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</li></ul></li></ul><h3 id="字节操作"><a href="#字节操作" class="headerlink" title="字节操作"></a>字节操作</h3><ul><li>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，<ul><li>InputStream 是抽象组件；</li><li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li><li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li></ul></li></ul><h3 id="字符操作"><a href="#字符操作" class="headerlink" title="字符操作"></a>字符操作</h3><h4 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h4><blockquote><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p></blockquote><ul><li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li><li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li><li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。<ul><li>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</li><li>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</li></ul></li></ul><h4 id="String-的编码方式"><a href="#String-的编码方式" class="headerlink" title="String 的编码方式"></a>String 的编码方式</h4><blockquote><p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p></blockquote><pre class=" language-java"><code class="language-java">String str1 <span class="token operator">=</span> <span class="token string">"中文"</span><span class="token punctuation">;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="Reader-与-Writer"><a href="#Reader-与-Writer" class="headerlink" title="Reader 与 Writer"></a>Reader 与 Writer</h4><blockquote><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p></blockquote><ul><li>InputStreamReader 实现从字节流解码成字符流；</li><li>OutputStreamWriter 实现字符流编码成为字节流。</li></ul><h3 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h3><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ul><li><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p><ul><li>序列化：ObjectOutputStream.writeObject()</li><li>反序列化：ObjectInputStream.readObject()</li></ul></li><li><p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p></li></ul><h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><ul><li>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</li></ul><h3 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h3><h4 id="Java-中的网络支持"><a href="#Java-中的网络支持" class="headerlink" title="Java 中的网络支持"></a>Java 中的网络支持</h4><ul><li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li><li>URL：统一资源定位符；</li><li>Sockets：使用 TCP 协议实现网络通信；</li><li>Datagram：使用 UDP 协议实现网络通信。</li></ul><h4 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h4><p>没有公有的构造函数，只能通过静态方法来创建实例。</p><pre class=" language-java"><code class="language-java">InetAddress<span class="token punctuation">.</span><span class="token function">getByName</span><span class="token punctuation">(</span>String host<span class="token punctuation">)</span><span class="token punctuation">;</span>InetAddress<span class="token punctuation">.</span><span class="token function">getByAddress</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>可以直接从 URL 中读取字节流数据。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    URL url<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"http://www.baidu.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    BufferedReader reader<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">openStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String line<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="Sockets"><a href="#Sockets" class="headerlink" title="Sockets"></a>Sockets</h4><ul><li>ServerSocket：服务器端类</li><li>Socket：客户端类</li><li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li></ul><h4 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h4><ul><li>DatagramSocket：通信类</li><li>DatagramPacket：数据包类</li></ul><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><blockquote><p>新的输入/输出 (NIO) 库在 JDK 1.4 中引入，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O</p></blockquote><h4 id="流与块"><a href="#流与块" class="headerlink" title="流与块"></a>流与块</h4><ul><li>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</li><li>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</li><li>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</li><li>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</li></ul><h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><ul><li>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</li><li>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</li><li>通道包括以下类型：<ul><li>FileChannel：从文件中读写数据；</li><li>DatagramChannel：通过 UDP 读写网络中数据；</li><li>SocketChannel：通过 TCP 读写网络中数据；</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul></li></ul><h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><ul><li>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</li><li>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</li><li>缓冲区包括以下类型：<ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul></li><li>缓冲区状态变量<ul><li>capacity：最大容量；</li><li>position：当前已经读写的字节数；</li><li>limit：还可以读写的字节数。</li></ul></li></ul><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><ul><li><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p></li><li><p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p></li><li><p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p></li><li><p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用性能更优。</p></li><li><p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p></li><li><p>实例</p><ol><li><p>创建选择器</p><pre class=" language-java"><code class="language-java">Selector selector <span class="token operator">=</span> Selector<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>将通道注册到选择器上</p><pre class=" language-java"><code class="language-java">ServerSocketChannel ssChannel <span class="token operator">=</span> ServerSocketChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ssChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ssChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> SelectionKey<span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p><p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>它们在 SelectionKey 的定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_READ <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_WRITE <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_CONNECT <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> OP_ACCEPT <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span></code></pre><p>  可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> interestSet <span class="token operator">=</span> SelectionKey<span class="token punctuation">.</span>OP_READ <span class="token operator">|</span> SelectionKey<span class="token punctuation">.</span>OP_WRITE<span class="token punctuation">;</span></code></pre></li><li><p>监听事件</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> num <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p><p>获取到达的事件</p><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keyIterator <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    SelectionKey key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span>    keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>事件循环</p><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Set<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Iterator<span class="token operator">&lt;</span>SelectionKey<span class="token operator">></span> keyIterator <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SelectionKey key <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// ...</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// ...</span>        <span class="token punctuation">}</span>        keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
